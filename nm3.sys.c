/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

NDIS_STATUS __fastcall NetmonSetOptions(NDIS_HANDLE NdisDriverHandle, NDIS_HANDLE DriverContext);
NDIS_STATUS __fastcall NetmonFilterPause(FilterDeviceExtension *FilterModuleContext, PNDIS_FILTER_PAUSE_PARAMETERS PauseParameters);
NDIS_STATUS __fastcall NetmonFilterRestart(FilterDeviceExtension *FilterModuleContext, PNDIS_FILTER_RESTART_PARAMETERS RestartParameters);
NDIS_STATUS __fastcall NetmonOidRequest(FilterDeviceExtension *FilterModuleContext, PNDIS_OID_REQUEST OidRequest);
void __fastcall NetmonOidRequestComplete(FilterDeviceExtension *FilterModuleContext, PNDIS_OID_REQUEST OidRequest, NDIS_STATUS Status);
void __fastcall NetmonFilterStatus(FilterDeviceExtension *FilterModuleContext, PNDIS_STATUS_INDICATION StatusIndication);
NDIS_STATUS __fastcall NetmonFilterSetModuleOptions(FilterDeviceExtension *FilterModuleContext);
NDIS_STATUS __fastcall nmFilterDoInternalRequest(int Oid, FilterDeviceExtension *DeviceExtension, int RequestType_1, __int64 *Information, unsigned int InformationBufferLength, int a6, __int64 a7, unsigned int *BufferLength);
NDIS_STATUS __fastcall NmRegisterFilter(PDRIVER_OBJECT DriverObject);
NDIS_STATUS __fastcall nmOid_Query(int a1, FilterDeviceExtension *a2, __int64 *a3, unsigned int a4);
NDIS_STATUS __fastcall NmGetGlobalStat(FilterDeviceExtension *FilterDeviceExtension, int n, __int64 *a3, unsigned int a4);
void __fastcall NmDerefCaptureBuffer(CaptureBuffer *CaptureBuffer); // idb
void __fastcall NmDestroyCaptureBuffer(CaptureBuffer *CaptureBuffer);
__int64 __fastcall NmCaptureFilterMatch(__int64 a1, __int64 a2);
NTSTATUS __fastcall NmGetFilterSize(_IRP *a1, _DWORD *a2, _DWORD *a3, _IRP *a4);
NTSTATUS __fastcall NmUnserializeCaptureFilter(FileContext *FsContext, _IRP *MasterIrp, unsigned int a3, _IRP **Irp_1);
NTSTATUS __fastcall NmAddCaptureFilter(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmDeleteCaptureFilter(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterRootDeviceIoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterRootDeviceIoClose(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterRootDeviceIoCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp);
RootDeviceExtension *__fastcall GetFilterRootDevice(PDEVICE_OBJECT DeviceObject);
RootDeviceExtension *__fastcall TestFilterRootDeviceSignature(PDEVICE_OBJECT DeviceObject);
NTSTATUS __fastcall NmAddGroupAccessAce(PDEVICE_OBJECT pDeviceObject);
GroupAce *__fastcall GetAceFromAcl(PACL Dacl, unsigned int a2);
char __fastcall AddAceToAcl(ACL *acl, GroupAce *GroupAce);
void __fastcall pNmDot11StoreCurrentIfc(Dot11Filter *Dot11, int a2);
void __fastcall pNmDot11StoreOpMode(Dot11Filter *Dot11, int a2);
__int64 __fastcall pNmDot11QueryMonitorMode(Dot11Filter *Dot11);
__int64 __fastcall pNmDot11QueryCurrentIfc(FilterDeviceExtension *DeviceExtension);
void __fastcall NmDeleteDot11Parameters(Dot11Filter *Dot11);
NTSTATUS __fastcall NmCreateDot11Filter(NDIS_HANDLE NdisHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameter, Dot11Filter **Dot11Filter);
NTSTATUS __fastcall NmDot11SetPhyId(FilterDeviceExtension *DeviceExtension, unsigned int a2);
__int64 __fastcall NmDot11SetChannel(FilterDeviceExtension *DeviceExtension, unsigned int channel_1);
void __fastcall NetmonUnload(struct _DRIVER_OBJECT *DriverObject);
NDIS_STATUS __fastcall NmSetPacketFilter(FilterDeviceExtension *ModuleContext, int filter);
__int64 __fastcall NmQueryPacketFilter(FilterDeviceExtension *ModuleContext, __int64 Q);
_BOOL8 __fastcall NmSetAppropriatePacketFilter(FilterDeviceExtension *DeviceExtension, int a2); // idb
NTSTATUS __fastcall CopyUnicodeStringToBuffer(void *a1, unsigned __int64 a2, _DWORD *a3, const void **a4);
NTSTATUS __fastcall NmEnumNetworks(PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation, size_t *Information);
NTSTATUS __fastcall NmCopyBufferToMdlWrapper(PMDL *MdlAddress, const void *a2, unsigned int a3, _DWORD *a4);
__int64 __fastcall NmInitializeGlobals(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
NTSTATUS __fastcall LookupFilterModule(NDIS_HANDLE NdisFilterHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters, FilterDeviceExtension **DeferredContext);
NDIS_STATUS __fastcall NetmonFilterAttach(NDIS_HANDLE NdisFilterHandle, NDIS_HANDLE FilterDriverContext, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters);
void __fastcall NetmonFilterDetach(FilterDeviceExtension *FilterModuleContext);
NTSTATUS __fastcall NmCreateFilterModule(NDIS_HANDLE NdisFilterHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters, FilterDeviceExtension **DeferredContext);
void __fastcall NmDestroyFilterModule(FilterDeviceExtension *DeviceExtension);
NTSTATUS __fastcall NmBuildDeviceName(NDIS_HANDLE NdisFilterHandle, PNDIS_STRING FilterModuleGuidName, const WCHAR *str, UNICODE_STRING *__struct_ptr Name);
void __fastcall StackModuleInstance(FilterDeviceExtension *FilterModuleContext, int b);
NTSTATUS __fastcall NmFilterModuleIoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterModuleIoClose(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterModuleIoCleanup(PDEVICE_OBJECT DeviceObject, PIRP Irp);
void __fastcall NmIoReadCancelRoutine(_DEVICE_OBJECT *DeviceObject, _IRP *Irp); // idb
NTSTATUS __fastcall NmFilterModuleIoRead(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterModuleIoCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp);
BOOL __fastcall TestFilterModuleSignature(PDEVICE_OBJECT DeviceObject);
void __fastcall NetmonDevicePnPEventNotify(FilterDeviceExtension *FilterModuleContext, PNET_DEVICE_PNP_EVENT NetDevicePnPEvent);
NDIS_STATUS __fastcall NetmonNetPnPEvent(FilterDeviceExtension *FilterModuleContext, PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification);
__int64 __fastcall NetmonGetTimeStamp(FilterDeviceExtension *FilterModuleContext, __int64 *a2);
void __fastcall NetmonReceiveNetBufferLists(FilterDeviceExtension *FilterModuleContext, PNET_BUFFER_LIST NetBufferLists, NDIS_PORT_NUMBER PortNumber, ULONG NumberOfNetBufferLists, ULONG ReceiveFlags);
void __fastcall NetmonSendNetBufferLists(FilterDeviceExtension *FilterModuleContext, PNET_BUFFER_LIST NetBufferList, NDIS_PORT_NUMBER PortNumber, ULONG SendFlags);
void __fastcall NmCopySingleNetBuffer(_DWORD *a1, __int64 a2, __int64 a3, FilterDeviceExtension *FilterModuleContext, __int64 a5, void *a6, unsigned int a7);
NTSTATUS __fastcall NmCopyNetBufferToCaptureBuffer(FilterDeviceExtension *FilterModuleContext, unsigned int edx0, void *a2, char *r9_0, unsigned int a3, void *a2a, void *a7, unsigned int a3a);
__int64 __fastcall NmCopyNetBufferToMdlWrapper(PMDL *MdlAddress, __int64 a2, _DWORD *a3);
void __fastcall NmSyncTimerSystem(FilterDeviceExtension *Context);
void __fastcall ScanLongTimersDpc(struct _KDPC *Dpc, FilterDeviceExtension *DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2); // idb
void __fastcall NmInitializeTimerSystem(FilterDeviceExtension *DeviceExtension);
BOOL __fastcall NmStopTimerSystem(FilterDeviceExtension *DeviceExtension);
void __fastcall NmDerefUserProc(FileContext *FsContext);
NTSTATUS __fastcall NmOpenUserProc(FilterDeviceExtension *FilterDeviceExtension, PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation);
__int64 __fastcall NmCreateUserProc(FilterDeviceExtension *FilterDeviceExtension, FileContext **ctx1, FileContext **ctx2);
NTSTATUS __fastcall NmVerifyUserProcObject(FileContext *FsContext);
__int64 __fastcall NmDestroyUserProc(FileContext *Parameter);
void __fastcall NmStopUserProc(FileContext *FsContext);
NTSTATUS __fastcall NmUserProcCaptureStart(PDEVICE_OBJECT DeviceObject, PIRP Irp);
void __fastcall NmUploadCaptureBuffer(volatile FilterDeviceExtension *DeviceExtension, FileContext *FsContext);
NTSTATUS __fastcall NmUserProcCaptureStop(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmCloseUserProc(PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation);
void __fastcall NmUserProcGetStats(PDEVICE_OBJECT DeviceObject, FileContext *Context); // idb
// void __fastcall _security_check_cookie(uintptr_t StackCookie);
// void __fastcall __noreturn _report_gsfailure(ULONG_PTR BugCheckParameter1); idb
// void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// __int64 __fastcall _GSHandlerCheckCommon(__int64 a1, __int64 a2);
// __int64 __fastcall _GSHandlerCheck(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// EXCEPTION_DISPOSITION __cdecl _C_specific_handler_0(struct _EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, struct _CONTEXT *ContextRecord, struct _DISPATCHER_CONTEXT *DispatcherContext);
// LARGE_INTEGER __stdcall KeQueryPerformanceCounter(PLARGE_INTEGER PerformanceFrequency);
// NDIS_STATUS NdisFNetPnPEvent(NDIS_HANDLE NdisFilterHandle, PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification);
// void NdisFDevicePnPEventNotify(NDIS_HANDLE NdisFilterHandle, PNET_DEVICE_PNP_EVENT NetDevicePnPEvent);
// NDIS_STATUS NdisFRestartFilter(NDIS_HANDLE NdisFilterHandle);
// NDIS_STATUS NdisFSetAttributes(NDIS_HANDLE NdisFilterHandle, NDIS_HANDLE FilterModuleContext, PNDIS_FILTER_ATTRIBUTES FilterAttributes);
// void NdisFDeregisterFilterDriver(NDIS_HANDLE NdisFilterDriverHandle);
// PVOID NdisAllocateMemoryWithTagPriority(NDIS_HANDLE NdisHandle, UINT Length, ULONG Tag, EX_POOL_PRIORITY Priority);
// void __stdcall NdisFreeMemory(PVOID VirtualAddress, UINT Length, UINT MemoryFlags);
// void NdisDeregisterDeviceEx(NDIS_HANDLE NdisDeviceHandle);
// PVOID NdisGetDeviceReservedExtension(PDEVICE_OBJECT DeviceObject);
// NDIS_STATUS NdisRegisterDeviceEx(NDIS_HANDLE NdisHandle, PNDIS_DEVICE_OBJECT_ATTRIBUTES DeviceObjectAttributes, PDEVICE_OBJECT *pDeviceObject, PNDIS_HANDLE NdisDeviceHandle);
// NDIS_STATUS NdisFRegisterFilterDriver(PDRIVER_OBJECT DriverObject, NDIS_HANDLE FilterDriverContext, PNDIS_FILTER_DRIVER_CHARACTERISTICS FilterDriverCharacteristics, PNDIS_HANDLE NdisFilterDriverHandle);
// void NdisFIndicateReceiveNetBufferLists(NDIS_HANDLE NdisFilterHandle, PNET_BUFFER_LIST NetBufferLists, NDIS_PORT_NUMBER PortNumber, ULONG NumberOfNetBufferLists, ULONG ReceiveFlags);
// void __stdcall NdisSetEvent(PNDIS_EVENT Event);
// BOOLEAN __stdcall NdisWaitEvent(PNDIS_EVENT Event, UINT msToWait);
// void __stdcall NdisInitializeEvent(PNDIS_EVENT Event);
// NDIS_STATUS NdisSetOptionalHandlers(NDIS_HANDLE NdisHandle, PNDIS_DRIVER_OPTIONAL_HANDLERS OptionalHandlers);
// void NdisFIndicateStatus(NDIS_HANDLE NdisFilterHandle, PNDIS_STATUS_INDICATION StatusIndication);
// void NdisFOidRequestComplete(NDIS_HANDLE NdisFilterHandle, PNDIS_OID_REQUEST OidRequest, NDIS_STATUS Status);
// void NdisFreeCloneOidRequest(NDIS_HANDLE SourceHandle, PNDIS_OID_REQUEST Request);
// NDIS_STATUS NdisFOidRequest(NDIS_HANDLE NdisFilterHandle, PNDIS_OID_REQUEST OidRequest);
// NDIS_STATUS NdisAllocateCloneOidRequest(NDIS_HANDLE SourceHandle, PNDIS_OID_REQUEST OidRequest, UINT PoolTag, PNDIS_OID_REQUEST *ClonedOidRequest);
// void __stdcall NdisCloseConfiguration(NDIS_HANDLE ConfigurationHandle);
// NDIS_STATUS NdisOpenConfigurationEx(PNDIS_CONFIGURATION_OBJECT ConfigObject, PNDIS_HANDLE ConfigurationHandle);
// void NdisFSendNetBufferLists(NDIS_HANDLE NdisFilterHandle, PNET_BUFFER_LIST NetBufferList, NDIS_PORT_NUMBER PortNumber, ULONG SendFlags);
// NTSTATUS __stdcall IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName);
// PIO_WORKITEM __stdcall IoAllocateWorkItem(PDEVICE_OBJECT DeviceObject);
// void __stdcall IoQueueWorkItem(PIO_WORKITEM IoWorkItem, PIO_WORKITEM_ROUTINE WorkerRoutine, WORK_QUEUE_TYPE QueueType, PVOID Context);
// BOOLEAN __stdcall KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
// void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
// void __stdcall KeInitializeTimer(PKTIMER Timer);
// BOOLEAN __stdcall KeCancelTimer(PKTIMER);
// void __stdcall ExQueueWorkItem(PWORK_QUEUE_ITEM WorkItem, WORK_QUEUE_TYPE QueueType);
// PEPROCESS IoGetCurrentProcess(void);
// NTSTATUS __stdcall ExDeleteResourceLite(PERESOURCE Resource);
// void __stdcall IoSetShareAccess(ACCESS_MASK DesiredAccess, ULONG DesiredShareAccess, PFILE_OBJECT FileObject, PSHARE_ACCESS ShareAccess);
// NTSTATUS __stdcall SeAssignSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR ExplicitDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOLEAN IsDirectoryObject, PSECURITY_SUBJECT_CONTEXT SubjectContext, PGENERIC_MAPPING GenericMapping, POOL_TYPE PoolType);
// void IoRemoveShareAccess(PFILE_OBJECT FileObject, PSHARE_ACCESS ShareAccess);
// void __stdcall ExReleaseResourceLite(PERESOURCE Resource);
// NTSTATUS __stdcall SeDeassignSecurity(PSECURITY_DESCRIPTOR *SecurityDescriptor);
// void KeEnterCriticalRegion(void);
// void KeLeaveCriticalRegion(void);
// void __stdcall IoFreeWorkItem(PIO_WORKITEM IoWorkItem);
// void __stdcall __noreturn KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// NTSTATUS __stdcall ExInitializeResourceLite(PERESOURCE Resource);
// void __stdcall IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
// NTSTATUS __stdcall IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName, PUNICODE_STRING DeviceName);
// NTSTATUS __stdcall IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, ULONG DeviceType, ULONG DeviceCharacteristics, BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject);
// NTSTATUS __stdcall ZwQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
// NTSTATUS __stdcall ZwOpenKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// NTSTATUS __stdcall ZwSetSecurityObject(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);
// NTSTATUS __stdcall RtlSetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, BOOLEAN DaclPresent, PACL Dacl, BOOLEAN DaclDefaulted);
// NTSTATUS __stdcall RtlCreateSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Revision);
// PVOID __stdcall ExAllocatePool(POOL_TYPE PoolType, SIZE_T NumberOfBytes);
// ULONG __stdcall RtlLengthSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor);
// NTSTATUS __stdcall RtlGetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, PBOOLEAN DaclPresent, PACL *Dacl, PBOOLEAN DaclDefaulted);
// NTSTATUS ObOpenObjectByPointer(PVOID Object, ULONG HandleAttributes, PACCESS_STATE PassedAccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PHANDLE Handle);
// void __stdcall IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
// PVOID __stdcall MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList, KPROCESSOR_MODE AccessMode, MEMORY_CACHING_TYPE CacheType, PVOID BaseAddress, ULONG BugCheckOnFailure, MM_PAGE_PRIORITY Priority);
// void __stdcall IoReleaseCancelSpinLock(KIRQL Irql);
// void __stdcall IoAcquireCancelSpinLock(PKIRQL Irql);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// ULONG DbgPrintEx(ULONG ComponentId, ULONG Level, PCSTR Format, ...);
// void __stdcall KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// void __stdcall KeReleaseSpinLockFromDpcLevel(PKSPIN_LOCK SpinLock);
// KIRQL __stdcall KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock);
// BOOLEAN __stdcall ExAcquireResourceExclusiveLite(PERESOURCE Resource, BOOLEAN Wait);
// void __stdcall KeAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock);
// EXCEPTION_DISPOSITION __cdecl __C_specific_handler(struct _EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, struct _CONTEXT *ContextRecord, struct _DISPATCHER_CONTEXT *DispatcherContext);
void __fastcall NmInitializeMinipInfo(NDIS_MEDIUM MiniportMediaType, FilterDeviceExtension *FilterModuleContext);
NTSTATUS __fastcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
// void __cdecl _security_init_cookie();
// NTSTATUS __stdcall GsDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);

//-------------------------------------------------------------------------
// Data declarations

char aNmuserprocea[13] = "NmUserProcEa"; // weak
GENERIC_MAPPING g_GenericMapping = { 131072u, 131072u, 131072u, 131072u }; // idb
int g_TimeSyncIntervalCount = 20; // weak
int g_FilterScanTimerInterval = 500; // weak
int g_OlpFilterConditionMaxCount = 16; // weak
_UNKNOWN g_NmDriverVersion; // weak
_UNKNOWN DefaultCharacteristics; // weak
PVOID g_FilterDriverHandle = NULL; // idb
NDIS_HANDLE g_FilterDeviceHandle = NULL; // idb
LIST_ENTRY g_FilterModuleList = { NULL, NULL };
LIST_ENTRY g_ByPassFilterModuleList = { NULL, NULL };
GroupAce *g_GroupAce = NULL;
int g_AttachUpperLayers = 0; // weak
int g_NmDebug = 0; // weak
__int64 g_DriverStartTimeStamp = 0i64; // weak
int g_InternalRequestFailedCount = 0; // weak
KSPIN_LOCK g_FilterListLock = 0ui64; // idb
KIRQL g_Irql = 0u; // idb
PDRIVER_OBJECT g_FilterDriverObject = NULL; // idb


//----- (0000000000011008) ----------------------------------------------------
NDIS_STATUS __fastcall NetmonSetOptions(NDIS_HANDLE NdisDriverHandle, NDIS_HANDLE DriverContext)
{
  NDIS_STATUS result; // eax

  if ( NdisDriverHandle == g_FilterDriverHandle && DriverContext == g_FilterDriverObject )
    result = STATUS_SUCCESS;
  else
    result = STATUS_INVALID_PARAMETER;
  return result;
}

//----- (000000000001102C) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonFilterPause(FilterDeviceExtension *FilterModuleContext, PNDIS_FILTER_PAUSE_PARAMETERS PauseParameters)
{
  KIRQL NewIrql; // al

  NewIrql = KeAcquireSpinLockRaiseToDpc(&FilterModuleContext->SpinLock);
  FilterModuleContext->State = FilterPausing;
  FilterModuleContext->irql = NewIrql;
  KeReleaseSpinLock(&FilterModuleContext->SpinLock, NewIrql);
  return STATUS_SUCCESS;
}

//----- (0000000000011078) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonFilterRestart(FilterDeviceExtension *FilterModuleContext, PNDIS_FILTER_RESTART_PARAMETERS RestartParameters)
{
  PNDIS_RESTART_ATTRIBUTES RestartAttributes; // rax
  KIRQL irql; // al
  NDIS_CONFIGURATION_OBJECT ConfigObject; // [rsp+20h] [rbp-28h] BYREF
  NDIS_HANDLE ConfigurationHandle; // [rsp+50h] [rbp+8h] BYREF

  ConfigurationHandle = NULL;
  ConfigObject.Header.Size = 0x18;
  ConfigObject.Header.Type = NDIS_OBJECT_TYPE_CONFIGURATION_OBJECT;
  ConfigObject.Header.Revision = NDIS_CONFIGURATION_OBJECT_REVISION_1;
  ConfigObject.NdisHandle = g_FilterDriverHandle;
  ConfigObject.Flags = 0;
  if ( !NdisOpenConfigurationEx(&ConfigObject, &ConfigurationHandle) )
    NdisCloseConfiguration(ConfigurationHandle);
  RestartAttributes = RestartParameters->RestartAttributes;
  if ( RestartAttributes )
  {
    *(_DWORD *)RestartAttributes[1].Data = 128; // 参见：\Windows-driver-samples\network\ndis\filter\filter.c的FilterRestart函数。
                                                // 
                                                // NdisGeneralAttributes = (PNDIS_RESTART_GENERAL_ATTRIBUTES)NdisRestartAttributes->Data;
                                                // NdisGeneralAttributes->LookaheadSize = 128;
    do
      RestartAttributes = RestartAttributes->Next;
    while ( RestartAttributes );
  }
  irql = KeAcquireSpinLockRaiseToDpc(&FilterModuleContext->SpinLock);
  FilterModuleContext->State = FilterPaused;    // 3估计是自定义的枚举值，表示运行状态，参见：\Windows-driver-samples\network\ndis\filter\filter.h的FILTER_STATE
  FilterModuleContext->irql = irql;
  KeReleaseSpinLock(&FilterModuleContext->SpinLock, irql);
  return STATUS_SUCCESS;
}

//----- (0000000000011128) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonOidRequest(FilterDeviceExtension *FilterModuleContext, PNDIS_OID_REQUEST OidRequest)
{
  unsigned int NtStatus_2; // eax
  NDIS_STATUS NtStatus; // edi
  PNDIS_OID_REQUEST OidRequest_2; // rdx
  PVOID InformationBuffer; // rbx
  int Information; // ebp
  KIRQL irql; // al
  bool b; // zf
  NDIS_STATUS NtStatus_1; // eax
  PNDIS_OID_REQUEST OidRequesta; // [rsp+30h] [rbp+8h] BYREF

  OidRequesta = NULL;
  NtStatus_2 = NdisAllocateCloneOidRequest(FilterModuleContext->NdisFilterHandle, OidRequest, 'dnTF', &OidRequesta);
  NtStatus = NtStatus_2;
  if ( NtStatus_2 )
  {
    DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NetmonOidRequest Clone failed: %x\n", NtStatus_2);
    if ( OidRequest->RequestType == NdisRequestSetInformation || OidRequest->RequestType != (NdisRequestGeneric1|NdisRequestClose) )// NdisRequestMethod = 0xc
    {
      OidRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
      OidRequest->DATA.QUERY_INFORMATION.BytesNeeded = 0;
    }
    else
    {
      OidRequest->DATA.METHOD_INFORMATION.BytesRead = 0;
      OidRequest->DATA.METHOD_INFORMATION.BytesNeeded = 0;
      OidRequest->DATA.METHOD_INFORMATION.BytesWritten = 0;
    }
  }
  else
  {
    *(_QWORD *)&OidRequesta[1].DATA.METHOD_INFORMATION.MethodId = OidRequest;
    OidRequesta->RequestId = OidRequest->RequestId;
    OidRequest_2 = OidRequesta;
    FilterModuleContext->OidRequesta = OidRequesta;
    if ( OidRequest_2->RequestType == NdisRequestSetInformation
      && OidRequest_2->DATA.QUERY_INFORMATION.Oid == 0x1010E
      && OidRequest_2->DATA.QUERY_INFORMATION.InformationBufferLength == 4 )
    {
      InformationBuffer = OidRequest_2->DATA.QUERY_INFORMATION.InformationBuffer;
      Information = *(_DWORD *)InformationBuffer;
      irql = KeAcquireSpinLockRaiseToDpc(&FilterModuleContext->SpinLock);
      b = FilterModuleContext->dword21C == 0;
      FilterModuleContext->irql = irql;
      LODWORD(FilterModuleContext->filter) = *(_DWORD *)InformationBuffer;
      if ( !b )
        *(_DWORD *)InformationBuffer = Information | HIDWORD(FilterModuleContext->filter);
      KeReleaseSpinLock(&FilterModuleContext->SpinLock, FilterModuleContext->irql);
      OidRequest_2 = OidRequesta;
    }
    NtStatus_1 = NdisFOidRequest(FilterModuleContext->NdisFilterHandle, OidRequest_2);
    NtStatus = NtStatus_1;
    if ( NtStatus_1 != NDIS_STATUS_PENDING )
    {
      NetmonOidRequestComplete(FilterModuleContext, OidRequesta, NtStatus_1);
      NtStatus = NDIS_STATUS_PENDING;
    }
  }
  return NtStatus;
}

//----- (000000000001126C) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonOidRequestComplete(FilterDeviceExtension *FilterModuleContext, PNDIS_OID_REQUEST OidRequest, NDIS_STATUS Status)
{
  PNDIS_OID_REQUEST OidRequest_2; // rdi
  __int32 RequestType; // ecx
  Dot11Filter *Dot11; // rcx

  OidRequest_2 = *(PNDIS_OID_REQUEST *)&OidRequest[1].DATA.METHOD_INFORMATION.MethodId;
  if ( OidRequest_2 )
  {
    FilterModuleContext->OidRequesta = 0i64;
    RequestType = OidRequest->RequestType - 1;
    OidRequest_2->DATA.QUERY_INFORMATION.BytesWritten = OidRequest->DATA.QUERY_INFORMATION.BytesWritten;
    if ( RequestType )
    {
      if ( RequestType == NdisRequestGeneric4 )
      {
        *(_QWORD *)&OidRequest_2->DATA.METHOD_INFORMATION.BytesRead = *(_QWORD *)&OidRequest->DATA.METHOD_INFORMATION.BytesRead;
        OidRequest_2->DATA.METHOD_INFORMATION.BytesWritten = OidRequest->DATA.METHOD_INFORMATION.BytesWritten;
      }
      else
      {
        OidRequest_2->DATA.QUERY_INFORMATION.BytesNeeded = OidRequest->DATA.QUERY_INFORMATION.BytesNeeded;
      }
    }
    else
    {
      OidRequest_2->DATA.QUERY_INFORMATION.BytesNeeded = OidRequest->DATA.QUERY_INFORMATION.BytesNeeded;
      Dot11 = FilterModuleContext->Dot11;
      if ( Dot11
        && OidRequest->DATA.QUERY_INFORMATION.Oid == OID_DOT11_CURRENT_OPERATION_MODE
        && !Status
        && OidRequest->DATA.QUERY_INFORMATION.InformationBufferLength >= 8 )
      {
        pNmDot11StoreOpMode(Dot11, *((_DWORD *)OidRequest->DATA.QUERY_INFORMATION.InformationBuffer + 1));
      }
    }
    *(_QWORD *)&OidRequest[1].DATA.METHOD_INFORMATION.MethodId = 0i64;
    NdisFreeCloneOidRequest(FilterModuleContext->NdisFilterHandle, OidRequest);
    NdisFOidRequestComplete(FilterModuleContext->NdisFilterHandle, OidRequest_2, Status);
  }
  else
  {
    *(_DWORD *)&OidRequest[1].NdisReserved[32] = Status;
    NdisSetEvent((PNDIS_EVENT)&OidRequest[1].NdisReserved[8]);
  }
}

//----- (0000000000011358) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonFilterStatus(FilterDeviceExtension *FilterModuleContext, PNDIS_STATUS_INDICATION StatusIndication)
{
  NdisFIndicateStatus(FilterModuleContext->NdisFilterHandle, StatusIndication);
}

//----- (000000000001136C) ----------------------------------------------------
// 第一个参数名誉上是NDIS_HANDLE。
// 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonFilterSetModuleOptions(FilterDeviceExtension *FilterModuleContext)
{
  void (__fastcall *ReceiveNetBufferLists)(FilterDeviceExtension *, PNET_BUFFER_LIST, NDIS_PORT_NUMBER, ULONG, ULONG); // rax
  NDIS_DRIVER_OPTIONAL_HANDLERS OptionalHandlers; // [rsp+20h] [rbp-38h] BYREF
  void (__fastcall *SendNetBufferLists)(FilterDeviceExtension *, PNET_BUFFER_LIST, NDIS_PORT_NUMBER, ULONG); // [rsp+28h] [rbp-30h]
  void (__fastcall *ReceiveNetBufferList)(FilterDeviceExtension *, PNET_BUFFER_LIST, NDIS_PORT_NUMBER, ULONG, ULONG); // [rsp+40h] [rbp-18h]

  memmove(&OptionalHandlers, &DefaultCharacteristics, 0x30u);
  _InterlockedAdd(&FilterModuleContext->field_210, 1u);
  ReceiveNetBufferLists = NULL;
  if ( BYTE2(FilterModuleContext->gap20C) )
  {
    SendNetBufferLists = NetmonSendNetBufferLists;
    ReceiveNetBufferLists = NetmonReceiveNetBufferLists;
  }
  else
  {
    SendNetBufferLists = NULL;
  }
  ReceiveNetBufferList = ReceiveNetBufferLists;
  if ( _InterlockedExchangeAdd(&FilterModuleContext->field_210, 0xFFFFFFFF) == 1 )
    NmDestroyFilterModule(FilterModuleContext);
  return NdisSetOptionalHandlers(FilterModuleContext->NdisFilterHandle, &OptionalHandlers);
}

//----- (00000000000113F0) ----------------------------------------------------
NDIS_STATUS __fastcall nmFilterDoInternalRequest(int Oid, FilterDeviceExtension *DeviceExtension, int RequestType_1, __int64 *Information, unsigned int InformationBufferLength, int a6, __int64 a7, unsigned int *BufferLength)
{
  NDIS_STATUS result; // eax
  NDIS_HANDLE NdisFilterHandle; // rcx
  unsigned int BytesWritten; // ecx
  NDIS_OID_REQUEST OidRequest; // [rsp+20h] [rbp-138h] BYREF
  struct _NDIS_EVENT Event; // [rsp+110h] [rbp-48h] BYREF
  NDIS_STATUS NtStatus; // [rsp+128h] [rbp-30h]

  NtStatus = STATUS_SUCCESS;
  if ( DeviceExtension->State == FilterRestarting )
    return STATUS_SUCCESS;
  memset(&OidRequest, 0, 0xF0u);
  NdisInitializeEvent(&Event);
  OidRequest.Header.Size = 0xF0;
  OidRequest.Header.Type = NDIS_OBJECT_TYPE_REQUEST_EX;
  OidRequest.Header.Revision = NDIS_FILTER_CHARACTERISTICS_REVISION_1;
  OidRequest.RequestType = RequestType_1;
  if ( !RequestType_1 || RequestType_1 == 1 )
    goto LABEL_7;
  if ( RequestType_1 == 12 )
  {
    *(_QWORD *)&OidRequest.DATA.METHOD_INFORMATION.OutputBufferLength = 0i64;
LABEL_7:
    OidRequest.DATA.QUERY_INFORMATION.Oid = Oid;
    OidRequest.DATA.QUERY_INFORMATION.InformationBuffer = Information;
    OidRequest.DATA.QUERY_INFORMATION.InformationBufferLength = InformationBufferLength;
  }
  NdisFilterHandle = DeviceExtension->NdisFilterHandle;
  OidRequest.RequestId = (PVOID)0x52464D4E;
  result = NdisFOidRequest(NdisFilterHandle, &OidRequest);
  if ( result == NDIS_STATUS_PENDING )
  {
    NdisWaitEvent(&Event, 0);
    result = NtStatus;
  }
  if ( !result )
  {
    BytesWritten = OidRequest.DATA.QUERY_INFORMATION.BytesWritten;
    if ( RequestType_1 == 1 )
      *BufferLength = OidRequest.DATA.QUERY_INFORMATION.BytesWritten;
    if ( !RequestType_1 )
      *BufferLength = BytesWritten;
    if ( *BufferLength > InformationBufferLength )
      *BufferLength = InformationBufferLength;
  }
  return result;
}

//----- (0000000000011534) ----------------------------------------------------
NDIS_STATUS __fastcall NmRegisterFilter(PDRIVER_OBJECT DriverObject)
{
  PDRIVER_OBJECT FilterDriverObject; // rdx
  NDIS_STRING FriendlyName; // xmm0
  NDIS_STRING UniqueName; // xmm1
  NDIS_STRING ServiceName; // xmm0
  _NDIS_FILTER_DRIVER_CHARACTERISTICS FilterDriverCharacteristics; // [rsp+20h] [rbp-108h] BYREF
  UNICODE_STRING name; // [rsp+100h] [rbp-28h] BYREF
  UNICODE_STRING DestinationString; // [rsp+110h] [rbp-18h] BYREF

  RtlInitUnicodeString(&name, L"nm3");
  RtlInitUnicodeString(&DestinationString, L"Netmon Lightweight Filter Driver");
  RtlInitUnicodeString((PUNICODE_STRING)&FilterDriverCharacteristics.DirectOidRequestCompleteHandler, L"{6E022F38-AB31-44c5-8206-2EB023EFF145}");
  memset(&FilterDriverCharacteristics, 0, 0xC8u);
  FilterDriverObject = g_FilterDriverObject;
  FriendlyName = (NDIS_STRING)_mm_loadu_si128((const __m128i *)&DestinationString);
  UniqueName = (NDIS_STRING)_mm_loadu_si128((const __m128i *)&FilterDriverCharacteristics.DirectOidRequestCompleteHandler);
  FilterDriverCharacteristics.MinorNdisVersion = 0;
  FilterDriverCharacteristics.MinorDriverVersion = 0;
  FilterDriverCharacteristics.FriendlyName = FriendlyName;
  ServiceName = (NDIS_STRING)_mm_loadu_si128((const __m128i *)&name);
  FilterDriverCharacteristics.UniqueName = UniqueName;
  FilterDriverCharacteristics.AttachHandler = (FILTER_ATTACH_HANDLER)NetmonFilterAttach;
  FilterDriverCharacteristics.Flags = 0;
  FilterDriverCharacteristics.DetachHandler = (FILTER_DETACH_HANDLER)NetmonFilterDetach;
  FilterDriverCharacteristics.ReturnNetBufferListsHandler = 0i64;
  FilterDriverCharacteristics.ServiceName = ServiceName;
  FilterDriverCharacteristics.RestartHandler = (FILTER_RESTART_HANDLER)NetmonFilterRestart;
  FilterDriverCharacteristics.CancelOidRequestHandler = 0i64;
  FilterDriverCharacteristics.PauseHandler = (FILTER_PAUSE_HANDLER)NetmonFilterPause;
  FilterDriverCharacteristics.SendNetBufferListsCompleteHandler = 0i64;
  FilterDriverCharacteristics.OidRequestHandler = (FILTER_OID_REQUEST_HANDLER)NetmonOidRequest;
  FilterDriverCharacteristics.CancelSendNetBufferListsHandler = 0i64;
  FilterDriverCharacteristics.SetFilterModuleOptionsHandler = (FILTER_SET_FILTER_MODULE_OPTIONS_HANDLER)NetmonFilterSetModuleOptions;
  FilterDriverCharacteristics.SetOptionsHandler = (SET_OPTIONS_HANDLER)NetmonSetOptions;
  FilterDriverCharacteristics.ReceiveNetBufferListsHandler = (FILTER_RECEIVE_NET_BUFFER_LISTS_HANDLER)NetmonReceiveNetBufferLists;
  FilterDriverCharacteristics.DevicePnPEventNotifyHandler = (FILTER_DEVICE_PNP_EVENT_NOTIFY_HANDLER)NetmonDevicePnPEventNotify;
  FilterDriverCharacteristics.Header.Type = NDIS_OBJECT_TYPE_FILTER_DRIVER_CHARACTERISTICS;
  FilterDriverCharacteristics.NetPnPEventHandler = (FILTER_NET_PNP_EVENT_HANDLER)NetmonNetPnPEvent;
  FilterDriverCharacteristics.Header.Size = 0xC8;
  FilterDriverCharacteristics.StatusHandler = (FILTER_STATUS_HANDLER)NetmonFilterStatus;
  FilterDriverCharacteristics.Header.Revision = NDIS_FILTER_CHARACTERISTICS_REVISION_1;
  FilterDriverCharacteristics.OidRequestCompleteHandler = (FILTER_OID_REQUEST_COMPLETE_HANDLER)NetmonOidRequestComplete;
  FilterDriverCharacteristics.MajorNdisVersion = NDIS_FILTER_MAJOR_VERSION;
  FilterDriverCharacteristics.SendNetBufferListsHandler = (FILTER_SEND_NET_BUFFER_LISTS_HANDLER)NetmonSendNetBufferLists;
  FilterDriverCharacteristics.MajorDriverVersion = 1;
  DriverObject->DriverUnload = (PDRIVER_UNLOAD)NetmonUnload;
  return NdisFRegisterFilterDriver(DriverObject, FilterDriverObject, &FilterDriverCharacteristics, &g_FilterDriverHandle);
}

//----- (0000000000011700) ----------------------------------------------------
NDIS_STATUS __fastcall nmOid_Query(int a1, FilterDeviceExtension *a2, __int64 *a3, unsigned int a4)
{
  __int64 v5; // [rsp+30h] [rbp-28h]
  unsigned int *v6; // [rsp+40h] [rbp-18h] BYREF

  LODWORD(v5) = 0;
  return nmFilterDoInternalRequest(a1, a2, 0, a3, a4, 0, v5, (unsigned int *)&v6);
}
// 11723: variable 'v5' is possibly undefined

//----- (0000000000011734) ----------------------------------------------------
NDIS_STATUS __fastcall NmGetGlobalStat(FilterDeviceExtension *FilterDeviceExtension, int n, __int64 *a3, unsigned int a4)
{
  __int64 v5; // [rsp+30h] [rbp-18h]
  __int64 *v6; // [rsp+60h] [rbp+18h] BYREF

  v6 = a3;
  LODWORD(v5) = 0;
  return nmFilterDoInternalRequest(n, FilterDeviceExtension, 0, a3, a4, 0, v5, (unsigned int *)&v6);
}
// 11767: variable 'v5' is possibly undefined

//----- (0000000000011778) ----------------------------------------------------
void __fastcall NmDerefCaptureBuffer(CaptureBuffer *CaptureBuffer)
{
  FileContext *FsContext; // rbp
  _IRP *irp; // rbx
  _QWORD *v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rdi
  FileContext *FsContext_1; // rbx

  FsContext = CaptureBuffer->FsContext;
  if ( _InterlockedExchangeAdd(&CaptureBuffer->volatile_signed___int3258, 0xFFFFFFFF) == 1 )
  {
    irp = CaptureBuffer->irp;
    IoAcquireCancelSpinLock(&irp->CancelIrql);
    _InterlockedExchange64((volatile __int64 *)&irp->CancelRoutine, 0i64);
    IoReleaseCancelSpinLock(irp->CancelIrql);
    FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    v4 = (_QWORD *)CaptureBuffer->qword50;
    v5 = CaptureBuffer->qword48;
    *v4 = v5;
    *(_QWORD *)(v5 + 8) = v4;
    v6 = (unsigned int)++CaptureBuffer->FsContext->gap68;
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    FsContext_1 = CaptureBuffer->FsContext;
    memmove(&CaptureBuffer->charB0, &FsContext_1->field_F8, 0x30u);
    memmove(&CaptureBuffer->char80, &FsContext_1->field_C8, 0x30u);
    CaptureBuffer->qwordB8 = v6;
    NmDestroyCaptureBuffer(CaptureBuffer);
    NmDerefUserProc(FsContext);
  }
}

//----- (0000000000011860) ----------------------------------------------------
void __fastcall NmDestroyCaptureBuffer(CaptureBuffer *CaptureBuffer)
{
  _IRP *irp; // rsi
  PMDL mdl; // rcx
  PVOID MappedSystemVa; // rbp
  int v5; // eax
  int *v6; // rdx
  __int16 Src[4]; // [rsp+30h] [rbp-B8h] BYREF
  __int64 v8; // [rsp+38h] [rbp-B0h]
  int v9; // [rsp+40h] [rbp-A8h]
  _DWORD v10[3]; // [rsp+44h] [rbp-A4h]
  char Dst[48]; // [rsp+50h] [rbp-98h] BYREF
  char v12[48]; // [rsp+80h] [rbp-68h] BYREF
  char v13[40]; // [rsp+B0h] [rbp-38h] BYREF
  int v14; // [rsp+D8h] [rbp-10h]

  irp = CaptureBuffer->irp;
  if ( irp->IoStatus.Status == (unsigned int)STATUS_CANCELLED
    || irp->IoStatus.Status == (unsigned int)STATUS_INVALID_HANDLE
    || irp->IoStatus.Status == NDIS_STATUS_RESOURCES )
  {
    irp->IoStatus.Information = 0i64;
  }
  else
  {
    mdl = CaptureBuffer->mdl;
    if ( (mdl->MdlFlags & 5) != 0 )
      MappedSystemVa = mdl->MappedSystemVa;
    else
      MappedSystemVa = MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
    *(_QWORD *)&v10[1] = 0i64;
    Src[0] = 1;
    Src[1] = 176;
    v9 = CaptureBuffer->field_78;
    v5 = CaptureBuffer->field_7C;
    v8 = MEMORY[0xFFFFF78000000014] / 10i64;
    v10[0] = v5;
    memmove(Dst, &CaptureBuffer->char80, 0x30u);
    memmove(v12, &CaptureBuffer->charB0, 0x30u);
    v6 = &CaptureBuffer->FsContext->field_128;
    v14 = 192;
    memmove(v13, v6, 0x28u);
    CaptureBuffer->irp->IoStatus.Status = 0;
    CaptureBuffer->irp->IoStatus.Information = (unsigned int)CaptureBuffer->field_5C;
    if ( MappedSystemVa )
      memmove(MappedSystemVa, Src, 0xB0u);
    CaptureBuffer->irp->IoStatus.Status = 0;
    CaptureBuffer->irp->IoStatus.Information = (unsigned int)CaptureBuffer->field_5C;
  }
  ExFreePoolWithTag(CaptureBuffer, 0);
  IofCompleteRequest(irp, IO_NETWORK_INCREMENT);
}

//----- (0000000000011A08) ----------------------------------------------------
__int64 __fastcall NmCaptureFilterMatch(__int64 a1, __int64 a2)
{
  unsigned int v2; // er11
  int v3; // eax
  unsigned int v4; // er9
  __int64 v5; // rdi
  int v6; // er8
  _BOOL8 v7; // rbp
  __int64 v8; // r15
  __int64 v9; // r14
  unsigned int v10; // esi
  PMDL mdl; // rbx
  PVOID MappedSystemVa_1; // rax
  __int64 v13; // rdx
  PVOID MappedSystemVa; // r13
  ULONG ByteCount; // edi
  unsigned int v16; // er12
  ULONG v17; // esi
  __int64 v18; // rbp
  __int64 v19; // r10
  _WORD *v20; // rbx
  int v21; // er11
  __int64 result; // rax
  bool v23; // zf
  unsigned __int8 v24; // dl
  unsigned __int8 v25; // r8
  unsigned __int8 v26; // r9
  __int64 v27; // r12
  __int64 v28; // rbp
  unsigned __int16 v29; // di
  __int16 v30; // si
  int v31; // eax
  int v32; // er11
  unsigned __int8 v33; // r9
  unsigned __int16 v34; // di
  unsigned __int8 v35; // r8
  unsigned __int8 v36; // r10
  char v37; // r9
  int v38; // [rsp+30h] [rbp-68h]
  int i; // [rsp+34h] [rbp-64h]
  _BOOL8 v40; // [rsp+38h] [rbp-60h]
  __int64 v41; // [rsp+40h] [rbp-58h]
  __int64 v43; // [rsp+A8h] [rbp+10h]
  unsigned int v44; // [rsp+B0h] [rbp+18h]
  int v45; // [rsp+B8h] [rbp+20h]

  v43 = a2;
  v2 = *(_DWORD *)(a2 + 24);
  v3 = _bittest((const signed __int32 *)(a1 + 24), 0x10u);
  v4 = 16;
  v5 = a2;
  v6 = 16;
  v44 = v2;
  if ( !*(_QWORD *)(a2 + 8) || !v2 )
    return 0xFFFFFFFFi64;
  v7 = v3 == 0;
  v8 = a1 + 36;
  v38 = 0;
  v40 = v7;
  v41 = v3;
  if ( *(_DWORD *)(a1 + 32) )
  {
    while ( 1 )
    {
      v45 = 0;
      v9 = *(_QWORD *)v8 + 12i64;
      if ( *(_DWORD *)(*(_QWORD *)v8 + 8i64) )
        break;
LABEL_81:
      result = 1i64;
      v4 = v6;
      if ( v6 == 1 )
      {
LABEL_77:
        if ( !v41 )
          return result;
      }
      else
      {
LABEL_82:
        if ( (*(_DWORD *)(*(_QWORD *)v8 + 4i64) & 1) != 0 )
          return 2i64;
        if ( v41 == 1 )
          return 0i64;
      }
      v8 += 8i64;
      if ( (unsigned int)++v38 >= *(_DWORD *)(a1 + 32) )
        return v4;
      v5 = v43;
      v2 = v44;
    }
    v10 = 8 * v2;
    for ( i = 8 * v2; ; v10 = i )
    {
      mdl = *(PMDL *)(v5 + 8);
      if ( (mdl->MdlFlags & 5) != 0 )
      {
        MappedSystemVa_1 = mdl->MappedSystemVa;
      }
      else
      {
        MappedSystemVa_1 = MmMapLockedPagesSpecifyCache(*(PMDL *)(v5 + 8), 0, MmCached, 0i64, 0, NormalPagePriority);
        v2 = v44;
      }
      v13 = *(unsigned int *)(v5 + 16);
      MappedSystemVa = (char *)MappedSystemVa_1 + v13;
      if ( *(_DWORD *)(*(_QWORD *)v9 + 4i64) + *(_DWORD *)(*(_QWORD *)v9 + 8i64) <= v10 )
        break;
      v6 = -1;
LABEL_26:
      if ( (*(_WORD *)(*(_QWORD *)v9 + 2i64) & 1) == 1 )
        return 2i64;
      if ( v7 )
      {
        v4 = 0;
        goto LABEL_82;
      }
LABEL_28:
      v9 += 8i64;
      if ( (unsigned int)++v45 >= *(_DWORD *)(*(_QWORD *)v8 + 8i64) )
        goto LABEL_81;
      v5 = v43;
      v2 = v44;
    }
    ByteCount = v2;
    if ( mdl->ByteCount - (int)v13 < v2 )
      ByteCount = mdl->ByteCount - v13;
    v16 = *(_DWORD *)(*(_QWORD *)v9 + 4i64);
    v17 = v2 - ByteCount;
    v18 = v16 >> 3;
    while ( (unsigned int)v18 >= ByteCount )
    {
      mdl = mdl->Next;
      if ( !mdl )
      {
        v6 = -1;
        goto LABEL_25;
      }
      if ( (mdl->MdlFlags & 5) != 0 )
        MappedSystemVa = mdl->MappedSystemVa;
      else
        MappedSystemVa = MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
      v18 = (unsigned int)v18 - ByteCount;
      v16 += -8 * ByteCount;
      ByteCount = v17;
      if ( mdl->ByteCount < v17 )
        ByteCount = mdl->ByteCount;
      v17 -= ByteCount;
    }
    v19 = *(_QWORD *)v9;
    if ( v16 + *(_DWORD *)(*(_QWORD *)v9 + 8i64) > 8 * ByteCount )
    {
      v6 = 4;
LABEL_25:
      v7 = v40;
      goto LABEL_26;
    }
    if ( *(__int16 *)(v19 + 2) < 0 )
    {
      v20 = *(_WORD **)v9;
      v21 = memcmp((char *)MappedSystemVa + (unsigned int)v18, *(const void **)(v19 + 16), *(unsigned __int16 *)(v19 + 12));
      result = 1i64;
      v6 = 0;
      if ( *v20 != 1 )
      {
        switch ( *v20 )
        {
          case 2:
            LOBYTE(v6) = v21 != 0;
            break;
          case 3:
            LOBYTE(v6) = v21 > 0;
            break;
          case 4:
            LOBYTE(v6) = v21 < 0;
            break;
        }
        goto LABEL_74;
      }
      v23 = v21 == 0;
      goto LABEL_73;
    }
    v24 = *(_BYTE *)(v19 + 14);
    v25 = *((_BYTE *)MappedSystemVa + v18);
    v26 = **(_BYTE **)(v19 + 16);
    v27 = (unsigned int)v18;
    result = 1i64;
    v28 = *(_QWORD *)v9;
    if ( v24 )
    {
      switch ( *(_WORD *)v19 )
      {
        case 1:
          v6 = (v25 & v24) == (v26 & *(_BYTE *)(v19 + 14));
          break;
        case 2:
          v6 = (v25 & v24) != (v26 & *(_BYTE *)(v19 + 14));
          break;
        case 3:
          v6 = (unsigned __int8)(v25 & v24) > (unsigned __int8)(v26 & *(_BYTE *)(v19 + 14));
          break;
        case 4:
          v6 = (unsigned __int8)(v25 & v24) < (unsigned __int8)(v26 & *(_BYTE *)(v19 + 14));
          break;
        default:
          v6 = 0;
          goto LABEL_51;
      }
      result = 1i64;
    }
    else
    {
      v6 = 1;
    }
LABEL_51:
    if ( v6 != 1 )
      goto LABEL_25;
    v29 = *(_WORD *)(v19 + 12);
    v30 = *(_BYTE *)(v19 + 14) != 0;
    if ( v29 )
    {
      v31 = memcmp((char *)MappedSystemVa + v27 + (*(_BYTE *)(v19 + 14) != 0), (const void *)((*(_BYTE *)(v19 + 14) != 0) + *(_QWORD *)(v19 + 16)), v29);
      v6 = 0;
      v32 = v31;
      result = 1i64;
      switch ( *(_WORD *)v28 )
      {
        case 1:
          LOBYTE(v6) = v32 == 0;
          break;
        case 2:
          LOBYTE(v6) = v32 != 0;
          break;
        case 3:
          LOBYTE(v6) = v32 > 0;
          break;
        case 4:
          LOBYTE(v6) = v32 < 0;
          break;
      }
      if ( v6 != 1 )
        goto LABEL_25;
    }
    v33 = *(_BYTE *)(v28 + 15);
    if ( !v33 )
      goto LABEL_75;
    v34 = v30 + v29;
    v35 = *((_BYTE *)MappedSystemVa + v34 + v27);
    v36 = *(_BYTE *)(v34 + *(_QWORD *)(v28 + 16));
    result = 1i64;
    if ( *(_WORD *)v28 != 1 )
    {
      switch ( *(_WORD *)v28 )
      {
        case 2:
          v6 = (v35 & v33) != (v36 & *(_BYTE *)(v28 + 15));
          break;
        case 3:
          v6 = (unsigned __int8)(v35 & v33) > (unsigned __int8)(v36 & *(_BYTE *)(v28 + 15));
          break;
        case 4:
          v6 = (unsigned __int8)(v35 & v33) < (unsigned __int8)(v36 & *(_BYTE *)(v28 + 15));
          break;
        default:
          v6 = 0;
          goto LABEL_74;
      }
      result = 1i64;
LABEL_74:
      if ( v6 != 1 )
        goto LABEL_25;
LABEL_75:
      v7 = v40;
      if ( !v40 )
      {
        v4 = 1;
        goto LABEL_77;
      }
      goto LABEL_28;
    }
    v37 = v35 & v33;
    v6 = 0;
    v23 = v37 == (char)(v36 & *(_BYTE *)(v28 + 15));
    result = 1i64;
LABEL_73:
    LOBYTE(v6) = v23;
    goto LABEL_74;
  }
  return v4;
}

//----- (0000000000011EDC) ----------------------------------------------------
NTSTATUS __fastcall NmGetFilterSize(_IRP *a1, _DWORD *a2, _DWORD *a3, _IRP *a4)
{
  int v6; // edi
  unsigned int v7; // er14
  unsigned int v8; // er9
  int v9; // esi
  NTSTATUS NtStatus; // er8
  char *v11; // r10
  unsigned int v12; // er13
  unsigned int v13; // ebp
  unsigned int v14; // edx

  if ( !a2 )
    return STATUS_INVALID_PARAMETER;
  if ( !a3 )
    return STATUS_INVALID_PARAMETER;
  v6 = (int)a4->ThreadListEntry.Flink;
  v7 = HIDWORD(a4->AssociatedIrp.SystemBuffer);
  v8 = 36;
  *a2 = 8 * v6 + 44;
  if ( v7 <= 0x24 )
    return STATUS_INVALID_PARAMETER;
  *a3 = 0;
  v9 = 0;
  NtStatus = 0;
  v11 = (char *)&a1->ThreadListEntry.Flink + 4;
  if ( v6 )
  {
    while ( !NtStatus )
    {
      v8 += 12;
      *a2 += 8 * *((_DWORD *)v11 + 2) + 20;
      if ( v8 >= v7 )
        return NDIS_STATUS_INVALID_PARAMETER;
      v12 = *((_DWORD *)v11 + 2);
      v13 = 0;
      *a3 += v12;
      v11 = (char *)a1 + v8;
      if ( v12 )
      {
        while ( 1 )
        {
          v14 = ((*((_DWORD *)v11 + 1) & 7u) + *((_DWORD *)v11 + 2) + 7) >> 3;
          v8 += v14 + 16;
          *a2 += v14 + 24;
          if ( v8 > v7 )
            break;
          ++v13;
          v11 = (char *)a1 + v8;
          if ( v13 >= v12 )
            goto LABEL_12;
        }
        NtStatus = NDIS_STATUS_INVALID_PARAMETER;
      }
LABEL_12:
      if ( ++v9 >= (unsigned int)v6 )
        return NtStatus;
    }
  }
  return NtStatus;
}

//----- (0000000000011FE4) ----------------------------------------------------
NTSTATUS __fastcall NmUnserializeCaptureFilter(FileContext *FsContext, _IRP *MasterIrp, unsigned int a3, _IRP **Irp_1)
{
  unsigned int v4; // edi
  NTSTATUS NtStatus; // esi
  NTSTATUS result; // eax
  KIRQL NewIrql; // al
  unsigned int v10; // ecx
  _DWORD *temp; // rax
  _DWORD *v12; // rbp
  unsigned int v13; // er15
  int v14; // eax
  const __m128i *v15; // r9
  unsigned int v16; // er13
  _DWORD *v17; // rcx
  __int64 *v18; // rdx
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 *v21; // r8
  __m128i v22; // xmm0
  __int64 v23; // r8
  int v24; // edx
  int v25; // eax
  unsigned int v26; // edi
  __int64 v27; // rbx
  bool v28; // cf
  int v29; // ebx
  KIRQL irql; // al
  int v31; // [rsp+20h] [rbp-68h] BYREF
  int v32; // [rsp+24h] [rbp-64h]
  int v33; // [rsp+28h] [rbp-60h]
  const __m128i *v34; // [rsp+30h] [rbp-58h]
  __int64 *v35; // [rsp+38h] [rbp-50h]
  __int64 v36; // [rsp+40h] [rbp-48h]
  SIZE_T NumberOfBytes; // [rsp+98h] [rbp+10h] BYREF
  unsigned int v38; // [rsp+A0h] [rbp+18h]
  _IRP **irp; // [rsp+A8h] [rbp+20h]

  irp = Irp_1;
  v38 = a3;
  v31 = 0;
  v4 = a3;
  NtStatus = NDIS_STATUS_INVALID_PARAMETER;
  if ( MasterIrp && Irp_1 && HIDWORD(MasterIrp->AssociatedIrp.SystemBuffer) == a3 )
  {
    result = NmGetFilterSize(MasterIrp, &NumberOfBytes, &v31, MasterIrp);
    if ( result )
      return result;
    NewIrql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    v10 = FsContext->gap80 + v31;
    FsContext->irql = NewIrql;
    if ( g_OlpFilterConditionMaxCount < v10 )
    {
      KeReleaseSpinLock(&FsContext->SpinLock, NewIrql);
      return STATUS_QUOTA_EXCEEDED;
    }
    FsContext->gap80 = v10;
    KeReleaseSpinLock(&FsContext->SpinLock, NewIrql);
    temp = ExAllocatePoolWithTag(NonPagedPool, (unsigned int)NumberOfBytes, 'u3MN');
    v12 = temp;
    if ( !temp )
      return STATUS_NO_MEMORY;
    v13 = 36;
    memmove(temp, MasterIrp, 0x24u);
    v14 = v12[8];
    v15 = (const __m128i *)((char *)&MasterIrp->ThreadListEntry.Flink + 4);
    v16 = 8 * v14 + 36;
    v17 = (_DWORD *)((char *)v12 + v16);
    if ( v4 <= 0x24 || v16 >= (unsigned int)NumberOfBytes )
      NtStatus = STATUS_DATA_OVERRUN;
    else
      NtStatus = 0;
    v33 = 0;
    v18 = (__int64 *)(v12 + 9);
    v35 = (__int64 *)(v12 + 9);
    if ( v14 )
    {
      while ( !NtStatus )
      {
        v19 = v15->i64[0];
        v13 += 12;
        v15 = (const __m128i *)((char *)v15 + 12);
        *(_QWORD *)v17 = v19;
        v17[2] = v15[-1].i32[3];
        *v18 = (__int64)v17;
        v16 += 8 * v17[2] + 12;
        v17 = (_DWORD *)((char *)v12 + v16);
        if ( v13 >= v4 || v16 >= (unsigned int)NumberOfBytes )
        {
          NtStatus = STATUS_DATA_OVERRUN;
          goto LABEL_29;
        }
        v20 = *v18;
        v32 = 0;
        v21 = (__int64 *)(v20 + 12);
        v36 = v20 + 12;
        if ( *(_DWORD *)(v20 + 8) )
        {
          while ( 1 )
          {
            v22 = _mm_loadu_si128(v15);
            v16 += 24;
            ++v15;
            v13 += 16;
            v34 = v15;
            *(__m128i *)v17 = v22;
            *v21 = (__int64)v17;
            v17 = (_DWORD *)((char *)v12 + v16);
            if ( v13 >= v4 || v16 >= (unsigned int)NumberOfBytes )
              break;
            v23 = *v21;
            v24 = *(_DWORD *)(v23 + 4);
            v25 = *(_DWORD *)(v23 + 8);
            *(_QWORD *)(v23 + 16) = v17;
            v26 = ((v24 & 7u) + v25 + 7) >> 3;
            v27 = v26;
            memmove(v17, v15, v26);
            v16 += v26;
            v13 += v26;
            v4 = v38;
            v15 = (const __m128i *)((char *)v34 + v27);
            v34 = (const __m128i *)((char *)v34 + v27);
            v17 = (_DWORD *)((char *)v12 + v16);
            if ( v13 > v38 || v16 > (unsigned int)NumberOfBytes )
            {
              v18 = v35;
              break;
            }
            v18 = v35;
            v21 = (__int64 *)(v36 + 8);
            v28 = (unsigned int)++v32 < *(_DWORD *)(*v35 + 8);
            v15 = v34;
            v36 += 8i64;
            if ( !v28 )
              goto LABEL_26;
          }
          NtStatus = STATUS_DATA_OVERRUN;
        }
LABEL_26:
        v35 = ++v18;
        if ( (unsigned int)++v33 >= v12[8] )
          goto LABEL_29;
      }
    }
    else
    {
LABEL_29:
      if ( !NtStatus )
        goto LABEL_31;
    }
    ExFreePoolWithTag(v12, 0);
    v12 = 0i64;
LABEL_31:
    *irp = (_IRP *)v12;
    if ( NtStatus )
    {
      v29 = v31;
      if ( v31 )
      {
        irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
        FsContext->gap80 -= v29;
        FsContext->irql = irql;
        KeReleaseSpinLock(&FsContext->SpinLock, irql);
      }
    }
  }
  return NtStatus;
}
// 19128: using guessed type int g_OlpFilterConditionMaxCount;

//----- (00000000000122D8) ----------------------------------------------------
NTSTATUS __fastcall NmAddCaptureFilter(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  _IO_STACK_LOCATION *CurrentStackLocation; // rax
  PIRP MasterIrp; // rbp
  MACRO_NDIS_MEMORY NtStatus; // ebx
  unsigned int InputBufferLength; // er14
  PFILE_OBJECT FileObject; // rax
  FileContext *FsContext; // rdi
  NTSTATUS Status; // eax
  KIRQL irql; // al
  bool v11; // zf
  _LIST_ENTRY *list; // rsi
  _LIST_ENTRY *list2; // rcx
  _LIST_ENTRY *list3; // rcx
  _LIST_ENTRY *list4; // rax
  PIRP Irp_1; // [rsp+58h] [rbp+10h] BYREF

  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  MasterIrp = Irp->AssociatedIrp.MasterIrp;
  NtStatus = NDIS_STATUS_SUCCESS;
  Irp->IoStatus.Information = 0i64;
  InputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.InputBufferLength;
  Irp->IoStatus.Information = 0i64;
  FileObject = CurrentStackLocation->FileObject;
  Irp_1 = MasterIrp;
  FsContext = (FileContext *)FileObject->FsContext;
  Status = NmVerifyUserProcObject(FsContext);
  if ( Status || InputBufferLength != HIDWORD(MasterIrp->AssociatedIrp.SystemBuffer) )
  {
    NtStatus = Status;
    if ( !Status )
      NtStatus = NDIS_STATUS_INVALID_PARAMETER;
  }
  else
  {
    irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    v11 = (FsContext->field_40 & 0x40) == 0;
    FsContext->irql = irql;
    if ( v11 && SLOBYTE(FsContext->field_40) >= 0 )
    {
      list = &FsContext->list2;
      list2 = FsContext->list2.Flink;
      if ( list2 == &FsContext->list2 )
        goto LABEL_10;
      do
      {
        v11 = *(&MasterIrp->Flags + 1) == LODWORD(list2[1].Flink);
        list2 = list2->Flink;
        if ( v11 )
          NtStatus = (unsigned int)STATUS_OBJECTID_EXISTS;
      }
      while ( list2 != list );
      if ( NtStatus == NDIS_STATUS_SUCCESS )
      {
LABEL_10:
        KeReleaseSpinLock(&FsContext->SpinLock, irql);
        NtStatus = NmUnserializeCaptureFilter(FsContext, Irp->AssociatedIrp.MasterIrp, InputBufferLength, &Irp_1);
        FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
        if ( NtStatus )
        {
          NtStatus = NDIS_STATUS_RESOURCES;
        }
        else
        {
          list3 = (_LIST_ENTRY *)(&Irp_1->Size + 1);
          *(PMDL *)((char *)&Irp_1->MdlAddress + 4) = (PMDL)(&Irp_1->Size + 1);
          list3->Flink = list3;
          list4 = FsContext->list2.Blink;
          list3->Blink = list4;
          list3->Flink = list;
          list4->Flink = list3;
          FsContext->list2.Blink = list3;
        }
      }
      NmDerefUserProc(FsContext);
    }
    else
    {
      NtStatus = (unsigned int)STATUS_DEVICE_BUSY;
    }
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
  }
  return NtStatus;
}

//----- (0000000000012420) ----------------------------------------------------
NTSTATUS __fastcall NmDeleteCaptureFilter(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  _IO_STACK_LOCATION *CurrentStackLocation; // rcx
  PIRP MasterIrp; // rbp
  ULONG InputBufferLength; // edi
  FileContext *FsContext; // rbx
  NTSTATUS result; // eax
  KIRQL irql; // al
  bool v8; // zf
  NTSTATUS NtStatus; // edi
  LIST_ENTRY *i; // rax
  CaptureFilter *CaptureFilter; // r8
  _QWORD *v12; // rax
  __int64 v13; // rcx
  int v14; // edx
  __int64 v15; // r9
  __int64 *v16; // rcx
  __int64 v17; // rax

  Irp->IoStatus.Information = 0i64;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  LODWORD(MasterIrp) = *(_DWORD *)Irp->AssociatedIrp.MasterIrp;
  InputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.InputBufferLength;
  FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
  result = NmVerifyUserProcObject(FsContext);
  if ( result || InputBufferLength != 4 )
  {
    if ( !result )
      result = STATUS_INVALID_BUFFER_SIZE;
  }
  else
  {
    irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    v8 = (FsContext->field_40 & 0x40) == 0;
    NtStatus = STATUS_DEVICE_BUSY;
    FsContext->irql = irql;
    if ( v8 && SLOBYTE(FsContext->field_40) >= 0 )
    {
      NtStatus = STATUS_NOT_FOUND;
      for ( i = FsContext->list2.Flink; i != &FsContext->list2; i = i->Flink )
      {
        CaptureFilter = (CaptureFilter *)((char *)&i[-1].Blink + 4);
        if ( (_DWORD)MasterIrp == LODWORD(i[1].Flink) )
        {
          v12 = CaptureFilter->pqwordC;
          v13 = CaptureFilter->qword4;
          v14 = 0;
          *v12 = v13;
          *(_QWORD *)(v13 + 8) = v12;
          if ( CaptureFilter->unsigned_int20 )
          {
            v15 = CaptureFilter->unsigned_int20;
            v16 = &CaptureFilter->int6424;
            do
            {
              v17 = *v16++;
              v14 += *(_DWORD *)(v17 + 8);
              --v15;
            }
            while ( v15 );
          }
          FsContext->gap80 -= v14;
          ExFreePoolWithTag(CaptureFilter, 0);
          NtStatus = 0;
          break;
        }
      }
      NmDerefUserProc(FsContext);
    }
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    result = NtStatus;
  }
  return result;
}

//----- (000000000001252C) ----------------------------------------------------
NTSTATUS __fastcall NmFilterRootDeviceIoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  NTSTATUS NtStatus; // edi
  size_t Information; // ebp
  RootDeviceExtension *DeviceReservedExtension; // r12
  _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  NTSTATUS Status; // eax
  size_t infor; // [rsp+48h] [rbp+10h] BYREF

  NtStatus = 0;
  Information = 0;
  infor = 0;
  DeviceReservedExtension = GetFilterRootDevice(DeviceObject);
  TestFilterRootDeviceSignature(DeviceObject);
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Irp->IoStatus.Information = 0i64;
  if ( CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode == 0x21008A )
  {
    if ( DeviceReservedExtension->init == TRUE )
    {
      if ( Irp->MdlAddress )
      {
        Status = NmEnumNetworks(Irp, CurrentStackLocation, &infor);
        Information = infor;
        NtStatus = Status;
      }
      else
      {
        NtStatus = NDIS_STATUS_BUFFER_OVERFLOW;
      }
    }
    else
    {
      Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
      NtStatus = STATUS_INVALID_DEVICE_STATE;
    }
  }
  Irp->IoStatus.Information = Information;
  Irp->IoStatus.Status = NtStatus;
  IofCompleteRequest(Irp, IO_NO_INCREMENT);
  return NtStatus;
}

//----- (00000000000125D4) ----------------------------------------------------
NTSTATUS __fastcall NmFilterRootDeviceIoClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  _IO_STACK_LOCATION *CurrentStackLocation; // rax

  GetFilterRootDevice(DeviceObject);
  TestFilterRootDeviceSignature(DeviceObject);
  Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Irp->IoStatus.Information = 0i64;
  Irp->IoStatus.Status = NDIS_STATUS_PENDING;
  CurrentStackLocation->Control &= 0xFEu;
  Irp->IoStatus.Status = STATUS_INVALID_HANDLE;
  IofCompleteRequest(Irp, IO_NETWORK_INCREMENT);
  return STATUS_INVALID_HANDLE;
}

//----- (000000000001263C) ----------------------------------------------------
NTSTATUS __fastcall NmFilterRootDeviceIoCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  _IO_STACK_LOCATION *CurrentStackLocation; // rax

  GetFilterRootDevice(DeviceObject);
  TestFilterRootDeviceSignature(DeviceObject);
  Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Irp->IoStatus.Information = 0i64;
  Irp->IoStatus.Status = NDIS_STATUS_PENDING;
  CurrentStackLocation->Control &= 0xFEu;
  Irp->IoStatus.Status = NDIS_STATUS_SUCCESS;
  IofCompleteRequest(Irp, IO_NETWORK_INCREMENT);
  return NDIS_STATUS_SUCCESS;
}

//----- (00000000000126A0) ----------------------------------------------------
RootDeviceExtension *__fastcall GetFilterRootDevice(PDEVICE_OBJECT DeviceObject)
{
  RootDeviceExtension *DeviceReservedExtension; // r11
  RootDeviceExtension *FilterRootDevice; // rax

  DeviceReservedExtension = (RootDeviceExtension *)NdisGetDeviceReservedExtension(DeviceObject);
  FilterRootDevice = NULL;
  if ( &DeviceReservedExtension->FilterDeviceHandle < (_QWORD *)((char *)DeviceObject + DeviceObject->Size)
    && DeviceReservedExtension->ExtensionSize == 72
    && DeviceReservedExtension->tag == 'DFMN' )
  {
    FilterRootDevice = DeviceReservedExtension;
  }
  return FilterRootDevice;
}

//----- (00000000000126E4) ----------------------------------------------------
RootDeviceExtension *__fastcall TestFilterRootDeviceSignature(PDEVICE_OBJECT DeviceObject)
{
  RootDeviceExtension *DeviceReservedExtension; // rax

  DeviceReservedExtension = (RootDeviceExtension *)NdisGetDeviceReservedExtension(DeviceObject);
  if ( &DeviceReservedExtension->FilterDeviceHandle >= (_QWORD *)((char *)DeviceObject + DeviceObject->Size)
    || DeviceReservedExtension->ExtensionSize != 72
    || DeviceReservedExtension->tag != 'DFMN' )
  {
    __debugbreak();
  }
  return DeviceReservedExtension;
}

//----- (0000000000012724) ----------------------------------------------------
NTSTATUS __fastcall NmAddGroupAccessAce(PDEVICE_OBJECT pDeviceObject)
{
  WORD AceCount; // r13
  NTSTATUS NtStatus; // edi
  void *SecurityDescriptor_2; // rbp
  ACL *Dacl_1; // r12
  GroupAce *GroupAce; // rsi
  PACL dacl; // r15
  unsigned __int16 DataLength; // r14
  __int16 v9; // r14
  GroupAce *v10; // rax
  unsigned __int16 Length_1; // cx
  ULONG Length; // eax
  PVOID SecurityDescriptor_1; // rax
  PACL dacl_1; // rbx
  __int64 NumberOfBytes; // rdi
  ACL *acl; // rax
  ACL *Acl; // rsi
  unsigned int i; // edi
  GroupAce *v19; // rax
  GroupAce *v20; // rax
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+40h] [rbp-58h]
  BOOLEAN DaclDefaulted; // [rsp+A0h] [rbp+8h] BYREF
  BOOLEAN DaclPresent; // [rsp+A8h] [rbp+10h] BYREF
  HANDLE Handle; // [rsp+B0h] [rbp+18h] BYREF
  PACL Dacl; // [rsp+B8h] [rbp+20h] BYREF

  AceCount = NULL;
  NtStatus = NULL;
  SecurityDescriptor_2 = NULL;
  Dacl_1 = NULL;
  Handle = NULL;
  if ( pDeviceObject && g_GroupAce )
  {
    NtStatus = ObOpenObjectByPointer(pDeviceObject, 0x200u, 0i64, 0x40000u, NULL, NULL, &Handle);
    if ( !NtStatus )
    {
      SecurityDescriptor = pDeviceObject->SecurityDescriptor;
      NtStatus = RtlGetDaclSecurityDescriptor(SecurityDescriptor, &DaclPresent, &Dacl, &DaclDefaulted);
      if ( !NtStatus )
      {
        GroupAce = g_GroupAce;
        dacl = Dacl;
        if ( g_GroupAce )
        {
          DataLength = g_GroupAce->DataLength;
          if ( DataLength >= 0xCu )
          {
            v9 = DataLength - 12;
            if ( Dacl->AceCount )
            {
              do
              {
                v10 = GetAceFromAcl(dacl, AceCount);
                if ( v10 )
                {
                  Length_1 = v10->DataLength - 12;
                  if ( Length_1 == v9 )
                  {
                    if ( Length_1 == RtlCompareMemory(&v10->DataOffset, &GroupAce->DataOffset, Length_1) )
                      goto LABEL_24;
                    GroupAce = g_GroupAce;
                  }
                }
                ++AceCount;
              }
              while ( AceCount < dacl->AceCount );
            }
          }
        }
        Length = RtlLengthSecurityDescriptor(SecurityDescriptor);
        SecurityDescriptor_1 = ExAllocatePool(NonPagedPool, Length + (unsigned __int16)g_GroupAce->DataLength);
        SecurityDescriptor_2 = SecurityDescriptor_1;
        if ( SecurityDescriptor_1 )
        {
          RtlCreateSecurityDescriptor(SecurityDescriptor_1, 1u);
          dacl_1 = Dacl;
          if ( Dacl )
          {
            NumberOfBytes = (unsigned __int16)(Dacl->AclSize + g_GroupAce->DataLength);
            acl = (ACL *)ExAllocatePool(NonPagedPool, (unsigned __int16)NumberOfBytes);
            Acl = acl;
            if ( acl )
            {
              *acl = *dacl_1;
              acl->AclSize = NumberOfBytes;
              acl->AceCount = NULL;
              for ( i = NULL; i < dacl_1->AceCount; ++i )
              {
                v19 = GetAceFromAcl(dacl_1, i);
                if ( v19->char0 != 1 )
                  break;
                AddAceToAcl(Acl, v19);
              }
              AddAceToAcl(Acl, g_GroupAce);
              for ( ; i < dacl_1->AceCount; ++i )
              {
                v20 = GetAceFromAcl(dacl_1, i);
                AddAceToAcl(Acl, v20);
              }
              Dacl_1 = Acl;
            }
          }
          NtStatus = RtlSetDaclSecurityDescriptor(SecurityDescriptor_2, 1u, Dacl_1, 0);
          if ( !NtStatus )
            NtStatus = ZwSetSecurityObject(Handle, 4u, SecurityDescriptor_2);
        }
      }
    }
LABEL_24:
    if ( Handle )
      ZwClose(Handle);
    if ( SecurityDescriptor_2 )
      ExFreePoolWithTag(SecurityDescriptor_2, 0);
    if ( Dacl_1 )
      ExFreePoolWithTag(Dacl_1, 0);
  }
  return NtStatus;
}

//----- (00000000000129DC) ----------------------------------------------------
GroupAce *__fastcall GetAceFromAcl(PACL Dacl, unsigned int a2)
{
  GroupAce *Ace; // r8
  PACL acl; // r9
  unsigned __int16 i; // r10

  Ace = 0i64;
  if ( Dacl && a2 < Dacl->AceCount )
  {
    acl = Dacl + 1;
    for ( i = 0; i < a2; acl = (PACL)((char *)acl + acl->AclSize) )
    {
      if ( acl >= (PACL)((char *)Dacl + Dacl->AclSize) )
        break;
      ++i;
    }
    if ( i == a2 )
      Ace = (GroupAce *)acl;
  }
  return Ace;
}

//----- (0000000000012A30) ----------------------------------------------------
char __fastcall AddAceToAcl(ACL *acl, GroupAce *GroupAce)
{
  char ret; // bl
  ACL *pacl; // rcx
  WORD i; // si
  __int64 DataLength; // r8

  ret = 1;
  if ( acl && GroupAce )
  {
    pacl = acl + 1;
    for ( i = FALSE; i < acl->AceCount; pacl = (ACL *)((char *)pacl + pacl->AclSize) )
    {
      if ( pacl >= (ACL *)((char *)acl + acl->AclSize) )
        break;
      ++i;
    }
    DataLength = (unsigned __int16)GroupAce->DataLength;
    if ( (char *)pacl + DataLength > (char *)acl + acl->AclSize )
    {
      ret = FALSE;
    }
    else
    {
      memmove(pacl, GroupAce, DataLength);
      acl->AceCount = i + 1;
    }
  }
  return ret;
}

//----- (0000000000012AC4) ----------------------------------------------------
void __fastcall pNmDot11StoreCurrentIfc(Dot11Filter *Dot11, int a2)
{
  unsigned int i; // edi
  __int64 *v5; // rbp
  KIRQL NewIrql; // al

  i = 0;
  if ( Dot11 && Dot11->dwordA4 )
  {
    v5 = &Dot11->qwordB8;
    do
    {
      if ( *(_DWORD *)(*v5 + 20) == a2 )
      {
        NewIrql = KeAcquireSpinLockRaiseToDpc(&Dot11->SpinLock);
        Dot11->Irql = NewIrql;
        Dot11->field_B0 = *v5;
        KeReleaseSpinLock(&Dot11->SpinLock, NewIrql);
      }
      ++i;
      ++v5;
    }
    while ( i < Dot11->dwordA4 );
  }
}

//----- (0000000000012B60) ----------------------------------------------------
void __fastcall pNmDot11StoreOpMode(Dot11Filter *Dot11, int a2)
{
  KIRQL Irql; // al

  if ( Dot11 )
  {
    Irql = KeAcquireSpinLockRaiseToDpc(&Dot11->SpinLock);
    Dot11->gapA8 = a2;
    Dot11->Irql = Irql;
    KeReleaseSpinLock(&Dot11->SpinLock, Irql);
  }
}

//----- (0000000000012BB4) ----------------------------------------------------
__int64 __fastcall pNmDot11QueryMonitorMode(Dot11Filter *Dot11)
{
  MACRO_BOOL b; // edi
  KIRQL NewIrql; // al

  b = FALSE;
  if ( Dot11 )
  {
    NewIrql = KeAcquireSpinLockRaiseToDpc(&Dot11->SpinLock);
    if ( Dot11->gapA8 == 0x80000000 )
      b = TRUE;
    Dot11->Irql = NewIrql;
    KeReleaseSpinLock(&Dot11->SpinLock, NewIrql);
  }
  return (unsigned int)b;
}

//----- (0000000000012C14) ----------------------------------------------------
__int64 __fastcall pNmDot11QueryCurrentIfc(FilterDeviceExtension *DeviceExtension)
{
  Dot11Filter *Dot11; // rcx
  Dot11Filter *Dot11_1; // rax
  __int64 v5; // rdi
  unsigned int status; // eax
  Dot11Filter *Dot11_2; // rax
  __int64 v8; // [rsp+30h] [rbp-18h]
  __int64 a4; // [rsp+50h] [rbp+8h] BYREF
  unsigned int *v10; // [rsp+58h] [rbp+10h] BYREF

  Dot11 = DeviceExtension->Dot11;
  if ( !Dot11 )
    return 0i64;
  DeviceExtension->Dot11->Irql = KeAcquireSpinLockRaiseToDpc(&Dot11->SpinLock);
  Dot11_1 = DeviceExtension->Dot11;
  v5 = Dot11_1->field_B0;
  KeReleaseSpinLock(&Dot11_1->SpinLock, Dot11_1->Irql);
  if ( !v5 )
  {
    LODWORD(v8) = 0;
    status = nmFilterDoInternalRequest(0xE010192, DeviceExtension, 0, &a4, 4u, 0, v8, (unsigned int *)&v10);
    if ( status )
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "pNmDot11QueryCurrentIfc: status %x\n", status);
    else
      pNmDot11StoreCurrentIfc(DeviceExtension->Dot11, a4);
    DeviceExtension->Dot11->Irql = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->Dot11->SpinLock);
    Dot11_2 = DeviceExtension->Dot11;
    v5 = Dot11_2->field_B0;
    KeReleaseSpinLock(&Dot11_2->SpinLock, Dot11_2->Irql);
    if ( !v5 )
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "pNmDot11QueryCurrentIfc: none\n");
  }
  return v5;
}
// 12C9F: variable 'v8' is possibly undefined

//----- (0000000000012D3C) ----------------------------------------------------
void __fastcall NmDeleteDot11Parameters(Dot11Filter *Dot11)
{
  unsigned int i; // edi
  PVOID *v3; // rsi

  i = 0;
  if ( Dot11 )
  {
    if ( Dot11->dwordA4 )
    {
      v3 = (PVOID *)&Dot11->qwordB8;
      do
      {
        NdisFreeMemory(*v3, 0, 0);
        ++i;
        ++v3;
      }
      while ( i < Dot11->dwordA4 );
    }
    NdisFreeMemory(Dot11, 0, 0);
  }
}

//----- (0000000000012DA4) ----------------------------------------------------
NTSTATUS __fastcall NmCreateDot11Filter(NDIS_HANDLE NdisHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameter, Dot11Filter **Dot11Filter)
{
  NTSTATUS NtStatus; // eax
  Dot11Filter *Dot11Filter_3; // rsi
  Dot11Filter **Dot11Filter_2; // r12
  FilterDeviceExtension *MiniportMediaSpecificAttributes; // rbx 这个肯定不是NDIS_HANDLE，而是个结构。
  unsigned int v7; // edi
  UINT Length; // edi
  Dot11Filter *p; // rax
  unsigned int v10; // er14
  int v11; // eax
  __int64 v12; // r13
  _QWORD *v13; // r15
  int v14; // ebp
  MACRO_OID_DOT11_TEMP oid; // edi
  __int64 p_1; // rax
  Dot11Filter **Dot11Filter_1; // [rsp+70h] [rbp+18h]

  Dot11Filter_1 = Dot11Filter;
  NtStatus = 0;
  Dot11Filter_3 = 0i64;
  Dot11Filter_2 = Dot11Filter;
  if ( AttachParameter->MiniportMediaType != NdisMediumNative802_11 )
    goto LABEL_24;
  MiniportMediaSpecificAttributes = (FilterDeviceExtension *)AttachParameter->MiniportMediaSpecificAttributes;
  if ( !MiniportMediaSpecificAttributes
    || MiniportMediaSpecificAttributes->byte0 != 0xA1
    || !MiniportMediaSpecificAttributes->gap1[0]
    || MiniportMediaSpecificAttributes->word2 < 0x28u )
  {
    NtStatus = NDIS_STATUS_INVALID_PARAMETER;
    goto LABEL_26;
  }
  v7 = 8 * HIDWORD(MiniportMediaSpecificAttributes->list.Flink);
  if ( v7 < (unsigned __int64)(v7 + 8) + 184 )
  {
    Length = v7 + 192;
    p = (Dot11Filter *)NdisAllocateMemoryWithTagPriority(NdisHandle, Length, 't3mN', LowPoolPriority);
    Dot11Filter_3 = p;
    if ( !p )
    {
      NtStatus = NDIS_STATUS_RESOURCES;
      goto LABEL_26;
    }
    memset(p, 0, Length);
    v10 = 0;
    Dot11Filter_3->dword94 = MiniportMediaSpecificAttributes->gap4;
    Dot11Filter_3->qword98 = MiniportMediaSpecificAttributes->tag;
    Dot11Filter_3->byteA0 = MiniportMediaSpecificAttributes->list.Flink;
    v11 = HIDWORD(MiniportMediaSpecificAttributes->list.Flink);
    Dot11Filter_3->dwordA4 = v11;
    if ( v11 )
    {
      v12 = 0i64;
      v13 = &Dot11Filter_3->qwordB8;
      do
      {
        v14 = *(_DWORD *)((char *)&MiniportMediaSpecificAttributes->list.Blink->Flink + v12 + 4);
        if ( v14 == 4 )
        {
          oid = OID_DOT11_CURRENT_FREQUENCY;
        }
        else if ( v14 == 6 || v14 == 5 )
        {
          oid = OID_DOT11_CURRENT_CHANNEL;
        }
        else
        {
          oid = -1;
          if ( v14 == 7 )
            oid = OID_DOT11_CURRENT_CHANNEL;
        }
        p_1 = (__int64)NdisAllocateMemoryWithTagPriority(NdisHandle, 0x468u, 't3mN', LowPoolPriority);// 又是个结构？
        if ( p_1 )
        {
          *v13 = p_1;
          *(_DWORD *)(p_1 + 20) = v10;
          *(_DWORD *)(p_1 + 24) = v14;
          *(_DWORD *)(p_1 + 1120) = oid;
          *(_WORD *)(p_1 + 16) = 1128;
          memmove((void *)(p_1 + 28), (char *)MiniportMediaSpecificAttributes->list.Blink + v12, 0x444u);
        }
        ++v10;
        ++v13;
        v12 += 1092i64;
      }
      while ( v10 < Dot11Filter_3->dwordA4 );
      Dot11Filter_2 = Dot11Filter_1;
    }
    NtStatus = 0;
    Dot11Filter_3->SpinLock = 0i64;
LABEL_24:
    *Dot11Filter_2 = Dot11Filter_3;
    return NtStatus;
  }
  NtStatus = NDIS_STATUS_BUFFER_OVERFLOW;
LABEL_26:
  *Dot11Filter_2 = 0i64;
  return NtStatus;
}

//----- (0000000000012F84) ----------------------------------------------------
NTSTATUS __fastcall NmDot11SetPhyId(FilterDeviceExtension *DeviceExtension, unsigned int a2)
{
  Dot11Filter *Dot11; // rbx
  unsigned int status_1; // eax
  unsigned int status; // eax
  NTSTATUS NtStatus; // edi
  __int64 v8; // [rsp+30h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-28h]
  __int64 a4[3]; // [rsp+40h] [rbp-18h] BYREF
  unsigned int *v11; // [rsp+60h] [rbp+8h] BYREF
  __int64 Information; // [rsp+68h] [rbp+10h] BYREF

  LODWORD(Information) = a2;
  *(_OWORD *)a4 = 0ui64;
  if ( !DeviceExtension )
    return NDIS_STATUS_INVALID_PARAMETER;
  Dot11 = DeviceExtension->Dot11;
  if ( !Dot11 )
    return 0xC0235001;
  if ( !(unsigned int)pNmDot11QueryMonitorMode(DeviceExtension->Dot11) )
    return 0xC0235002;
  HIDWORD(a4[1]) = Information;
  LODWORD(v8) = 0;
  a4[0] = 0x100100180i64;
  LODWORD(a4[1]) = 1;
  status_1 = nmFilterDoInternalRequest(OID_DOT11_DESIRED_PHY_LIST, DeviceExtension, 1, a4, 0x10u, 0, v8, (unsigned int *)&v11);
  if ( status_1 )
    DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmSetDot11PhyType: Attempted set DESIRED_PHY_LIST, status %x\n", status_1);
  LODWORD(v9) = 0;
  status = nmFilterDoInternalRequest(OID_DOT11_CURRENT_PHY_ID, DeviceExtension, 1, &Information, 4u, 0, v9, (unsigned int *)&v11);
  NtStatus = status;
  if ( status )
    DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmSetDot11PhyType: Attempted set CURRENT_PHY_ID, status %x\n", status);
  else
    pNmDot11StoreCurrentIfc(Dot11, Information);
  return NtStatus;
}
// 1303E: variable 'v8' is possibly undefined
// 1308B: variable 'v9' is possibly undefined

//----- (00000000000130CC) ----------------------------------------------------
__int64 __fastcall NmDot11SetChannel(FilterDeviceExtension *DeviceExtension, unsigned int channel_1)
{
  Dot11Filter *Dot11; // rcx
  __int64 NtStatus; // rax
  __int64 v5; // rdi
  NDIS_STATUS Status; // eax
  unsigned int v7; // ebx
  __int64 oid; // [rsp+20h] [rbp-28h]
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  unsigned int *v11; // [rsp+50h] [rbp+8h] BYREF
  __int64 channel; // [rsp+58h] [rbp+10h] BYREF

  LODWORD(channel) = channel_1;
  Dot11 = DeviceExtension->Dot11;
  if ( !Dot11 )
    return 0xC0235001i64;
  if ( !(unsigned int)pNmDot11QueryMonitorMode(Dot11) )
    return 0xC0235002i64;
  NtStatus = pNmDot11QueryCurrentIfc(DeviceExtension);
  v5 = NtStatus;
  if ( NtStatus )
  {
    LODWORD(v10) = 0;
    Status = nmFilterDoInternalRequest(*(_DWORD *)(NtStatus + 1120), DeviceExtension, 1, &channel, 4u, 0, v10, (unsigned int *)&v11);
    v7 = Status;
    if ( Status )
    {
      LODWORD(v9) = Status;
      LODWORD(oid) = *(_DWORD *)(v5 + 1120);
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmDot11SetChannel: set channel %x, oid %x, status %x\n", (unsigned int)channel, oid, v9);
    }
    NtStatus = v7;
  }
  return NtStatus;
}
// 13143: variable 'v10' is possibly undefined
// 1316D: variable 'oid' is possibly undefined
// 1316D: variable 'v9' is possibly undefined

//----- (0000000000013188) ----------------------------------------------------
void __fastcall NetmonUnload(struct _DRIVER_OBJECT *DriverObject)
{
  if ( g_GroupAce )
  {
    ExFreePoolWithTag(g_GroupAce, 0);
    g_GroupAce = NULL;
  }
  if ( g_FilterDeviceHandle )
    NdisDeregisterDeviceEx(g_FilterDeviceHandle);
  g_FilterDeviceHandle = NULL;
  NdisFDeregisterFilterDriver(g_FilterDriverHandle);
}

//----- (00000000000131DC) ----------------------------------------------------
NDIS_STATUS __fastcall NmSetPacketFilter(FilterDeviceExtension *ModuleContext, int filter)
{
  __int64 v3; // [rsp+30h] [rbp-18h]
  __int64 a4; // [rsp+58h] [rbp+10h] BYREF
  unsigned int *v5; // [rsp+60h] [rbp+18h] BYREF

  LODWORD(a4) = filter;
  LODWORD(v3) = 0;
  return nmFilterDoInternalRequest(OID_GEN_CURRENT_PACKET_FILTER, ModuleContext, 1, &a4, 4u, 0, v3, (unsigned int *)&v5);
}
// 13213: variable 'v3' is possibly undefined

//----- (0000000000013224) ----------------------------------------------------
__int64 __fastcall NmQueryPacketFilter(FilterDeviceExtension *ModuleContext, __int64 Q)
{
  NDIS_STATUS Status; // eax
  unsigned int NtStatus; // ebx
  __int64 status; // [rsp+20h] [rbp-28h]
  __int64 v7; // [rsp+30h] [rbp-18h]
  unsigned int *v8; // [rsp+60h] [rbp+18h] BYREF

  LODWORD(v7) = 0;
  Status = nmFilterDoInternalRequest(OID_GEN_CURRENT_PACKET_FILTER, ModuleContext, 0, (__int64 *)Q, 4u, 0, v7, (unsigned int *)&v8);
  NtStatus = Status;
  if ( g_NmDebug )
  {
    LODWORD(status) = Status;
    DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmQPacketFilter: Attempted to Q %x, status %x\n", *(unsigned int *)Q, status);
  }
  return NtStatus;
}
// 1325B: variable 'v7' is possibly undefined
// 1327E: variable 'status' is possibly undefined
// 1919C: using guessed type int g_NmDebug;

//----- (0000000000013298) ----------------------------------------------------
_BOOL8 __fastcall NmSetAppropriatePacketFilter(FilterDeviceExtension *DeviceExtension, int a2)
{
  KIRQL irql_1; // dl
  int v5; // eax
  int v6; // esi
  int v7; // ebp
  int filter; // edi
  BOOL b; // er12
  KIRQL irql_2; // al

  _InterlockedAdd(&DeviceExtension->field_210, 1u);
  irql_1 = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->SpinLock);
  DeviceExtension->irql = irql_1;
  v5 = DeviceExtension->dword21C;
  if ( a2 <= 0 )
  {
    if ( a2 < 0 )
      DeviceExtension->dword21C = v5 - 1;
  }
  else
  {
    DeviceExtension->dword21C = v5 + 1;
  }
  v6 = DeviceExtension->dword21C;
  v7 = DeviceExtension->dword220;
  filter = DeviceExtension->filter;
  b = (v5 == 0) != (v6 == 0);
  KeReleaseSpinLock(&DeviceExtension->SpinLock, irql_1);
  if ( b )
  {
    if ( DeviceExtension->Dot11 )
    {
      if ( v6 > 0 )
        filter = 0x3FF002F;
      goto LABEL_18;
    }
    if ( !v6 )
      goto LABEL_11;
    if ( v7 || DeviceExtension->gap224 )
    {
      filter = 32;
      goto LABEL_18;
    }
    if ( !BYTE4(DeviceExtension->field_234) || BYTE5(DeviceExtension->field_234) )
      filter = 128;
    else
LABEL_11:
      filter = DeviceExtension->filter;
LABEL_18:
    irql_2 = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->SpinLock);
    HIDWORD(DeviceExtension->filter) = filter;
    DeviceExtension->irql = irql_2;
    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql_2);
    NmSetPacketFilter(DeviceExtension, filter);
  }
  if ( _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF) == 1 )
    NmDestroyFilterModule(DeviceExtension);
  return b;
}

//----- (00000000000133E8) ----------------------------------------------------
NTSTATUS __fastcall CopyUnicodeStringToBuffer(void *a1, unsigned __int64 a2, _DWORD *a3, const void **a4)
{
  NTSTATUS NtStatus; // ebx
  unsigned __int64 size; // r8

  NtStatus = STATUS_SUCCESS;
  if ( !a1 )
    return NDIS_STATUS_INVALID_PARAMETER;
  size = *(unsigned __int16 *)a4;
  if ( size > a2 )
    return NDIS_STATUS_BUFFER_OVERFLOW;
  memmove(a1, a4[1], size);
  *a3 = *(unsigned __int16 *)a4;
  return NtStatus;
}

//----- (0000000000013444) ----------------------------------------------------
NTSTATUS __fastcall NmEnumNetworks(PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation, size_t *Information)
{
  PMDL MdlAddress; // r9
  ULONG OutputBufferLength; // eax
  unsigned int i; // er15
  ULONG Length; // er12
  unsigned int j; // ebx
  KIRQL irql; // al
  _LIST_ENTRY *FilterModuleList; // rdx
  KIRQL Irql; // r11
  int v15; // eax
  _LIST_ENTRY *v16; // r8
  __int64 v17; // rax
  _LIST_ENTRY **v18; // r8
  __int64 v19; // r9
  __int64 v20; // rax
  PMDL MdlAddress_3; // rbx
  bool b; // zf
  PVOID MappedSystemVa_2; // rax
  MACRO_NDIS_MEMORY NtStatus; // ebx
  _DWORD *p; // rax
  _DWORD *v26; // r14
  __int64 v27; // rax
  _DWORD *v28; // r13
  _WORD *v29; // r14
  unsigned __int64 v30; // rsi
  char *v31; // rbp
  KIRQL Irql_1; // al
  _LIST_ENTRY *FilterModuleList_1; // rdi
  _WORD *v34; // rbx
  int v35; // eax
  const void **v36; // r9
  unsigned int v37; // ecx
  NTSTATUS status_1; // eax
  unsigned int v39; // ecx
  NTSTATUS NtStatus_1; // eax
  unsigned int v41; // ecx
  NTSTATUS status; // eax
  unsigned int v43; // ecx
  NTSTATUS Status; // eax
  _LIST_ENTRY *v45; // rax
  __int64 v46; // r13
  unsigned __int16 *v47; // rdx
  unsigned __int64 v48; // r12
  PMDL MdlAddress_1; // rbx
  PVOID MappedSystemVa; // rax
  _DWORD *v51; // [rsp+30h] [rbp-58h]
  PMDL MdlAddress_2; // [rsp+38h] [rbp-50h] BYREF
  PVOID MappedSystemVa_1; // [rsp+40h] [rbp-48h]
  ULONG ByteOffset; // [rsp+48h] [rbp-40h]
  ULONG ByteCount; // [rsp+4Ch] [rbp-3Ch]
  PIRP irp; // [rsp+90h] [rbp+8h]
  unsigned int a4; // [rsp+98h] [rbp+10h] BYREF
  ULONG Length_2; // [rsp+A8h] [rbp+20h]

  irp = Irp;
  MdlAddress = Irp->MdlAddress;
  OutputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.OutputBufferLength;
  i = 0;
  Length = 4;
  j = 0;
  Length_2 = 4;
  if ( MdlAddress->ByteCount != OutputBufferLength )
    return NDIS_STATUS_BUFFER_OVERFLOW;
  irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
  FilterModuleList = g_FilterModuleList.Flink;
  Irql = irql;
  g_Irql = irql;
  if ( g_FilterModuleList.Flink != &g_FilterModuleList )
  {
    do
    {
      v15 = (int)FilterModuleList[31].Blink;
      if ( v15 != 5 && v15 != 6 && v15 )
      {
        v16 = FilterModuleList[58].Flink;
        Length += (ULONG)&FilterModuleList[21].Flink->Flink[13]
                + LOWORD(FilterModuleList[18].Flink)
                + LOWORD(FilterModuleList[17].Flink)
                + LOWORD(FilterModuleList[16].Flink);
        if ( v16 )
        {
          v17 = HIDWORD(v16[10].Flink);
          if ( (_DWORD)v17 )
          {
            v18 = &v16[11].Blink;
            v19 = v17;
            do
            {
              v20 = (__int64)*v18++;
              Length += *(unsigned __int16 *)(v20 + 16);
              --v19;
            }
            while ( v19 );
          }
        }
        ++j;
      }
      FilterModuleList = FilterModuleList->Flink;
    }
    while ( FilterModuleList != &g_FilterModuleList );
    Length_2 = Length;
  }
  KeReleaseSpinLock(&g_FilterListLock, Irql);
  *Information = Length;
  if ( CurrentStackLocation->Parameters.DeviceIoControl.OutputBufferLength >= Length )
  {
    p = ExAllocatePoolWithTag(NonPagedPool, Length, ' 3MN');
    v26 = p;
    if ( !p )
      return NDIS_STATUS_RESOURCES;
    memset(p, 0, Length);
    *v26 = 0;
    v27 = 104i64 * j;
    v28 = v26;
    v51 = v26;
    v29 = v26 + 1;
    v30 = Length - v27 * 2 - 4;
    v31 = (char *)&v29[v27];
    Irql_1 = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    FilterModuleList_1 = g_FilterModuleList.Flink;
    g_Irql = Irql_1;
    if ( g_FilterModuleList.Flink != &g_FilterModuleList )
    {
      v34 = v29 + 5;
      do
      {
        v35 = (int)FilterModuleList_1[31].Blink;
        if ( v35 != 5 && v35 != 6 && v35 )
        {
          *v29 = 208;
          *(_DWORD *)(v34 - 3) = FilterModuleList_1[53].Blink;
          *(v34 - 1) = WORD2(FilterModuleList_1[53].Blink);
          *(_DWORD *)v34 = FilterModuleList_1[55].Blink;
          v34[2] = WORD2(FilterModuleList_1[55].Blink);
          *(_DWORD *)(v34 + 51) = HIDWORD(FilterModuleList_1[19].Flink);
          *(_QWORD *)(v34 + 55) = FilterModuleList_1[19].Blink;
          *(_DWORD *)(v34 + 59) = FilterModuleList_1[20].Blink;
          *(_QWORD *)(v34 + 63) = FilterModuleList_1[27].Blink;
          *(_DWORD *)(v34 + 67) = FilterModuleList_1[28].Flink;
          *(_QWORD *)(v34 + 71) = FilterModuleList_1[28].Blink;
          *(v34 - 4) = 1857;
          if ( LODWORD(FilterModuleList_1[23].Blink) == 3 )
          {
            *(_QWORD *)(v34 + 3) = 0i64;
            *(_QWORD *)(v34 + 7) = 0i64;
          }
          else
          {
            *(_QWORD *)(v34 + 3) = FilterModuleList_1[22].Blink;
            *(_QWORD *)(v34 + 7) = FilterModuleList_1[23].Flink;
          }
          *(_DWORD *)(v34 + 11) = FilterModuleList_1[23].Blink;
          *(_DWORD *)(v34 + 13) = HIDWORD(FilterModuleList_1[23].Blink);
          if ( LOBYTE(FilterModuleList_1[34].Blink) )
            *(_DWORD *)(v34 + 17) |= 0x10u;
          if ( BYTE4(FilterModuleList_1[33].Flink) )
            *(_DWORD *)(v34 + 17) |= 0x8000u;
          v36 = (const void **)&FilterModuleList_1[21].Flink->Flink;
          v37 = 0;
          a4 = 0;
          if ( v36 )
          {
            status_1 = CopyUnicodeStringToBuffer(v31, v30, &a4, v36);
            v37 = a4;
          }
          else
          {
            status_1 = NDIS_STATUS_INVALID_PARAMETER;
          }
          if ( !status_1 )
          {
            *(_DWORD *)(v34 + 19) = v37;
            v31 += v37;
            v30 -= v37;
          }
          v39 = 0;
          a4 = 0;
          if ( FilterModuleList_1 == (_LIST_ENTRY *)-256i64 )
          {
            NtStatus_1 = NDIS_STATUS_INVALID_PARAMETER;
          }
          else
          {
            NtStatus_1 = CopyUnicodeStringToBuffer(v31, v30, &a4, (const void **)&FilterModuleList_1[16].Flink);
            v39 = a4;
          }
          if ( !NtStatus_1 )
          {
            *(_DWORD *)(v34 + 27) = v39;
            v31 += v39;
            v30 -= v39;
          }
          v41 = 0;
          a4 = 0;
          if ( FilterModuleList_1 == (_LIST_ENTRY *)0xFFFFFFFFFFFFFEF0i64 )
          {
            status = NDIS_STATUS_INVALID_PARAMETER;
          }
          else
          {
            status = CopyUnicodeStringToBuffer(v31, v30, &a4, (const void **)&FilterModuleList_1[0x11].Flink);
            v41 = a4;
          }
          if ( !status )
          {
            *(_DWORD *)(v34 + 35) = v41;
            v31 += v41;
            v30 -= v41;
          }
          v43 = 0;
          a4 = 0;
          if ( FilterModuleList_1 == (_LIST_ENTRY *)0xFFFFFFFFFFFFFEE0i64 )
          {
            Status = NDIS_STATUS_INVALID_PARAMETER;
          }
          else
          {
            Status = CopyUnicodeStringToBuffer(v31, v30, &a4, (const void **)&FilterModuleList_1[0x12].Flink);
            v43 = a4;
          }
          if ( !Status )
          {
            *(_DWORD *)(v34 + 43) = v43;
            v31 += v43;
            v30 -= v43;
          }
          if ( FilterModuleList_1[58].Flink )
          {
            *(_DWORD *)(v34 + 75) = HIDWORD(FilterModuleList_1[58].Flink[9].Flink);
            *(_DWORD *)(v34 + 77) = FilterModuleList_1[58].Flink[9].Blink;
            *(_DWORD *)(v34 + 79) = HIDWORD(FilterModuleList_1[58].Flink[9].Blink);
            *((_BYTE *)v34 + 162) = FilterModuleList_1[58].Flink[10].Flink;
            *(_DWORD *)(v34 + 83) = HIDWORD(FilterModuleList_1[58].Flink[10].Flink);
            v45 = FilterModuleList_1[58].Flink;
            if ( HIDWORD(v45[10].Flink) )
            {
              v46 = 184i64;
              do
              {
                v47 = *(unsigned __int16 **)((char *)&v45->Flink + v46);
                v48 = v47[8];
                if ( v30 >= v48 )
                {
                  memmove(v31, v47, v47[8]);
                  v31 += v48;
                  v30 -= v48;
                }
                v45 = FilterModuleList_1[58].Flink;
                ++i;
                v46 += 8i64;
              }
              while ( i < HIDWORD(v45[10].Flink) );
              v28 = v51;
            }
            i = 0;
          }
          v29 += 104;
          v34 += 104;
          ++*v28;
        }
        FilterModuleList_1 = FilterModuleList_1->Flink;
      }
      while ( FilterModuleList_1 != &g_FilterModuleList );
      Irql_1 = g_Irql;
      Length = Length_2;
    }
    KeReleaseSpinLock(&g_FilterListLock, Irql_1);
    MdlAddress_1 = irp->MdlAddress;
    MdlAddress_2 = MdlAddress_1;
    if ( MdlAddress_1 )
    {
      if ( (MdlAddress_1->MdlFlags & 5) != 0 )
        MappedSystemVa = MdlAddress_1->MappedSystemVa;
      else
        MappedSystemVa = MmMapLockedPagesSpecifyCache(MdlAddress_1, 0, MmCached, 0i64, 0, NormalPagePriority);
      MappedSystemVa_1 = MappedSystemVa;
      ByteOffset = MdlAddress_1->ByteOffset;
      ByteCount = MdlAddress_1->ByteCount;
    }
    else
    {
      MappedSystemVa_1 = 0i64;
      ByteOffset = 0;
      ByteCount = 0;
    }
    NtStatus = NmCopyBufferToMdlWrapper(&MdlAddress_2, v28, Length, &a4);
    ExFreePoolWithTag(v28, 0);
  }
  else
  {
    if ( CurrentStackLocation->Parameters.DeviceIoControl.OutputBufferLength == 4 )
    {
      MdlAddress_3 = Irp->MdlAddress;
      if ( MdlAddress_3 )
      {
        b = (MdlAddress_3->MdlFlags & 5) == 0;
        MdlAddress_2 = Irp->MdlAddress;
        if ( b )
          MappedSystemVa_2 = MmMapLockedPagesSpecifyCache(MdlAddress_3, 0, MmCached, 0i64, 0, NormalPagePriority);
        else
          MappedSystemVa_2 = MdlAddress_3->MappedSystemVa;
        MappedSystemVa_1 = MappedSystemVa_2;
        ByteOffset = MdlAddress_3->ByteOffset;
        ByteCount = MdlAddress_3->ByteCount;
        NmCopyBufferToMdlWrapper(&MdlAddress_2, &g_NmDriverVersion, 4u, &a4);
      }
    }
    NtStatus = NDIS_STATUS_BUFFER_OVERFLOW;
  }
  return NtStatus;
}

//----- (0000000000013A24) ----------------------------------------------------
NTSTATUS __fastcall NmCopyBufferToMdlWrapper(PMDL *MdlAddress, const void *a2, unsigned int a3, _DWORD *a4)
{
  NTSTATUS NtStatus; // ebp
  unsigned int size; // er14
  const void *v7; // rax
  PMDL mdl; // r13
  PMDL mdl_1; // rbx
  __int64 Size; // rsi
  PMDL MemoryDescriptorList; // rcx
  _MDL *mdl_2; // rax
  ULONG ByteOffset; // eax
  ULONG ByteCount; // eax
  const void *v17; // [rsp+68h] [rbp+10h]

  v17 = a2;
  NtStatus = 0;
  size = a3;
  v7 = a2;
  *a4 = 0;
  if ( !MdlAddress )
    return NDIS_STATUS_RESOURCES;
  mdl = *MdlAddress;
  if ( !*MdlAddress )
    return NDIS_STATUS_BUFFER_OVERFLOW;
  if ( !MdlAddress[1] )
    return NDIS_STATUS_RESOURCES;
  if ( a3 )
  {
    do
    {
      if ( !mdl )
        break;
      mdl_1 = MdlAddress[1];
      Size = size;
      if ( *((_DWORD *)MdlAddress + 5) < size )
        Size = *((unsigned int *)MdlAddress + 5);
      memmove(MdlAddress[1], v7, Size);
      *((_DWORD *)MdlAddress + 4) += Size;
      *((_DWORD *)MdlAddress + 5) -= Size;
      *a4 += Size;
      size -= Size;
      MdlAddress[1] = (PMDL)((char *)mdl_1 + Size);
      if ( !*((_DWORD *)MdlAddress + 5) )
      {
        MemoryDescriptorList = mdl->Next;
        *MdlAddress = mdl->Next;
        if ( MemoryDescriptorList )
        {
          if ( (MemoryDescriptorList->MdlFlags & 5) != 0 )
            mdl_2 = (_MDL *)MemoryDescriptorList->MappedSystemVa;
          else
            mdl_2 = (_MDL *)MmMapLockedPagesSpecifyCache(MemoryDescriptorList, 0, MmCached, 0i64, 0u, NormalPagePriority);
        }
        else
        {
          mdl_2 = 0i64;
        }
        mdl = *MdlAddress;
        MdlAddress[1] = mdl_2;
        ByteOffset = 0;
        if ( mdl )
          ByteOffset = mdl->ByteOffset;
        *((_DWORD *)MdlAddress + 4) = ByteOffset;
        ByteCount = 0;
        if ( mdl )
          ByteCount = mdl->ByteCount;
        *((_DWORD *)MdlAddress + 5) = ByteCount;
      }
      v7 = v17;
    }
    while ( size );
  }
  return NtStatus;
}

//----- (0000000000013B64) ----------------------------------------------------
__int64 __fastcall NmInitializeGlobals(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  KEY_VALUE_FULL_INFORMATION *KeyValueInformation_1; // rbx
  NTSTATUS NtStatus; // eax
  GroupAce *GroupAce; // rax
  __int16 DataLength; // cx
  NTSTATUS Status; // eax
  int AttachUpperLayers; // eax
  NTSTATUS NtStatus_1; // eax
  NTSTATUS NtStatus_2; // eax
  NTSTATUS NtStatus_3; // eax
  __int64 result; // rax
  ULONG Length; // [rsp+30h] [rbp-98h] BYREF
  HANDLE KeyHandle; // [rsp+38h] [rbp-90h] BYREF
  UNICODE_STRING DestinationString; // [rsp+40h] [rbp-88h] BYREF
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+50h] [rbp-78h] BYREF
  KEY_VALUE_FULL_INFORMATION KeyValueInformation; // [rsp+80h] [rbp-48h] BYREF

  ObjectAttributes.Length = 0x30;
  ObjectAttributes.RootDirectory = NULL;
  ObjectAttributes.Attributes = OBJ_CASE_INSENSITIVE;
  ObjectAttributes.ObjectName = RegistryPath;
  KeyValueInformation_1 = NULL;
  KeyHandle = NULL;
  Length = 24;
  ObjectAttributes.SecurityDescriptor = NULL;
  ObjectAttributes.SecurityQualityOfService = NULL;
  if ( !ZwOpenKey(&KeyHandle, KEY_READ, &ObjectAttributes) )
  {
    RtlInitUnicodeString(&DestinationString, L"GroupSid");
    NtStatus = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
    if ( NtStatus == NDIS_STATUS_BUFFER_OVERFLOW || NtStatus == (unsigned int)STATUS_BUFFER_TOO_SMALL )
    {
      KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
      if ( KeyValueInformation_1 )
      {
        if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length) )
        {
          GroupAce = (GroupAce *)ExAllocatePoolWithTag(NonPagedPool, KeyValueInformation_1->DataLength + 12i64, 'gamn');
          g_GroupAce = GroupAce;
          if ( GroupAce )
          {                                     // GroupAce肯定是一个结构。
            GroupAce->char0 = NULL;
            GroupAce->byte1 = NULL;
            DataLength = LOWORD(KeyValueInformation_1->DataLength) + 12;
            GroupAce->dword4 = 0x120089;
            GroupAce->DataLength = DataLength;
            memmove(&GroupAce->DataOffset, (char *)KeyValueInformation_1 + KeyValueInformation_1->DataOffset, KeyValueInformation_1->DataLength);
            ExFreePoolWithTag(KeyValueInformation_1, 0);
            KeyValueInformation_1 = NULL;
            Length = 24;
            RtlInitUnicodeString(&DestinationString, L"LoadUpperLayers");
            Status = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
            if ( Status == NDIS_STATUS_BUFFER_OVERFLOW || Status == (unsigned int)STATUS_BUFFER_TOO_SMALL )
            {
              KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
              if ( KeyValueInformation_1 )
              {
                if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length)
                  && KeyValueInformation_1->DataLength )
                {
                  AttachUpperLayers = g_AttachUpperLayers;
                  if ( *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset) )
                    AttachUpperLayers = *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset);
                  g_AttachUpperLayers = AttachUpperLayers;
                }
                ExFreePoolWithTag(KeyValueInformation_1, 0);
                KeyValueInformation_1 = NULL;
              }
            }
            Length = 24;
            RtlInitUnicodeString(&DestinationString, L"TimeStampSyncIntervalCount");
            NtStatus_1 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
            if ( NtStatus_1 == NDIS_STATUS_BUFFER_OVERFLOW || NtStatus_1 == (unsigned int)STATUS_BUFFER_TOO_SMALL )
              KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
            if ( KeyValueInformation_1 )
            {
              if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length)
                && KeyValueInformation_1->DataLength == 4
                && KeyValueInformation_1->DataOffset )
              {
                g_TimeSyncIntervalCount = *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset);
              }
              ExFreePoolWithTag(KeyValueInformation_1, 0);
              KeyValueInformation_1 = NULL;
            }
            Length = 24;
            RtlInitUnicodeString(&DestinationString, L"TimerIntervalMS");
            NtStatus_2 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
            if ( NtStatus_2 == NDIS_STATUS_BUFFER_OVERFLOW || NtStatus_2 == (unsigned int)STATUS_BUFFER_TOO_SMALL )
              KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
            if ( KeyValueInformation_1 )
            {
              if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length)
                && KeyValueInformation_1->DataLength == 4
                && KeyValueInformation_1->DataOffset )
              {
                g_FilterScanTimerInterval = *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset);
              }
              ExFreePoolWithTag(KeyValueInformation_1, 0);
              KeyValueInformation_1 = NULL;
            }
            Length = 24;
            RtlInitUnicodeString(&DestinationString, L"OlpFilterConditionMaxCount");
            NtStatus_3 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
            if ( NtStatus_3 == NDIS_STATUS_BUFFER_OVERFLOW || NtStatus_3 == (unsigned int)STATUS_BUFFER_TOO_SMALL )
              KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
            if ( KeyValueInformation_1 )
            {
              if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length)
                && KeyValueInformation_1->DataLength == 4
                && KeyValueInformation_1->DataOffset )
              {
                g_OlpFilterConditionMaxCount = *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset);
              }
              ExFreePoolWithTag(KeyValueInformation_1, 0);
              KeyValueInformation_1 = NULL;
            }
          }
        }
      }
    }
  }
  if ( KeyHandle )
    ZwClose(KeyHandle);
  if ( KeyValueInformation_1 )
    ExFreePoolWithTag(KeyValueInformation_1, 0);
  g_FilterListLock = NULL;
  g_FilterDriverObject = DriverObject;
  g_FilterModuleList.Blink = &g_FilterModuleList;
  g_FilterModuleList.Flink = &g_FilterModuleList;
  g_ByPassFilterModuleList.Blink = &g_ByPassFilterModuleList;
  g_ByPassFilterModuleList.Flink = &g_ByPassFilterModuleList;
  result = MEMORY[0xFFFFF78000000014];
  g_InternalRequestFailedCount = NULL;
  g_DriverStartTimeStamp = MEMORY[0xFFFFF78000000014];
  return result;
}
// 19120: using guessed type int g_TimeSyncIntervalCount;
// 19124: using guessed type int g_FilterScanTimerInterval;
// 19128: using guessed type int g_OlpFilterConditionMaxCount;
// 19198: using guessed type int g_AttachUpperLayers;
// 191A0: using guessed type __int64 g_DriverStartTimeStamp;
// 191A8: using guessed type int g_InternalRequestFailedCount;

//----- (000000000001406C) ----------------------------------------------------
NTSTATUS __fastcall LookupFilterModule(NDIS_HANDLE NdisFilterHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters, FilterDeviceExtension **DeferredContext)
{
  PNDIS_STRING FilterModuleGuidName; // rbp
  NTSTATUS NtStatus; // er12
  KIRQL irql; // al
  _LIST_ENTRY *FilterModuleList; // rdi
  SIZE_T Length_1; // rsi
  FilterDeviceExtension *temp; // rbx
  _LIST_ENTRY *v11; // rcx
  KIRQL Irql; // al
  _LIST_ENTRY *ByPassFilterModuleList; // rdi
  SIZE_T Length; // rsi
  _LIST_ENTRY *v15; // rcx
  KIRQL irql_1; // al
  bool b; // zf

  FilterModuleGuidName = AttachParameters->FilterModuleGuidName;
  NtStatus = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
  irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
  FilterModuleList = g_FilterModuleList.Flink;
  g_Irql = irql;
  if ( g_FilterModuleList.Flink == &g_FilterModuleList )
  {
LABEL_7:
    KeReleaseSpinLock(&g_FilterListLock, irql);
    Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    ByPassFilterModuleList = g_ByPassFilterModuleList.Flink;
    g_Irql = Irql;
    if ( g_ByPassFilterModuleList.Flink == &g_ByPassFilterModuleList )
    {
LABEL_13:
      KeReleaseSpinLock(&g_FilterListLock, Irql);
      temp = 0i64;
      goto LABEL_14;
    }
    LOWORD(Length) = FilterModuleGuidName->Length;
    while ( 1 )
    {
      temp = CONTAINING_RECORD(ByPassFilterModuleList, FilterDeviceExtension, list);
      v15 = ByPassFilterModuleList[20].Flink;
      if ( (_WORD)Length == LOWORD(v15->Flink) )
      {
        Length = FilterModuleGuidName->Length;
        if ( Length == RtlCompareMemory(v15->Blink, FilterModuleGuidName->Buffer, Length) )
          break;
      }
      ByPassFilterModuleList = ByPassFilterModuleList->Flink;
      if ( ByPassFilterModuleList == &g_ByPassFilterModuleList )
      {
        Irql = g_Irql;
        goto LABEL_13;
      }
    }
  }
  else
  {
    LOWORD(Length_1) = FilterModuleGuidName->Length;
    while ( 1 )
    {
      temp = (FilterDeviceExtension *)&FilterModuleList[-1];
      v11 = FilterModuleList[20].Flink;
      if ( (_WORD)Length_1 == LOWORD(v11->Flink) )
      {
        Length_1 = FilterModuleGuidName->Length;
        if ( Length_1 == RtlCompareMemory(v11->Blink, FilterModuleGuidName->Buffer, Length_1) )
          break;
      }
      FilterModuleList = FilterModuleList->Flink;
      if ( FilterModuleList == &g_FilterModuleList )
      {
        irql = g_Irql;
        goto LABEL_7;
      }
    }
  }
  if ( temp->State == FilterDetaching )
    ++temp->field_210;
  KeReleaseSpinLock(&g_FilterListLock, g_Irql);
LABEL_14:
  if ( temp )
  {
    irql_1 = KeAcquireSpinLockRaiseToDpc(&temp->SpinLock);
    b = temp->State == FilterDetaching;
    temp->irql = irql_1;
    if ( b )
    {
      temp->dword214 = 0;
      temp->NdisFilterHandle = NdisFilterHandle;
      temp->State = FilterInitialized;
    }
    KeReleaseSpinLock(&temp->SpinLock, irql_1);
    *DeferredContext = temp;
    NtStatus = STATUS_SUCCESS;
  }
  return NtStatus;
}

//----- (000000000001422C) ----------------------------------------------------
NDIS_STATUS __fastcall NetmonFilterAttach(NDIS_HANDLE NdisFilterHandle, NDIS_HANDLE FilterDriverContext, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters)
{
  PNDIS_STRING FilterModuleGuidName; // r9
  int b; // er13
  __int16 Length; // bp
  NTSTATUS NtStatus; // ebx
  PNDIS_STRING BaseMiniportName; // rdx
  FilterDeviceExtension *FilterModuleContext; // rdi
  int FilterScanTimerInterval; // eax
  struct _NDIS_FILTER_ATTRIBUTES FilterAttributes; // [rsp+20h] [rbp-68h] BYREF
  FilterDeviceExtension *DeferredContext; // [rsp+28h] [rbp-60h] BYREF
  char Dst[40]; // [rsp+30h] [rbp-58h] BYREF

  FilterModuleGuidName = AttachParameters->FilterModuleGuidName;
  DeferredContext = NULL;
  b = NULL;
  Length = 48;
  if ( FilterModuleGuidName->Length )
    Length = FilterModuleGuidName->Buffer[(unsigned __int64)(FilterModuleGuidName->Length - 1) >> 1];
  if ( FilterDriverContext != g_FilterDriverObject )
    return NDIS_STATUS_INVALID_PARAMETER;
  if ( !g_AttachUpperLayers && Length != 48 )
  {
    if ( g_NmDebug )
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NetmonFilterAttach: Discarding %ws\n", FilterModuleGuidName->Buffer);
    return NDIS_STATUS_INVALID_PARAMETER;
  }
  if ( AttachParameters->MiniportMediaType != NdisMediumWan
    || (memmove(Dst, L"\\DEVICE\\NDISWANBH", 36u),
        BaseMiniportName = AttachParameters->BaseMiniportName,
        NtStatus = NDIS_STATUS_FAILURE,
        BaseMiniportName->MaximumLength == 36)
    && RtlCompareMemory(Dst, BaseMiniportName->Buffer, 36ui64) == 36 )
  {
    NtStatus = LookupFilterModule(NdisFilterHandle, AttachParameters, &DeferredContext);
    if ( NtStatus )
    {
      if ( NmCreateFilterModule(NdisFilterHandle, AttachParameters, &DeferredContext) )
        return NDIS_STATUS_RESOURCES;
      FilterModuleContext = DeferredContext;
      b = TRUE;
      LOWORD(DeferredContext->gap20C) = Length;
    }
    else
    {
      FilterModuleContext = DeferredContext;
      if ( DeferredContext->State != FilterInitialized )
        return NtStatus;
    }
    FilterAttributes.Header.Size = 8;
    FilterAttributes.Header.Revision = NDIS_CONFIGURATION_OBJECT_REVISION_1;
    FilterAttributes.Header.Type = NDIS_OBJECT_TYPE_FILTER_ATTRIBUTES;
    FilterAttributes.Flags = NULL;
    NtStatus = NdisFSetAttributes(NdisFilterHandle, FilterModuleContext, &FilterAttributes);
    if ( !NtStatus )
    {
      NmInitializeMinipInfo(AttachParameters->MiniportMediaType, FilterModuleContext);
      FilterScanTimerInterval = g_FilterScanTimerInterval;
      FilterModuleContext->State = FilterPausing;
      FilterModuleContext->DueTime = 10000 * FilterScanTimerInterval;
      StackModuleInstance(FilterModuleContext, b);
    }
  }
  return NtStatus;
}
// 17D00: using guessed type wchar_t aDeviceNdiswanb[18];
// 19124: using guessed type int g_FilterScanTimerInterval;
// 19198: using guessed type int g_AttachUpperLayers;
// 1919C: using guessed type int g_NmDebug;

//----- (000000000001440C) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonFilterDetach(FilterDeviceExtension *FilterModuleContext)
{
  KIRQL irql; // al
  KIRQL irql_1; // al

  irql = KeAcquireSpinLockRaiseToDpc(&FilterModuleContext->SpinLock);
  FilterModuleContext->State = FilterRestarting;
  FilterModuleContext->irql = irql;
  KeReleaseSpinLock(&FilterModuleContext->SpinLock, irql);
  if ( !_InterlockedExchange(&FilterModuleContext->dword214, 1) )
  {
    NmStopTimerSystem(FilterModuleContext);
    irql_1 = KeAcquireSpinLockRaiseToDpc(&FilterModuleContext->SpinLock);
    FilterModuleContext->State = FilterDetaching;
    FilterModuleContext->irql = irql_1;
    KeReleaseSpinLock(&FilterModuleContext->SpinLock, irql_1);
    if ( _InterlockedExchangeAdd(&FilterModuleContext->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule(FilterModuleContext);
  }
}

//----- (00000000000144B4) ----------------------------------------------------
NTSTATUS __fastcall NmCreateFilterModule(NDIS_HANDLE NdisFilterHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters, FilterDeviceExtension **DeferredContext)
{
  void *v3; // r12
  PNDIS_STRING BaseMiniportName; // rdx
  Dot11Filter *Dot11; // r13
  int NtStatus; // esi
  int i; // edi
  USHORT Length; // r11
  PWSTR Buffer; // rax
  USHORT MaximumLength; // cx
  PVOID v14; // rax
  ULONG DeviceExtensionSize; // edi
  FilterDeviceExtension *DeviceExtension; // r14
  size_t Length_1; // edx
  void *v18; // rcx
  size_t Length_2; // edx
  void *v20; // rcx
  size_t Length_3; // edx
  UNICODE_STRING SymbolicLinkName_1; // xmm1
  __m128i v23; // xmm0
  UNICODE_STRING BaseMiniport; // [rsp+40h] [rbp-78h] BYREF
  UNICODE_STRING DeviceName; // [rsp+50h] [rbp-68h] BYREF
  __m128i v27; // [rsp+60h] [rbp-58h] BYREF
  UNICODE_STRING SymbolicLinkName; // [rsp+70h] [rbp-48h] BYREF
  PDEVICE_OBJECT pDeviceObject; // [rsp+C8h] [rbp+10h] BYREF
  Dot11Filter *Dot11Filter; // [rsp+D8h] [rbp+20h] BYREF

  v3 = 0i64;
  BaseMiniportName = AttachParameters->BaseMiniportName;
  DeviceName.Length = 0;
  DeviceName.MaximumLength = 0;
  DeviceName.Buffer = 0i64;
  SymbolicLinkName.Length = 0;
  SymbolicLinkName.MaximumLength = 0;
  SymbolicLinkName.Buffer = 0i64;
  v27.i32[0] = 0;
  v27.i64[1] = 0i64;
  Dot11 = 0i64;
  Dot11Filter = 0i64;
  NtStatus = 0;
  if ( BaseMiniportName )
  {
    i = 0;
    RtlInitUnicodeString(&BaseMiniport, BaseMiniportName->Buffer);
    Length = BaseMiniport.Length;
    if ( BaseMiniport.Length )
    {
      Buffer = BaseMiniport.Buffer;
      MaximumLength = BaseMiniport.MaximumLength;
      do
      {
        if ( *Buffer == '\\' )
          ++i;
        Length -= 2;
        MaximumLength -= 2;
        ++Buffer;
        BaseMiniport.Length = Length;
        BaseMiniport.MaximumLength = MaximumLength;
        BaseMiniport.Buffer = Buffer;
      }
      while ( i != 2 && Length );
    }
    v14 = NdisAllocateMemoryWithTagPriority(NdisFilterHandle, Length, 't3mN', LowPoolPriority);
    v3 = v14;
    v27.i64[1] = (__int64)v14;
    if ( v14 )
    {
      v27.i16[1] = BaseMiniport.Length;
      memmove(v14, BaseMiniport.Buffer, BaseMiniport.Length);
      v27.i16[0] = BaseMiniport.Length;
    }
    else
    {
      NtStatus = NDIS_STATUS_RESOURCES;
    }
  }
  if ( NtStatus < 0 )
    goto LABEL_28;
  if ( NmBuildDeviceName(NdisFilterHandle, AttachParameters->FilterModuleGuidName, L"\\Device\\Nm3_", &DeviceName) < 0 )
  {
    NtStatus = NDIS_STATUS_FAILURE;
LABEL_28:
    if ( v3 )
      NdisFreeMemory(v3, 0, 0);
    if ( DeviceName.Buffer )
      NdisFreeMemory(DeviceName.Buffer, 0, 0);
    if ( SymbolicLinkName.Buffer )
      NdisFreeMemory(SymbolicLinkName.Buffer, 0, 0);
    return NtStatus;
  }
  NtStatus = NmBuildDeviceName(NdisFilterHandle, AttachParameters->FilterModuleGuidName, L"\\DosDevices\\Nm3_", &SymbolicLinkName);
  if ( NtStatus < 0 )
    goto LABEL_28;
  if ( AttachParameters->MiniportMediaType == NdisMediumNative802_11
    && AttachParameters->FilterModuleGuidName->Buffer[(unsigned __int64)(AttachParameters->FilterModuleGuidName->Length - 1) >> 1] == 48 )
  {
    NmCreateDot11Filter(NdisFilterHandle, AttachParameters, &Dot11Filter);
    Dot11 = Dot11Filter;
    if ( !Dot11Filter )
    {
      NtStatus = NDIS_STATUS_RESOURCES;
      goto LABEL_28;
    }
  }
  DeviceExtensionSize = AttachParameters->FilterModuleGuidName->Length
                      + AttachParameters->BaseMiniportInstanceName->Length
                      + AttachParameters->BaseMiniportName->Length
                      + 1000;
  NtStatus = IoCreateDevice(g_FilterDriverObject, DeviceExtensionSize, &DeviceName, FILE_DEVICE_NETWORK, 0x100u, 0u, &pDeviceObject);
  if ( NtStatus < 0 )
    goto LABEL_26;
  pDeviceObject->Flags &= 0xFFFFFF7F;
  NtStatus = IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);
  if ( NtStatus >= 0 )
  {
    pDeviceObject->Flags |= 0x10u;
    DeviceExtension = (FilterDeviceExtension *)pDeviceObject->DeviceExtension;
    memset(DeviceExtension, 0, DeviceExtensionSize);
    DeviceExtension->byte0 = 9;
    DeviceExtension->word2 = 952;
    DeviceExtension->tag = 'MFMN';
    DeviceExtension->Create = NmFilterModuleIoCreate;
    DeviceExtension->NdisFilterHandle = NdisFilterHandle;
    DeviceExtension->Cleanup = NmFilterModuleIoCleanup;
    DeviceExtension->Close = NmFilterModuleIoClose;
    DeviceExtension->Read = NmFilterModuleIoRead;
    DeviceExtension->Control = NmFilterModuleIoControl;
    DeviceExtension->DeviceObject = pDeviceObject;
    memmove(&DeviceExtension->AttachParameters, AttachParameters, 0xA8u);
    DeviceExtension->qword3C0 = &DeviceExtension->FilterModuleGuidName;
    Length_1 = AttachParameters->FilterModuleGuidName->Length;
    DeviceExtension->word3BA = Length_1;
    *(_WORD *)&DeviceExtension->char3B8 = Length_1;
    memmove(&DeviceExtension->FilterModuleGuidName, AttachParameters->FilterModuleGuidName->Buffer, Length_1);
    *(__int64 *)((char *)&DeviceExtension->field_149 + 7) = (__int64)&DeviceExtension->char3B8;
    v18 = (void *)(DeviceExtension->qword3C0 + *(unsigned __int16 *)&DeviceExtension->char3B8);
    DeviceExtension->qword3D0 = v18;
    Length_2 = AttachParameters->BaseMiniportInstanceName->Length;
    DeviceExtension->Length = Length_2;
    *(_WORD *)&DeviceExtension->char3C8 = Length_2;
    memmove(v18, AttachParameters->BaseMiniportInstanceName->Buffer, Length_2);
    DeviceExtension->qword160 = &DeviceExtension->char3C8;
    v20 = (void *)(DeviceExtension->qword3D0 + *(unsigned __int16 *)&DeviceExtension->char3C8);
    DeviceExtension->qword3E0 = v20;
    Length_3 = AttachParameters->BaseMiniportName->Length;
    DeviceExtension->word3DA = Length_3;
    *(_WORD *)&DeviceExtension->char3D8 = Length_3;
    memmove(v20, AttachParameters->BaseMiniportName->Buffer, Length_3);
    DeviceExtension->qword168 = &DeviceExtension->char3D8;
    *(__m128i *)&DeviceExtension->m128i110 = _mm_loadu_si128((const __m128i *)&DeviceName);
    SymbolicLinkName_1 = (UNICODE_STRING)_mm_loadu_si128((const __m128i *)&SymbolicLinkName);
    v23 = _mm_loadu_si128(&v27);
    BYTE2(DeviceExtension->gap20C) = 1;
    DeviceExtension->field_210 = 1;
    DeviceExtension->dword214 = 0;
    DeviceExtension->SymbolicLink = SymbolicLinkName_1;
    *(__m128i *)&DeviceExtension->m128i130 = v23;
    NmAddGroupAccessAce(pDeviceObject);
    DeviceExtension->dword21C = 0;
    DeviceExtension->dword220 = 0;
    DeviceExtension->list.Blink = &DeviceExtension->list;
    DeviceExtension->list.Flink = &DeviceExtension->list;
    DeviceExtension->SpinLock = 0i64;
    DeviceExtension->field_2F0 = (__int64)&DeviceExtension->char2E8;
    DeviceExtension->char2E8 = (__int64)&DeviceExtension->char2E8;
    DeviceExtension->State = 1;                 // FilterInitialized
    ExInitializeResourceLite(&DeviceExtension->eresource);
    if ( AttachParameters->MiniportPhysicalMediaType == NdisPhysicalMediumNative802_11 )
    {
      HIDWORD(DeviceExtension->field_3A4) = 1;
      DeviceExtension->Dot11 = Dot11;
    }
    *DeferredContext = DeviceExtension;
  }
  else
  {
    IoDeleteDevice(pDeviceObject);
  }
  if ( NtStatus < 0 )
  {
LABEL_26:
    if ( Dot11 )
      NmDeleteDot11Parameters(Dot11);
    goto LABEL_28;
  }
  return NtStatus;
}

//----- (0000000000014960) ----------------------------------------------------
void __fastcall NmDestroyFilterModule(FilterDeviceExtension *DeviceExtension)
{
  _DEVICE_OBJECT *DeviceObject; // rdi
  _LIST_ENTRY *v3; // rdx
  _LIST_ENTRY *v4; // rax
  void *v5; // rcx
  void *v6; // rcx
  PWSTR v7; // rcx
  Dot11Filter *v8; // rcx

  DeviceObject = (_DEVICE_OBJECT *)DeviceExtension->DeviceObject;
  g_Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
  v3 = DeviceExtension->list.Flink;
  v4 = DeviceExtension->list.Blink;
  v4->Flink = v3;
  v3->Blink = v4;
  KeReleaseSpinLock(&g_FilterListLock, g_Irql);
  ExDeleteResourceLite(&DeviceExtension->eresource);
  IoDeleteSymbolicLink(&DeviceExtension->SymbolicLink);
  v5 = (void *)DeviceExtension->field_138;
  if ( v5 )
    NdisFreeMemory(v5, 0, 0);
  v6 = (void *)DeviceExtension->field_118;
  if ( v6 )
    NdisFreeMemory(v6, 0, 0);
  v7 = DeviceExtension->SymbolicLink.Buffer;
  if ( v7 )
    NdisFreeMemory(v7, 0, 0);
  v8 = DeviceExtension->Dot11;
  if ( v8 )
    NmDeleteDot11Parameters(v8);
  memset(DeviceExtension, 0, 0x3B8u);
  IoDeleteDevice(DeviceObject);
}

//----- (0000000000014A40) ----------------------------------------------------
NTSTATUS __fastcall NmBuildDeviceName(NDIS_HANDLE NdisFilterHandle, PNDIS_STRING FilterModuleGuidName, const WCHAR *str, UNICODE_STRING *Name)
{
  NTSTATUS NtStatus; // ebx
  USHORT Length; // bp
  USHORT Length_1; // r11
  PWSTR Buffer; // rax
  USHORT MaximumLength; // cx
  USHORT MaximumLength_1; // bp
  WCHAR *Buffer_1; // rax
  size_t Length_2; // er8
  PWSTR Buffer_2; // rdx
  size_t Length_3; // er8
  PWSTR Buffer_3; // rdx
  char *Buffer_4; // rcx
  UNICODE_STRING DestinationString; // [rsp+20h] [rbp-28h] BYREF
  UNICODE_STRING Name_1; // [rsp+30h] [rbp-18h] BYREF

  NtStatus = 0;
  RtlInitUnicodeString(&Name_1, str);
  Length = Name_1.Length;
  if ( FilterModuleGuidName )
  {
    RtlInitUnicodeString(&DestinationString, FilterModuleGuidName->Buffer);
    Length_1 = DestinationString.Length;
    if ( DestinationString.Length )
    {
      Buffer = DestinationString.Buffer;
      MaximumLength = DestinationString.MaximumLength;
      do
      {
        if ( *Buffer == '{' )
          break;
        Length_1 -= 2;
        MaximumLength -= 2;
        ++Buffer;
        DestinationString.Length = Length_1;
        DestinationString.MaximumLength = MaximumLength;
        DestinationString.Buffer = Buffer;
      }
      while ( Length_1 );
    }
  }
  else
  {
    Length_1 = DestinationString.Length;
  }
  MaximumLength_1 = Length_1 + Length;
  Buffer_1 = (WCHAR *)NdisAllocateMemoryWithTagPriority(NdisFilterHandle, MaximumLength_1, 't3mN', LowPoolPriority);
  Name->Buffer = Buffer_1;
  if ( !Buffer_1 )
    return NDIS_STATUS_RESOURCES;
  Length_2 = Name_1.Length;
  Buffer_2 = Name_1.Buffer;
  Name->MaximumLength = MaximumLength_1;
  memmove(Buffer_1, Buffer_2, Length_2);
  Length_3 = DestinationString.Length;
  Buffer_3 = DestinationString.Buffer;
  Buffer_4 = (char *)Name->Buffer + Name_1.Length;
  Name->Length = Name_1.Length;
  memmove(Buffer_4, Buffer_3, Length_3);
  Name->Length += DestinationString.Length;
  return NtStatus;
}

//----- (0000000000014B64) ----------------------------------------------------
void __fastcall StackModuleInstance(FilterDeviceExtension *FilterModuleContext, int b)
{
  int v4; // er13
  int v5; // ebp
  int v6; // er12
  KIRQL Irql; // al
  _LIST_ENTRY *FilterModuleList; // rdi
  SIZE_T v9; // rsi
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // cx
  _LIST_ENTRY *v12; // rax
  _LIST_ENTRY *v13; // rcx
  _LIST_ENTRY *v14; // rax
  _LIST_ENTRY *v15; // rcx
  _LIST_ENTRY v16; // rax
  _LIST_ENTRY v17; // rax
  KIRQL Irql_1; // al
  KIRQL Irql_2; // dl
  _LIST_ENTRY *FilterModuleList_1; // rax

  v4 = 0;
  v5 = 0;
  v6 = 0;
  Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
  FilterModuleList = g_FilterModuleList.Flink;
  g_Irql = Irql;
  if ( g_FilterModuleList.Flink != &g_FilterModuleList )
  {
    LOWORD(v9) = FilterModuleContext->m128i130;
    do
    {
      if ( LOWORD(FilterModuleList[18].Flink) == (_WORD)v9 )
      {
        v9 = LOWORD(FilterModuleContext->m128i130);
        if ( v9 == RtlCompareMemory(FilterModuleList[18].Blink, (const void *)FilterModuleContext->field_138, v9) )
        {
          v10 = WORD2(FilterModuleList[31].Blink);
          v11 = FilterModuleContext->gap20C;
          if ( v10 == v11 )
          {
            v5 = 1;
            break;
          }
          if ( v10 > v11 )
          {
            v6 = 1;
            break;
          }
          if ( v10 < v11 )
          {
            v12 = FilterModuleList->Blink;
            v13 = FilterModuleList->Flink;
            v12->Flink = FilterModuleList->Flink;
            v13->Blink = v12;
            v14 = g_ByPassFilterModuleList.Flink;
            FilterModuleList->Flink = g_ByPassFilterModuleList.Flink;
            v4 = 1;
            FilterModuleList->Blink = &g_ByPassFilterModuleList;
            v14->Blink = FilterModuleList;
            g_ByPassFilterModuleList.Flink = FilterModuleList;
            v15 = FilterModuleList[1].Flink;
            BYTE6(FilterModuleList[31].Blink) = 0;
            NdisFRestartFilter(v15);
            break;
          }
        }
      }
      FilterModuleList = FilterModuleList->Flink;
    }
    while ( FilterModuleList != &g_FilterModuleList );
  }
  KeReleaseSpinLock(&g_FilterListLock, g_Irql);
  if ( v4 )
  {
    BYTE2(FilterModuleContext->gap20C) = 1;
    g_Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    if ( FilterModuleContext->gap218 )
      NmInitializeTimerSystem(FilterModuleContext);
    v16.Flink = g_FilterModuleList.Flink;
    FilterModuleContext->list.Flink = g_FilterModuleList.Flink;
    FilterModuleContext->list.Blink = &g_FilterModuleList;
    v16.Flink->Blink = &FilterModuleContext->list;
    g_FilterModuleList.Flink = &FilterModuleContext->list;
  }
  else if ( v6 )
  {
    BYTE2(FilterModuleContext->gap20C) = 0;
    g_Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    v17.Flink = g_ByPassFilterModuleList.Flink;
    FilterModuleContext->list.Blink = &g_ByPassFilterModuleList;
    FilterModuleContext->list.Flink = v17.Flink;
    v17.Flink->Blink = &FilterModuleContext->list;
    g_ByPassFilterModuleList.Flink = &FilterModuleContext->list;
  }
  else
  {
    if ( v5 )
    {
      BYTE2(FilterModuleContext->gap20C) = 1;
      Irql_1 = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
      g_Irql = Irql_1;
      if ( FilterModuleContext->gap218 )
      {
        NmInitializeTimerSystem(FilterModuleContext);
        Irql_1 = g_Irql;
      }
      Irql_2 = Irql_1;
      goto LABEL_26;
    }
    if ( !b )
      return;
    BYTE2(FilterModuleContext->gap20C) = 1;
    g_Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    FilterModuleList_1 = g_FilterModuleList.Flink;
    FilterModuleContext->list.Blink = &g_FilterModuleList;
    FilterModuleContext->list.Flink = FilterModuleList_1;
    FilterModuleList_1->Blink = &FilterModuleContext->list;
    g_FilterModuleList.Flink = &FilterModuleContext->list;
  }
  Irql_2 = g_Irql;
LABEL_26:
  KeReleaseSpinLock(&g_FilterListLock, Irql_2);
}

//----- (0000000000014DC0) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  FilterDeviceExtension *DeviceExtension; // rbp
  NTSTATUS Status; // ebx
  _IO_STACK_LOCATION *CurrentStackLocation; // r15
  PIRP MasterIrp; // r12
  int InputBufferLength; // eax
  ULONG OutputBufferLength; // er14
  KIRQL NewIrql; // al
  bool IsPaused; // zf
  unsigned int IoControlCode; // er11
  unsigned int v13; // er11
  unsigned int v14; // er11
  unsigned int v15; // er11
  unsigned int v16; // er11
  NTSTATUS status_2; // eax
  Dot11Filter *v18; // r13
  unsigned int status; // eax
  int Type; // eax
  __int64 v21; // rax
  unsigned int oid; // er13
  NDIS_STATUS v23; // eax
  Dot11Filter *Dot11; // r13
  unsigned int status_1; // eax
  int Type_1; // er11
  unsigned int v27; // er11
  unsigned int v28; // er11
  unsigned int v29; // er11
  unsigned int v30; // er11
  NTSTATUS Status_1; // eax
  __int64 status_3; // [rsp+20h] [rbp-78h]
  __int64 a7; // [rsp+30h] [rbp-68h]
  unsigned int *v35; // [rsp+40h] [rbp-58h] BYREF
  unsigned int *v36; // [rsp+48h] [rbp-50h] BYREF
  int v37[18]; // [rsp+50h] [rbp-48h] BYREF
  __int64 a4; // [rsp+A0h] [rbp+8h] BYREF
  int InputBufferLength_1; // [rsp+B0h] [rbp+18h]
  __int64 Information; // [rsp+B8h] [rbp+20h] BYREF

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  Status = STATUS_INVALID_BUFFER_SIZE;
  if ( !TestFilterModuleSignature(DeviceObject) )
  {
    Irp->IoStatus.Information = 0i64;
    Status = NDIS_STATUS_INVALID_STATE;
    Irp->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
    IofCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
  }
  _InterlockedAdd(&DeviceExtension->field_210, 1u);
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  MasterIrp = Irp->AssociatedIrp.MasterIrp;
  InputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.InputBufferLength;
  OutputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.OutputBufferLength;
  Irp->IoStatus.Information = 0i64;
  InputBufferLength_1 = InputBufferLength;
  NewIrql = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->SpinLock);
  IsPaused = DeviceExtension->State == FilterPaused;
  DeviceExtension->irql = NewIrql;
  if ( !IsPaused && CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode != 0x2100AC )
  {
    KeReleaseSpinLock(&DeviceExtension->SpinLock, NewIrql);
    Status = NDIS_STATUS_INVALID_STATE;
    goto LABEL_62;
  }
  KeReleaseSpinLock(&DeviceExtension->SpinLock, NewIrql);
  IoControlCode = CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode;
  if ( IoControlCode > 0x2100A0 )
  {
    v27 = IoControlCode - 0x2100A4;
    if ( v27 )
    {
      v28 = v27 - 4;
      if ( v28 )
      {
        v29 = v28 - 4;
        if ( !v29 )
        {
          if ( OutputBufferLength == 4 && MasterIrp )
          {
            Status = 0;
            *(_DWORD *)&MasterIrp->Type = DeviceExtension->State;
            Irp->IoStatus.Information = 4i64;
          }
          goto LABEL_62;
        }
        v30 = v29 - 5;
        if ( v30 )
        {
          if ( v30 != 3 )
            goto LABEL_53;
          Status_1 = NmDeleteCaptureFilter(DeviceObject, Irp);
        }
        else
        {
          Status_1 = NmAddCaptureFilter(DeviceObject, Irp);
        }
      }
      else
      {
        Status_1 = NmUserProcCaptureStop(DeviceObject, Irp);
      }
    }
    else
    {
      Status_1 = NmUserProcCaptureStart(DeviceObject, Irp);
    }
    Status = Status_1;
    goto LABEL_62;
  }
  if ( IoControlCode != 0x2100A0 )
  {
    v13 = IoControlCode - 0x21008C;
    if ( v13 )
    {
      v14 = v13 - 4;
      if ( v14 )
      {
        v15 = v14 - 4;
        if ( v15 )
        {
          v16 = v15 - 4;
          if ( !v16 || v16 == 4 )
          {
            if ( InputBufferLength_1 == 4 && MasterIrp )
            {
              status_2 = NmDot11SetChannel(DeviceExtension, *(_DWORD *)&MasterIrp->Type);
              goto LABEL_46;
            }
            goto LABEL_62;
          }
LABEL_53:
          Status = NDIS_STATUS_NOT_SUPPORTED;
          goto LABEL_62;
        }
        if ( OutputBufferLength != 4 || !MasterIrp )
          goto LABEL_62;
        v18 = DeviceExtension->Dot11;
        if ( !v18 )
        {
LABEL_19:
          Status = 0xC0235001;
          goto LABEL_62;
        }
        LODWORD(a7) = 0;
        status = nmFilterDoInternalRequest(OID_DOT11_CURRENT_PHY_ID, DeviceExtension, 0, &a4, 4u, 0, a7, (unsigned int *)&v35);
        Status = status;
        if ( status )
          DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmDot11QueryPhyId: status %x\n", status);
        else
          pNmDot11StoreCurrentIfc(v18, a4);
        if ( Status )
          goto LABEL_62;
        Type = a4;
      }
      else
      {
        if ( OutputBufferLength != 4 || !MasterIrp )
          goto LABEL_62;
        if ( !DeviceExtension->Dot11 )
          goto LABEL_19;
        v21 = pNmDot11QueryCurrentIfc(DeviceExtension);
        if ( v21 )
        {
          oid = *(_DWORD *)(v21 + 1120);
          LODWORD(a7) = 0;
          v23 = nmFilterDoInternalRequest(oid, DeviceExtension, 0, &Information, 4u, 0, a7, (unsigned int *)&v35 + 1);
          Status = v23;
          if ( v23 )
          {
            LODWORD(status_3) = v23;
            DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmDot11QueryChannel: oid %x, status %x\n", oid, status_3);
          }
          if ( Status )
            goto LABEL_62;
        }
        else
        {
          Status = 0;
        }
        Type = Information;
      }
      *(_DWORD *)&MasterIrp->Type = Type;
    }
    else
    {
      if ( OutputBufferLength != 4 || !MasterIrp )
        goto LABEL_62;
      Dot11 = DeviceExtension->Dot11;
      if ( !Dot11 )
        goto LABEL_19;
      LODWORD(a7) = 0;
      status_1 = nmFilterDoInternalRequest(OID_DOT11_CURRENT_OPERATION_MODE, DeviceExtension, 0, (__int64 *)v37, 8u, 0, a7, (unsigned int *)&v36);
      Status = status_1;
      if ( status_1 )
      {
        DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmDot11QueryPhyId: status %x\n", status_1);
        Type_1 = a4;
      }
      else
      {
        pNmDot11StoreOpMode(Dot11, v37[1]);
        Type_1 = v37[1];
      }
      if ( Status )
        goto LABEL_62;
      *(_DWORD *)&MasterIrp->Type = Type_1;
    }
LABEL_47:
    Irp->IoStatus.Information = 4i64;
    goto LABEL_62;
  }
  if ( InputBufferLength_1 == 4 && MasterIrp )
  {
    status_2 = NmDot11SetPhyId(DeviceExtension, *(_DWORD *)&MasterIrp->Type);
LABEL_46:
    Status = status_2;
    if ( status_2 )
      goto LABEL_62;
    goto LABEL_47;
  }
LABEL_62:
  Irp->IoStatus.Status = Status;
  IofCompleteRequest(Irp, IO_NO_INCREMENT);
  if ( _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF) == 1 )
    NmDestroyFilterModule(DeviceExtension);
  return Status;
}
// 14F3E: variable 'a7' is possibly undefined
// 1500A: variable 'status_3' is possibly undefined

//----- (00000000000151B0) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  _IO_STACK_LOCATION *CurrentStackLocation; // rdi
  NTSTATUS Status; // ebx
  CCHAR PriorityBoost; // dl

  Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  Irp->IoStatus.Information = 0i64;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Irp->IoStatus.Status = NDIS_STATUS_PENDING;
  if ( !TestFilterModuleSignature(DeviceObject) )
  {
    Status = NDIS_STATUS_INVALID_STATE;
    PriorityBoost = 0;
LABEL_7:
    CurrentStackLocation->Control &= 0xFEu;
    Irp->IoStatus.Status = Status;
    IofCompleteRequest(Irp, PriorityBoost);
    return Status;
  }
  if ( LODWORD(CurrentStackLocation->FileObject->FsContext2) != 18175 )
  {
    Status = STATUS_INVALID_HANDLE;
LABEL_6:
    PriorityBoost = 2;
    goto LABEL_7;
  }
  Status = NmCloseUserProc(Irp, CurrentStackLocation);
  if ( Status != NDIS_STATUS_PENDING )
    goto LABEL_6;
  return Status;
}

//----- (0000000000015244) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoCleanup(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  NTSTATUS Status; // ebx
  _IO_STACK_LOCATION *CurrentStackLocation; // rdi
  CCHAR PriorityBoost; // dl
  PFILE_OBJECT FileObject; // rax
  FileContext *FsContext; // rbp

  Status = 0;
  Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Irp->IoStatus.Status = NDIS_STATUS_PENDING;
  Irp->IoStatus.Information = 0i64;
  if ( TestFilterModuleSignature(DeviceObject) )
  {
    FileObject = CurrentStackLocation->FileObject;
    if ( LODWORD(FileObject->FsContext2) == 18175 && (FsContext = (FileContext *)FileObject->FsContext, NmVerifyUserProcObject(FsContext) >= 0) )
    {
      NmStopUserProc(FsContext);
      NmDerefUserProc(FsContext);
    }
    else
    {
      Status = STATUS_INVALID_HANDLE;
    }
    PriorityBoost = IO_NETWORK_INCREMENT;
  }
  else
  {
    Status = NDIS_STATUS_INVALID_STATE;
    PriorityBoost = IO_NO_INCREMENT;
  }
  CurrentStackLocation->Control &= 0xFEu;
  Irp->IoStatus.Status = Status;
  IofCompleteRequest(Irp, PriorityBoost);
  return Status;
}

//----- (00000000000152F0) ----------------------------------------------------
void __fastcall NmIoReadCancelRoutine(_DEVICE_OBJECT *DeviceObject, _IRP *Irp)
{
  FilterDeviceExtension *DeviceExtension; // r12
  _IO_STACK_LOCATION *CurrentStackLocation; // rax
  FileContext *FsContext; // rbp
  KIRQL irql; // al
  _LIST_ENTRY *FsContext_1; // rcx
  CaptureBuffer *CaptureBuffer; // rdi
  KIRQL irql_1; // al

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  if ( TestFilterModuleSignature(DeviceObject) )
  {
    _InterlockedExchange64((volatile __int64 *)&Irp->CancelRoutine, 0i64);
    Irp->IoStatus.Information = 0i64;
    CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
    Irp->Cancel = 1;
    Irp->IoStatus.Status = STATUS_CANCELLED;
    FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
    irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    FsContext_1 = FsContext->list0.Flink;
    FsContext->irql = irql;
    while ( 1 )
    {
      if ( FsContext_1 == &FsContext->list0 )
      {
        KeReleaseSpinLock(&FsContext->SpinLock, irql);
        IoReleaseCancelSpinLock(Irp->CancelIrql);
        return;
      }
      CaptureBuffer = (CaptureBuffer *)&FsContext_1[-5].Blink;
      if ( (_IRP *)FsContext_1[-4].Blink == Irp )
        break;
      FsContext_1 = FsContext_1->Flink;
    }
    _InterlockedAdd(&CaptureBuffer->volatile_signed___int3258, 1u);
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    irql_1 = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    FsContext->irql = irql_1;
    if ( (CaptureBuffer->field_18 & 1) != 0 || (CaptureBuffer->field_18 & 2) == 0 )
    {
      KeReleaseSpinLock(&FsContext->SpinLock, irql_1);
    }
    else
    {
      LOBYTE(DeviceExtension->field_23C) = 1;
      CaptureBuffer->field_18 &= 0xFFFFFFFD;
      KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
      NmDerefCaptureBuffer(CaptureBuffer);
    }
    NmDerefCaptureBuffer(CaptureBuffer);
  }
  else
  {
    Irp->IoStatus.Information = 0i64;
    Irp->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
    IofCompleteRequest(Irp, IO_NO_INCREMENT);
  }
}

//----- (0000000000015428) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoRead(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  FilterDeviceExtension *DeviceExtension; // r14
  NTSTATUS Status; // edi
  NTSTATUS NtStatus; // ebx
  CCHAR PriorityBoost; // dl
  _IO_STACK_LOCATION *CurrentStackLocation; // r13
  FileContext *FsContext; // rbp
  NTSTATUS Status_1; // eax
  PMDL MdlAddress; // rbx
  PVOID MappedSystemVa; // rax
  struct_108 *temp; // rax
  struct_108 *v14; // r12
  _LIST_ENTRY *list2; // r14
  PMDL MdlAddress_1; // rax
  struct _IO_WORKITEM *WorkItem; // rax
  _LIST_ENTRY *list; // rax
  FileContext *FsContext_1; // rax

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  Status = NDIS_STATUS_PENDING;
  if ( !TestFilterModuleSignature(DeviceObject) )
  {
    NtStatus = NDIS_STATUS_INVALID_STATE;
    PriorityBoost = IO_NO_INCREMENT;
    Irp->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
LABEL_3:
    IofCompleteRequest(Irp, PriorityBoost);
    return NtStatus;
  }
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
  Status_1 = NmVerifyUserProcObject(FsContext);
  NtStatus = Status_1;
  if ( Status_1 )
  {
    Irp->IoStatus.Status = Status_1;
    PriorityBoost = IO_NETWORK_INCREMENT;
    goto LABEL_3;
  }
  Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  Irp->IoStatus.Status = NDIS_STATUS_PENDING;
  Irp->IoStatus.Information = 0i64;
  if ( LODWORD(CurrentStackLocation->FileObject->FsContext2) == 18175 )
  {
    if ( CurrentStackLocation->Parameters.Read.Length >= 0x32 )
    {
      MdlAddress = Irp->MdlAddress;
      if ( MdlAddress )
      {
        do
        {
          if ( (MdlAddress->MdlFlags & 5) != 0 )
            MappedSystemVa = MdlAddress->MappedSystemVa;
          else
            MappedSystemVa = MmMapLockedPagesSpecifyCache(MdlAddress, 0, MmCached, 0i64, 0, NormalPagePriority);
          if ( !MappedSystemVa )
            goto LABEL_23;
          MdlAddress = MdlAddress->Next;
        }
        while ( MdlAddress );
        temp = (struct_108 *)ExAllocatePoolWithTag(NonPagedPool, 0x108ui64, 'bcMN');// 有一个大结构?
        v14 = temp;
        if ( !temp )
        {
LABEL_23:
          Status = NDIS_STATUS_RESOURCES;
          goto LABEL_25;
        }
        memset(temp, 0, sizeof(struct_108));
        v14->DeviceExtension = DeviceExtension;
        v14->word0 = 264;
        v14->qword28 = 0i64;
        list2 = &v14->list_entry48;
        v14->word2 = 18175;
        v14->list_entry48.Blink = &v14->list_entry48;
        v14->list_entry48.Flink = &v14->list_entry48;
        v14->dword78 = 0;
        v14->dword5C = 192;
        v14->dword58 = 1;
        MdlAddress_1 = Irp->MdlAddress;
        v14->Irp = Irp;
        v14->MdlAddress = MdlAddress_1;
        v14->Length = CurrentStackLocation->Parameters.Read.Length;
        if ( !_InterlockedExchange(&FsContext->field_B8, 1) && !_InterlockedCompareExchange64((volatile signed __int64 *)&FsContext->WorkItem, 0i64, 0i64) )
        {
          _InterlockedAdd(&FsContext->gap18, 1u);
          WorkItem = IoAllocateWorkItem((PDEVICE_OBJECT)FsContext->FilterDeviceExtension->DeviceObject);
          if ( WorkItem )
          {
            _InterlockedCompareExchange64((volatile signed __int64 *)&FsContext->WorkItem, (signed __int64)WorkItem, 0i64);
            IoQueueWorkItem(WorkItem, (PIO_WORKITEM_ROUTINE)NmUserProcGetStats, DelayedWorkQueue, FsContext);
          }
        }
        IoAcquireCancelSpinLock(&Irp->CancelIrql);
        _InterlockedExchange64((volatile __int64 *)&Irp->CancelRoutine, (__int64)NmIoReadCancelRoutine);
        IoReleaseCancelSpinLock(Irp->CancelIrql);
        FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
        _InterlockedAdd(&FsContext->gap18, 1u);
        v14->dword18 |= 2u;
        v14->FsContext = FsContext;
        v14->SpinLock = &FsContext->SpinLock;
        list = FsContext->list0.Blink;
        list2->Flink = &FsContext->list0;
        v14->list_entry48.Blink = list;
        list->Flink = list2;
        FsContext->list0.Blink = list2;
        FsContext_1 = (FileContext *)v14->FsContext;
        if ( FsContext_1->gap68 )
          --FsContext_1->gap68;
        KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
        NmDerefUserProc(FsContext);
        return Status;
      }
    }
    Status = NDIS_STATUS_INVALID_PARAMETER;
  }
  else
  {
    Status = NDIS_STATUS_INVALID_DEVICE_REQUEST;
  }
LABEL_25:
  NmDerefUserProc(FsContext);
  CurrentStackLocation->Control &= 0xFEu;
  Irp->IoStatus.Status = Status;
  IofCompleteRequest(Irp, IO_NETWORK_INCREMENT);
  return Status;
}

//----- (00000000000156B8) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  MACRO_NDIS_MEMORY Status; // edi
  FilterDeviceExtension *v4; // r10
  CCHAR PriorityBoost; // dl
  PIRP MasterIrp; // r9
  _IO_STACK_LOCATION *CurrentStackLocation; // rsi
  unsigned __int16 i; // r8

  Status = 0;
  if ( !TestFilterModuleSignature(DeviceObject) )
  {
    Irp->IoStatus.Information = 0i64;
    PriorityBoost = IO_NO_INCREMENT;
    Status = NDIS_STATUS_INVALID_STATE;
LABEL_11:
    Irp->IoStatus.Status = Status;
    IofCompleteRequest(Irp, PriorityBoost);
    return Status;
  }
  Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  MasterIrp = Irp->AssociatedIrp.MasterIrp;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Irp->IoStatus.Status = NDIS_STATUS_PENDING;
  Irp->IoStatus.Information = 0i64;
  if ( !MasterIrp || *((_BYTE *)&MasterIrp->Size + 3) != 12 )
    goto LABEL_10;
  for ( i = 0; i < 12u; ++i )
  {
    if ( *((_BYTE *)&MasterIrp->MdlAddress + i) != aNmuserprocea[i] )
      break;
  }
  if ( i != 12 || (Status = NmOpenUserProc(v4, Irp, CurrentStackLocation), Status != NDIS_STATUS_PENDING) )
  {
LABEL_10:
    CurrentStackLocation->Control &= 0xFEu;
    PriorityBoost = IO_NETWORK_INCREMENT;
    goto LABEL_11;
  }
  return Status;
}
// 15747: variable 'v4' is possibly undefined

//----- (0000000000015780) ----------------------------------------------------
BOOL __fastcall TestFilterModuleSignature(PDEVICE_OBJECT DeviceObject)
{
  FilterDeviceExtension *DeviceExtension; // r8
  BOOL result; // eax

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  result = FALSE;
  if ( &DeviceExtension->list < (__int64 *)((char *)DeviceObject + DeviceObject->Size) && DeviceExtension->word2 == 952 && DeviceExtension->tag == 'MFMN' )
    result = TRUE;
  return result;
}

//----- (00000000000157B8) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonDevicePnPEventNotify(FilterDeviceExtension *FilterModuleContext, PNET_DEVICE_PNP_EVENT NetDevicePnPEvent)
{
  NdisFDevicePnPEventNotify(FilterModuleContext->NdisFilterHandle, NetDevicePnPEvent);
}

//----- (00000000000157CC) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonNetPnPEvent(FilterDeviceExtension *FilterModuleContext, PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification)
{
  return NdisFNetPnPEvent(FilterModuleContext->NdisFilterHandle, NetPnPEventNotification);
}

//----- (00000000000157E0) ----------------------------------------------------
__int64 __fastcall NetmonGetTimeStamp(FilterDeviceExtension *FilterModuleContext, __int64 *a2)
{
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 result; // rax
  int v7; // eax
  unsigned __int64 v8; // [rsp+30h] [rbp+8h]
  __int64 v9; // [rsp+30h] [rbp+8h]
  __int64 v10; // [rsp+38h] [rbp+10h]

  *a2 = 0i64;
  v4 = *(_QWORD *)&KeQueryPerformanceCounter(0i64) - FilterModuleContext->field_248;
  v5 = FilterModuleContext->field_250;
  v10 = (unsigned int)v4;
  v8 = 10000000i64 * HIDWORD(v4) / v5;
  result = HIDWORD(v8);
  if ( SHIDWORD(v8) <= 0 )
  {
    v7 = v8;
    LODWORD(v9) = 0;
    HIDWORD(v9) = v7;
    result = v9 + *(__int64 *)((char *)&FilterModuleContext->field_23C + 4) + 10000000 * v10 / v5;
    *a2 = result;
  }
  return result;
}

//----- (0000000000015880) ----------------------------------------------------
// 第一个参数名誉上是NDIS_HANDLE。
// 实际是：FilterDeviceExtension *
void __fastcall NetmonReceiveNetBufferLists(FilterDeviceExtension *FilterModuleContext, PNET_BUFFER_LIST NetBufferLists, NDIS_PORT_NUMBER PortNumber, ULONG NumberOfNetBufferLists, ULONG ReceiveFlags)
{
  unsigned int ReceiveFlag; // er15
  _NET_BUFFER_LIST *NetBufferList_1; // r14
  bool b; // bp
  KSPIN_LOCK *SpinLock; // rbx
  unsigned int v10; // er12
  KSPIN_LOCK *SpinLock_1; // rcx
  bool v12; // si
  _NET_BUFFER_LIST *v13; // rsi
  __int64 v14; // rbx
  Dot11Filter *v15; // rcx
  Dot11Filter *v16; // rdx
  int v17; // eax
  KSPIN_LOCK *SpinLock_2; // rcx
  _DWORD *v19; // r11
  Dot11Filter *v20; // rcx
  int v21; // er8
  char v22; // al
  int v23; // edx
  __int64 v24; // rax
  char *v25; // r13
  PNET_BUFFER a6; // rbp
  NDIS_PORT_NUMBER v27; // ebx
  __int64 ReceiveFlagsa; // [rsp+20h] [rbp-A8h]
  _DWORD a1[2]; // [rsp+40h] [rbp-88h] BYREF
  int v30; // [rsp+48h] [rbp-80h]
  unsigned int v31; // [rsp+4Ch] [rbp-7Ch]
  char v32; // [rsp+58h] [rbp-70h] BYREF
  __int16 v33; // [rsp+59h] [rbp-6Fh]
  int v34; // [rsp+5Bh] [rbp-6Dh]
  __int64 v35; // [rsp+5Fh] [rbp-69h]
  __int64 v36; // [rsp+67h] [rbp-61h]
  _BYTE v37[9]; // [rsp+6Fh] [rbp-59h]
  __int64 TimeStamp; // [rsp+D0h] [rbp+8h] BYREF
  PNET_BUFFER_LIST NetBufferList; // [rsp+D8h] [rbp+10h]
  NDIS_PORT_NUMBER PortNumbera; // [rsp+E0h] [rbp+18h]
  ULONG NumberOfNetBufferListsa; // [rsp+E8h] [rbp+20h]

  NumberOfNetBufferListsa = NumberOfNetBufferLists;
  PortNumbera = PortNumber;
  NetBufferList = NetBufferLists;
  ReceiveFlag = ReceiveFlags;
  NetBufferList_1 = NetBufferLists;
  b = (ReceiveFlags & 1) == 1;
  if ( !_bittest((const signed __int32 *)&NetBufferLists->Flags, 0xFu) )
  {
    SpinLock = &FilterModuleContext->SpinLock;
    v10 = 0;
    SpinLock_1 = &FilterModuleContext->SpinLock;
    if ( (ReceiveFlags & 1) == 1 )
      KeAcquireSpinLockAtDpcLevel(SpinLock_1);
    else
      FilterModuleContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
    v12 = FilterModuleContext->gap218 != 0;
    if ( b )
      KeReleaseSpinLockFromDpcLevel(SpinLock);
    else
      KeReleaseSpinLock(SpinLock, FilterModuleContext->irql);
    if ( v12 )
    {
      v13 = NetBufferList_1;
      NetmonGetTimeStamp(FilterModuleContext, &TimeStamp);
      v14 = TimeStamp;
      v30 = 0;
      *(_QWORD *)a1 = TimeStamp;
      while ( 1 )
      {
        v15 = FilterModuleContext->Dot11;
        v32 = 2;
        v33 = 32;
        v34 = 0;
        v35 = 0i64;
        v36 = 0i64;
        *(_QWORD *)v37 = 0i64;
        v37[8] = 0;
        if ( !v15 )
        {
          v25 = 0i64;
          goto LABEL_21;
        }
        FilterModuleContext->Dot11->Irql = KeAcquireSpinLockRaiseToDpc(&v15->SpinLock);
        v16 = FilterModuleContext->Dot11;
        v17 = v16->gapA8;
        SpinLock_2 = &v16->SpinLock;
        LOBYTE(v16) = v16->Irql;
        v34 = v17;
        KeReleaseSpinLock(SpinLock_2, (KIRQL)v16);
        v19 = v13->NetBufferListInfo[7];
        if ( !v19 )
          break;
        v20 = FilterModuleContext->Dot11;
        v21 = v19[1];
        HIDWORD(v36) = v19[5];
        v22 = *((_BYTE *)v19 + 24);
        LODWORD(v35) = v21;
        v37[0] = v22;
        v23 = 0;
        LODWORD(v36) = v19[3];
        v24 = (unsigned int)v19[2];
        if ( v20 && (unsigned int)v24 < v20->dwordA4 )
          v23 = *(_DWORD *)(*(&v20->qwordB8 + v24) + 24i64);
        HIDWORD(v35) = v23;
        if ( (v21 & 4) == 0 )
          goto LABEL_18;
        *(_QWORD *)&v37[1] = *((_QWORD *)v19 + 5);
LABEL_19:
        v25 = &v32;
        v10 = 32;
LABEL_21:
        a6 = v13->FirstNetBuffer;
        if ( a6 )
        {
          v27 = PortNumbera;
          do
          {
            v31 = v10 + a6->DataLength;
            LODWORD(ReceiveFlagsa) = v27;
            NmCopySingleNetBuffer(a1, (__int64)v25, v10, FilterModuleContext, ReceiveFlagsa, a6, ReceiveFlag);
            a6 = (PNET_BUFFER)a6->Link.Alignment;
          }
          while ( a6 );
          v14 = TimeStamp;
        }
        v13 = (_NET_BUFFER_LIST *)v13->Link.Alignment;
        v10 = 0;
        if ( !v13 )
        {
          NetBufferList_1 = NetBufferList;
          goto LABEL_27;
        }
      }
      v35 = -1i64;
      v37[0] = 0;
      v36 = 0i64;
LABEL_18:
      *(_QWORD *)&v37[1] = v14;
      goto LABEL_19;
    }
  }
LABEL_27:
  NdisFIndicateReceiveNetBufferLists(FilterModuleContext->NdisFilterHandle, NetBufferList_1, PortNumbera, NumberOfNetBufferListsa, ReceiveFlag);
}
// 15A8C: variable 'ReceiveFlagsa' is possibly undefined

//----- (0000000000015AF8) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonSendNetBufferLists(FilterDeviceExtension *FilterModuleContext, PNET_BUFFER_LIST NetBufferList, NDIS_PORT_NUMBER PortNumber, ULONG SendFlags)
{
  KSPIN_LOCK *SpinLock; // rbx
  KSPIN_LOCK *SpinLock_1; // rcx
  bool b; // bp
  bool b_1; // si
  PNET_BUFFER_LIST BufferList; // rsi
  __int64 Stamp; // rbx
  Dot11Filter *v13; // rax
  int v14; // eax
  char *v15; // r14
  unsigned int v16; // er13
  PNET_BUFFER FirstNetBuffer; // rbp
  int v18; // ebx
  __int64 a5; // [rsp+20h] [rbp-98h]
  _DWORD a1[2]; // [rsp+40h] [rbp-78h] BYREF
  int v21; // [rsp+48h] [rbp-70h]
  unsigned int v22; // [rsp+4Ch] [rbp-6Ch]
  char v23[11]; // [rsp+58h] [rbp-60h] BYREF
  __int64 v24; // [rsp+63h] [rbp-55h]
  _BYTE v25[13]; // [rsp+6Bh] [rbp-4Dh]
  __int64 TimeStamp; // [rsp+C0h] [rbp+8h] BYREF
  __int64 PortNumber_1; // [rsp+D0h] [rbp+18h]

  LODWORD(PortNumber_1) = PortNumber;
  SpinLock = &FilterModuleContext->SpinLock;
  SpinLock_1 = &FilterModuleContext->SpinLock;
  b = (SendFlags & 1) == 1;
  if ( (SendFlags & 1) == 1 )
    KeAcquireSpinLockAtDpcLevel(SpinLock_1);
  else
    FilterModuleContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
  b_1 = FilterModuleContext->gap218 != 0;
  if ( b )
    KeReleaseSpinLockFromDpcLevel(SpinLock);
  else
    KeReleaseSpinLock(SpinLock, FilterModuleContext->irql);
  if ( b_1 )
  {
    BufferList = NetBufferList;
    NetmonGetTimeStamp(FilterModuleContext, &TimeStamp);
    Stamp = TimeStamp;
    v21 = 0;
    *(_QWORD *)a1 = TimeStamp;
    if ( NetBufferList )
    {
      do
      {
        *(_DWORD *)&v23[3] = 0;
        *(_DWORD *)&v23[7] = -1;
        v24 = 0i64;
        *(_QWORD *)v25 = 0i64;
        *(_DWORD *)&v25[8] = 0;
        v25[12] = 0;
        v13 = FilterModuleContext->Dot11;
        v23[0] = 2;
        strcpy(&v23[1], " ");
        if ( v13 )
        {
          v14 = v13->gapA8;
          *(_QWORD *)&v25[5] = Stamp;
          v15 = v23;
          *(_DWORD *)&v23[3] = v14;
          v16 = 32;
        }
        else
        {
          v15 = 0i64;
          v16 = 0;
        }
        FirstNetBuffer = BufferList->FirstNetBuffer;
        if ( FirstNetBuffer )
        {
          v18 = PortNumber_1;
          do
          {
            v22 = v16 + FirstNetBuffer->DataLength;
            LODWORD(a5) = v18;
            NmCopySingleNetBuffer(a1, (__int64)v15, v16, FilterModuleContext, a5, FirstNetBuffer, SendFlags);
            FirstNetBuffer = (PNET_BUFFER)FirstNetBuffer->Link.Alignment;
          }
          while ( FirstNetBuffer );
          Stamp = TimeStamp;
        }
        BufferList = (PNET_BUFFER_LIST)BufferList->Link.Alignment;
      }
      while ( BufferList );
    }
  }
  NdisFSendNetBufferLists(FilterModuleContext->NdisFilterHandle, NetBufferList, PortNumber_1, SendFlags);
}
// 15C41: variable 'a5' is possibly undefined

//----- (0000000000015CA0) ----------------------------------------------------
void __fastcall NmCopySingleNetBuffer(_DWORD *a1, __int64 a2, __int64 a3, FilterDeviceExtension *FilterModuleContext, __int64 a5, void *a6, unsigned int a7)
{
  unsigned int v7; // er13
  KSPIN_LOCK *SpinLock_1; // rdi
  KSPIN_LOCK *SpinLock; // rcx
  __int64 v11; // r15
  __int64 *v12; // rax
  const signed __int32 *v13; // rsi
  const signed __int32 *v14; // r12
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // ecx
  unsigned int v19; // eax
  unsigned int v20; // er12
  KSPIN_LOCK *SpinLock_2; // rcx
  KSPIN_LOCK *SpinLock_4; // rcx
  KSPIN_LOCK *SpinLock_3; // rcx
  unsigned int a3a; // [rsp+90h] [rbp+18h]

  a3a = a3;
  v7 = a7;
  SpinLock_1 = &FilterModuleContext->SpinLock;
  SpinLock = &FilterModuleContext->SpinLock;
  if ( (a7 & 1) == 1 )
    KeAcquireSpinLockAtDpcLevel(SpinLock);
  else
    FilterModuleContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock);
  v11 = FilterModuleContext->char2E8;
  if ( (__int64 *)v11 != &FilterModuleContext->char2E8 )
  {
    v12 = &FilterModuleContext->char2E8;
    while ( 1 )
    {
      if ( (*(_BYTE *)(v11 + 56) & 0x40) != 0 || *(char *)(v11 + 56) >= 0 )
        goto LABEL_50;
      _InterlockedAdd((volatile signed __int32 *)(v11 + 16), 1u);
      if ( (a7 & 1) == 1 )
        KeReleaseSpinLockFromDpcLevel(SpinLock_1);
      else
        KeReleaseSpinLock(SpinLock_1, FilterModuleContext->irql);
      ++*(_QWORD *)(v11 + 240);
      v13 = (const signed __int32 *)(v11 + 104);
      if ( *(const signed __int32 **)v13 == v13 )
        goto LABEL_31;
      v14 = *(const signed __int32 **)v13;
      v15 = 0;
      while ( v14 != v13 )
      {
        v16 = NmCaptureFilterMatch((__int64)(v14 - 1), (__int64)a6);
        v15 = v16;
        if ( v16 >= 2 )
          break;
        if ( v16 == 1 )
        {
          if ( !_bittest(v14 + 5, 0x11u) )
            break;
        }
        else
        {
          if ( (v14[5] & 1) != 0 )
          {
            v15 = 2;
            break;
          }
          if ( _bittest(v14 + 5, 0x11u) )
            break;
        }
        v14 = *(const signed __int32 **)v14;
      }
      v17 = v15 - 1;
      if ( !v17 )
        break;
      v18 = v17 - 1;
      if ( !v18 || v18 == 2 )
        break;
      ++*(_QWORD *)(v11 + 280);
      if ( (a7 & 1) == 1 )
        KeAcquireSpinLockAtDpcLevel(SpinLock_1);
      else
        FilterModuleContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
      NmDerefUserProc((FileContext *)(v11 - 8));
LABEL_49:
      v12 = &FilterModuleContext->char2E8;
LABEL_50:
      v11 = *(_QWORD *)v11;
      v7 = a7;
      if ( (__int64 *)v11 == v12 )
        goto LABEL_51;
    }
    v7 = a7;
LABEL_31:
    v19 = *(_DWORD *)(v11 + 140);
    if ( a1[3] < v19 )
      v19 = a1[3];
    a1[4] = v19;
    v20 = (v19 + 55) & 0xFFFFFFE0;
    a1[5] = v20 - 24;
    SpinLock_2 = (KSPIN_LOCK *)(v11 + 24);
    if ( (a7 & 1) == 1 )
      KeAcquireSpinLockAtDpcLevel(SpinLock_2);
    else
      *(_BYTE *)(v11 + 32) = KeAcquireSpinLockRaiseToDpc(SpinLock_2);
    if ( (*(_BYTE *)(v11 + 56) & 0x40) != 0 || *(char *)(v11 + 56) >= 0 )
    {
      SpinLock_3 = (KSPIN_LOCK *)(v11 + 24);
      if ( (a7 & 1) == 1 )
        KeReleaseSpinLockFromDpcLevel(SpinLock_3);
      else
        KeReleaseSpinLock(SpinLock_3, *(_BYTE *)(v11 + 32));
    }
    else
    {
      SpinLock_4 = (KSPIN_LOCK *)(v11 + 24);
      if ( (a7 & 1) == 1 )
        KeReleaseSpinLockFromDpcLevel(SpinLock_4);
      else
        KeReleaseSpinLock(SpinLock_4, *(_BYTE *)(v11 + 32));
      if ( NmCopyNetBufferToCaptureBuffer(FilterModuleContext, v20, a6, (char *)(v11 - 8), v7, a1, (void *)a2, a3a) )
        ++*(_QWORD *)(v11 + 272);
    }
    NmDerefUserProc((FileContext *)(v11 - 8));
    if ( (a7 & 1) == 1 )
      KeAcquireSpinLockAtDpcLevel(SpinLock_1);
    else
      FilterModuleContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
    goto LABEL_49;
  }
LABEL_51:
  if ( (a7 & 1) == 1 )
    KeReleaseSpinLockFromDpcLevel(SpinLock_1);
  else
    KeReleaseSpinLock(SpinLock_1, FilterModuleContext->irql);
}

//----- (0000000000015F5C) ----------------------------------------------------
NTSTATUS __fastcall NmCopyNetBufferToCaptureBuffer(FilterDeviceExtension *FilterModuleContext, unsigned int edx0, void *a2, char *r9_0, unsigned int a3, void *a2a, void *a7, unsigned int a3a)
{
  unsigned __int64 v9; // r13
  char *v11; // r12
  bool v12; // bp
  KSPIN_LOCK *SpinLock_1; // rcx
  char *i; // rax
  CaptureBuffer *Capture; // rbx
  unsigned int v16; // er15
  KSPIN_LOCK *SpinLock_2; // rcx
  PKSPIN_LOCK SpinLock_7; // rcx
  unsigned int v19; // er12
  PKSPIN_LOCK SpinLock_3; // rcx
  KSPIN_LOCK *SpinLock_4; // rcx
  PMDL mdl; // rdi
  char *MappedSystemVa; // rcx
  ULONG ByteOffset; // edx
  ULONG ByteCount; // eax
  unsigned int v26; // er13
  unsigned int v27; // edi
  KSPIN_LOCK *SpinLock_5; // rcx
  KSPIN_LOCK *SpinLock_6; // rcx
  KSPIN_LOCK *SpinLock; // rcx
  PMDL MdlAddress[2]; // [rsp+30h] [rbp-48h] BYREF
  unsigned int v34; // [rsp+40h] [rbp-38h]
  ULONG v35; // [rsp+44h] [rbp-34h]

  v9 = edx0;
  v11 = r9_0 + 88;
  v12 = (a3 & 1) == 1;
  while ( 1 )
  {
    SpinLock_1 = (KSPIN_LOCK *)(r9_0 + 32);
    if ( v12 )
      KeAcquireSpinLockAtDpcLevel(SpinLock_1);
    else
      r9_0[40] = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
    for ( i = *(char **)v11; ; i = *(char **)i )
    {
      if ( i == v11 )
      {
        SpinLock = (KSPIN_LOCK *)(r9_0 + 32);
        if ( v12 )
          KeReleaseSpinLockFromDpcLevel(SpinLock);
        else
          KeReleaseSpinLock(SpinLock, r9_0[40]);
        return STATUS_INSUFFICIENT_RESOURCES;
      }
      Capture = (CaptureBuffer *)(i - 72);
      if ( (*(i - 48) & 1) == 0 && (Capture->field_18 & 2) != 0 )
        break;
    }
    _InterlockedAdd(&Capture->volatile_signed___int3258, 1u);
    v16 = Capture->field_60;
    if ( v16 - (unsigned __int64)(unsigned int)Capture->field_5C >= v9 )
      break;
    Capture->field_18 |= 1u;
    SpinLock_2 = (KSPIN_LOCK *)(r9_0 + 32);
    LOBYTE(FilterModuleContext->field_23C) = 1;
    if ( v12 )
      KeReleaseSpinLockFromDpcLevel(SpinLock_2);
    else
      KeReleaseSpinLock(SpinLock_2, r9_0[40]);
    NmDerefCaptureBuffer(Capture);
    NmDerefCaptureBuffer(Capture);
  }
  SpinLock_7 = &Capture->SpinLock;
  if ( v12 )
    KeAcquireSpinLockAtDpcLevel(SpinLock_7);
  else
    Capture->Irql = KeAcquireSpinLockRaiseToDpc(SpinLock_7);
  v19 = Capture->field_5C;
  SpinLock_3 = &Capture->SpinLock;
  Capture->field_5C = v19 + v9;
  if ( v12 )
    KeReleaseSpinLockFromDpcLevel(SpinLock_3);
  else
    KeReleaseSpinLock(SpinLock_3, Capture->Irql);
  SpinLock_4 = (KSPIN_LOCK *)(r9_0 + 32);
  if ( v12 )
    KeReleaseSpinLockFromDpcLevel(SpinLock_4);
  else
    KeReleaseSpinLock(SpinLock_4, r9_0[40]);
  mdl = Capture->mdl;
  MdlAddress[0] = mdl;
  if ( mdl )
  {
    if ( (mdl->MdlFlags & 5) != 0 )
      MappedSystemVa = (char *)mdl->MappedSystemVa;
    else
      MappedSystemVa = (char *)MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
    ByteOffset = mdl->ByteOffset;
    ByteCount = mdl->ByteCount;
  }
  else
  {
    MappedSystemVa = 0i64;
    ByteOffset = 0;
    ByteCount = 0;
  }
  if ( mdl )
  {
    v26 = ByteCount;
    if ( ByteCount > v19 )
    {
LABEL_37:
      v35 = ByteCount - v19;
      v34 = v19 + ByteOffset;
      MdlAddress[1] = (PMDL)&MappedSystemVa[v19];
      if ( !NmCopyBufferToMdlWrapper(MdlAddress, a2a, 0x18u, &a3) && a3 == 24 )
      {
        v27 = a3a;
        if ( !a3a || !NmCopyBufferToMdlWrapper(MdlAddress, a7, a3a, &a3) && a3 == v27 )
        {
          a3 = 0;
          if ( !(a2 ? (unsigned int)NmCopyNetBufferToMdlWrapper(MdlAddress, (__int64)a2, &a3) : 0) )
          {
            _InterlockedAdd(&Capture->field_78, 1u);
            NmDerefCaptureBuffer(Capture);
            return 0;
          }
        }
      }
    }
    else
    {
      while ( 1 )
      {
        mdl = mdl->Next;
        v19 -= v26;
        MdlAddress[0] = mdl;
        if ( !mdl )
          break;
        if ( (mdl->MdlFlags & 5) != 0 )
          MappedSystemVa = (char *)mdl->MappedSystemVa;
        else
          MappedSystemVa = (char *)MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
        ByteOffset = mdl->ByteOffset;
        ByteCount = mdl->ByteCount;
        if ( v26 > v19 )
          goto LABEL_37;
      }
    }
  }
  SpinLock_5 = &Capture->SpinLock;
  if ( v12 )
    KeAcquireSpinLockAtDpcLevel(SpinLock_5);
  else
    Capture->Irql = KeAcquireSpinLockRaiseToDpc(SpinLock_5);
  Capture->field_5C = v16;
  SpinLock_6 = &Capture->SpinLock;
  if ( v12 )
    KeReleaseSpinLockFromDpcLevel(SpinLock_6);
  else
    KeReleaseSpinLock(SpinLock_6, Capture->Irql);
  Capture->irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
  ++Capture->field_7C;
  NmDerefCaptureBuffer(Capture);
  return STATUS_INSUFFICIENT_RESOURCES;
}

//----- (000000000001628C) ----------------------------------------------------
__int64 __fastcall NmCopyNetBufferToMdlWrapper(PMDL *MdlAddress, __int64 a2, _DWORD *a3)
{
  _MDL *mdl; // rbx
  unsigned int v4; // edi
  unsigned int v5; // ebp
  PVOID MappedSystemVa; // r8
  __int64 v10; // rax
  PVOID MappedSystemVa_1; // rdx
  unsigned int i; // ecx
  unsigned int v13; // er8
  int v14; // ecx
  int a4; // [rsp+68h] [rbp+20h] BYREF

  mdl = *(_MDL **)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 24);
  v5 = 0;
  a4 = 0;
  if ( (mdl->MdlFlags & 5) != 0 )
    MappedSystemVa = mdl->MappedSystemVa;
  else
    MappedSystemVa = MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
  v10 = *(unsigned int *)(a2 + 16);
  MappedSystemVa_1 = (char *)MappedSystemVa + v10;
  for ( i = mdl->ByteCount - v10; v4; i = mdl->ByteCount )
  {
    v13 = v4;
    if ( i < v4 )
      v13 = i;
    v5 = NmCopyBufferToMdlWrapper(MdlAddress, MappedSystemVa_1, v13, &a4);
    if ( v5 )
      break;
    v14 = a4;
    mdl = mdl->Next;
    *a3 += a4;
    v4 -= v14;
    if ( !mdl )
      break;
    if ( (mdl->MdlFlags & 5) != 0 )
      MappedSystemVa_1 = mdl->MappedSystemVa;
    else
      MappedSystemVa_1 = MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
  }
  return v5;
}

//----- (0000000000016378) ----------------------------------------------------
void __fastcall NmSyncTimerSystem(FilterDeviceExtension *Context)
{
  LARGE_INTEGER v2; // rax
  LARGE_INTEGER PerformanceFrequency; // [rsp+30h] [rbp+8h] BYREF

  if ( Context )
  {
    _InterlockedExchange64((volatile __int64 *)((char *)&Context->field_23C + 4), MEMORY[0xFFFFF78000000014]);
    v2 = KeQueryPerformanceCounter(&PerformanceFrequency);
    _InterlockedExchange64(&Context->field_250, PerformanceFrequency.QuadPart);
    _InterlockedExchange64(&Context->field_248, v2.QuadPart);
    _InterlockedExchange(&Context->field_258, 0);
  }
}

//----- (00000000000163D8) ----------------------------------------------------
void __fastcall ScanLongTimersDpc(struct _KDPC *Dpc, FilterDeviceExtension *DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  __int64 *v5; // r12
  __int64 i; // rbp
  KSPIN_LOCK *SpinLock; // rcx
  __int64 v8; // rsi
  int v9; // eax
  KSPIN_LOCK *v10; // rcx
  signed __int32 v11; // eax

  KeAcquireSpinLockAtDpcLevel(&DeferredContext->SpinLock);
  v5 = &DeferredContext->char2E8;
  if ( (__int64 *)*v5 != v5 && !LOBYTE(DeferredContext->field_23C) )
  {
    for ( i = *v5; (__int64 *)i != v5; i = *(_QWORD *)i )
    {
      _InterlockedAdd((volatile signed __int32 *)(i + 16), 1u);
      SpinLock = &DeferredContext->SpinLock;
      v8 = *(_QWORD *)(i + 80);
      if ( v8 == i + 80 )
      {
        KeReleaseSpinLockFromDpcLevel(SpinLock);
      }
      else
      {
        _InterlockedAdd((volatile signed __int32 *)(v8 + 16), 1u);
        KeReleaseSpinLockFromDpcLevel(SpinLock);
        KeAcquireSpinLockAtDpcLevel(*(PKSPIN_LOCK *)(v8 - 16));
        if ( !*(_DWORD *)(v8 + 48) && *(_QWORD *)(*(_QWORD *)(v8 - 8) + 112i64) == *(_QWORD *)(v8 - 8) + 112i64
          || (v9 = *(_DWORD *)(v8 - 48), (v9 & 2) == 0)
          || (v9 & 1) != 0 )
        {
          KeReleaseSpinLockFromDpcLevel(*(PKSPIN_LOCK *)(v8 - 16));
        }
        else
        {
          v10 = *(KSPIN_LOCK **)(v8 - 16);
          *(_DWORD *)(v8 - 48) = v9 & 0xFFFFFFFD;
          KeReleaseSpinLockFromDpcLevel(v10);
          NmDerefCaptureBuffer((CaptureBuffer *)(v8 - 72));
        }
        NmDerefCaptureBuffer((CaptureBuffer *)(v8 - 72));
      }
      NmDerefUserProc((FileContext *)(i - 8));
      KeAcquireSpinLockAtDpcLevel(&DeferredContext->SpinLock);
    }
  }
  KeReleaseSpinLockFromDpcLevel(&DeferredContext->SpinLock);
  if ( DeferredContext->NdisFilterHandle )
  {
    v11 = _InterlockedIncrement(&DeferredContext->field_258);
    if ( g_TimeSyncIntervalCount == v11 )
      NmSyncTimerSystem(DeferredContext);
  }
  KeAcquireSpinLockAtDpcLevel(&DeferredContext->SpinLock);
  if ( DeferredContext->State >= FilterRestarting )
  {
    if ( _InterlockedExchangeAdd(&DeferredContext->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule(DeferredContext);
  }
  else
  {
    KeSetTimer(&DeferredContext->Timer, (LARGE_INTEGER)-DeferredContext->DueTime, &DeferredContext->Dpc);
  }
  LOBYTE(DeferredContext->field_23C) = 0;
  KeReleaseSpinLockFromDpcLevel(&DeferredContext->SpinLock);
}
// 19120: using guessed type int g_TimeSyncIntervalCount;

//----- (0000000000016580) ----------------------------------------------------
void __fastcall NmInitializeTimerSystem(FilterDeviceExtension *DeviceExtension)
{
  LARGE_INTEGER DueTime; // rdx

  if ( !DeviceExtension->InitializeTimerSystem )
  {
    KeInitializeDpc(&DeviceExtension->Dpc, (PKDEFERRED_ROUTINE)ScanLongTimersDpc, DeviceExtension);
    KeInitializeTimer(&DeviceExtension->Timer);
    DueTime.QuadPart = -DeviceExtension->DueTime;
    _InterlockedAdd(&DeviceExtension->field_210, 1u);
    KeSetTimer(&DeviceExtension->Timer, DueTime, &DeviceExtension->Dpc);
    NmSyncTimerSystem(DeviceExtension);
    DeviceExtension->InitializeTimerSystem = TRUE;
  }
}

//----- (0000000000016610) ----------------------------------------------------
BOOL __fastcall NmStopTimerSystem(FilterDeviceExtension *DeviceExtension)
{
  BOOL b; // edi

  b = TRUE;
  if ( DeviceExtension->InitializeTimerSystem )
  {
    DeviceExtension->InitializeTimerSystem = 0;
    b = KeCancelTimer(&DeviceExtension->Timer);
    if ( _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule(DeviceExtension);
  }
  return b;
}

//----- (0000000000016670) ----------------------------------------------------
void __fastcall NmDerefUserProc(FileContext *FsContext)
{
  struct _WORK_QUEUE_ITEM *WorkItem; // rcx

  if ( _InterlockedExchangeAdd(&FsContext->gap18, 0xFFFFFFFF) == 1 )
  {
    *(_QWORD *)&FsContext->ShareAccess.SharedDelete = FsContext;
    WorkItem = (struct _WORK_QUEUE_ITEM *)&FsContext->ShareAccess;
    WorkItem->List.Flink = 0i64;
    WorkItem->WorkerRoutine = (PWORKER_THREAD_ROUTINE)NmDestroyUserProc;
    ExQueueWorkItem(WorkItem, DelayedWorkQueue);
  }
}

//----- (00000000000166B4) ----------------------------------------------------
NTSTATUS __fastcall NmOpenUserProc(FilterDeviceExtension *FilterDeviceExtension, PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation)
{
  PEPROCESS CurrentProcess; // r13
  unsigned __int8 CurrentIrql; // r14
  FileContext *fc; // rax
  FileContext *pfc; // rbx
  NTSTATUS NtStatus; // ebx
  volatile FileContext *FsContext; // rdi
  BOOL DesiredShareAccess; // edx
  NTSTATUS Status; // er13
  FileContext *temp; // [rsp+78h] [rbp+10h] BYREF
  FileContext *ctx; // [rsp+88h] [rbp+20h] BYREF

  CurrentProcess = IoGetCurrentProcess();
  if ( !Irp->AssociatedIrp.MasterIrp )
    return STATUS_INVALID_ADDRESS_COMPONENT;
  CurrentIrql = KeGetCurrentIrql();
  __writecr8(1ui64);
  ExAcquireResourceExclusiveLite(&FilterDeviceExtension->eresource, 1u);
  fc = (FileContext *)ExAllocatePoolWithTag(NonPagedPool, 0x158ui64, 'u3MN');// 又是一个大结构。应该是文件上下文。
  pfc = fc;
  if ( !fc )
  {
    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    goto LABEL_16;
  }
  memset(fc, 0, sizeof(FileContext));
  pfc->WorkItem = 0i64;
  pfc->SpinLock = 0i64;
  pfc->word0 = 344;
  pfc->FilterDeviceExtension = FilterDeviceExtension;
  pfc->word2 = 18175;
  pfc->list.Blink = &pfc->list;                 // 这几个应该是链表。
  pfc->list.Flink = &pfc->list;
  pfc->list0.Blink = &pfc->list0;
  pfc->list0.Flink = &pfc->list0;
  ctx = pfc;
  pfc->list2.Blink = &pfc->list2;
  pfc->list2.Flink = &pfc->list2;
  NtStatus = NmCreateUserProc(FilterDeviceExtension, &temp, &ctx);
  if ( NtStatus < 0 )
  {
LABEL_16:
    ExReleaseResourceLite(&FilterDeviceExtension->eresource);
    goto LABEL_17;
  }
  FsContext = temp;
  temp->CurrentProcess = CurrentProcess;
  DesiredShareAccess = (CurrentStackLocation->Parameters.Create.ShareAccess & 1) != 0 || (CurrentStackLocation->Parameters.Create.ShareAccess & 2) != 0;
  IoSetShareAccess(1u, DesiredShareAccess, CurrentStackLocation->FileObject, &FsContext->ShareAccess);
  Status = SeAssignSecurity(
             0i64,
             CurrentStackLocation->Parameters.Create.SecurityContext->AccessState->SecurityDescriptor,
             &FsContext->NewDescriptor,
             0,
             &CurrentStackLocation->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext,
             &g_GenericMapping,
             PagedPool);
  if ( Status < 0 )
  {
    IoRemoveShareAccess(CurrentStackLocation->FileObject, &FsContext->ShareAccess);
    FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    FsContext->field_40 |= 0x40u;
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    ExReleaseResourceLite(&FilterDeviceExtension->eresource);
    NmDerefUserProc((FileContext *)FsContext);
    return Status;
  }
  ExReleaseResourceLite(&FilterDeviceExtension->eresource);
  if ( FilterDeviceExtension->State == FilterPaused )
  {
    CurrentStackLocation->FileObject->FsContext = (PVOID)FsContext;
    CurrentStackLocation->FileObject->FsContext2 = (PVOID)18175;
    FsContext->FileObject = CurrentStackLocation->FileObject;
    _InterlockedAdd(&FsContext->gap18, 1u);
    FsContext = temp;
    NtStatus = STATUS_SUCCESS;
  }
  else
  {
    NtStatus = STATUS_DEVICE_NOT_READY;
  }
  NmDerefUserProc((FileContext *)FsContext);
LABEL_17:
  __writecr8(CurrentIrql);
  return NtStatus;
}

//----- (00000000000168EC) ----------------------------------------------------
__int64 __fastcall NmCreateUserProc(FilterDeviceExtension *FilterDeviceExtension, FileContext **ctx1, FileContext **ctx2)
{
  FileContext *ctx; // rcx
  KIRQL irql; // al
  FileContext *v8; // r8
  _LIST_ENTRY *v9; // rax

  ctx = *ctx2;
  ctx->gap18 = 1;
  ctx->field_40 = 32;
  memset(&ctx->field_128, -1, 0x28u);
  irql = KeAcquireSpinLockRaiseToDpc(&FilterDeviceExtension->SpinLock);
  v8 = *ctx2;
  FilterDeviceExtension->irql = irql;
  v9 = (_LIST_ENTRY *)FilterDeviceExtension->field_2F0;
  v8 = (FileContext *)((char *)v8 + 8);
  v8->list.Flink = v9;
  *(_QWORD *)&v8->word0 = &FilterDeviceExtension->char2E8;
  v9->Flink = (_LIST_ENTRY *)v8;
  FilterDeviceExtension->field_2F0 = (__int64)v8;
  KeReleaseSpinLock(&FilterDeviceExtension->SpinLock, FilterDeviceExtension->irql);
  (*ctx2)->FilterDeviceExtension = FilterDeviceExtension;
  _InterlockedAdd(&FilterDeviceExtension->field_210, 1u);
  *ctx1 = *ctx2;
  return 0i64;
}

//----- (00000000000169A8) ----------------------------------------------------
NTSTATUS __fastcall NmVerifyUserProcObject(FileContext *FsContext)
{
  NTSTATUS NtStatus; // ebx

  NtStatus = STATUS_SUCCESS;
  if ( FsContext && FsContext->word0 == 344 && FsContext->word2 == 18175 )
  {
    FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    if ( (FsContext->field_40 & 0x40) != 0 )
    {
      NtStatus = STATUS_INVALID_ADDRESS;
    }
    else
    {
      _InterlockedAdd(&FsContext->gap18, 1u);
      NtStatus = STATUS_SUCCESS;
    }
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
  }
  return NtStatus;
}

//----- (0000000000016A2C) ----------------------------------------------------
// 是一个WorkerRoutine。
__int64 __fastcall NmDestroyUserProc(FileContext *Parameter)
{
  FilterDeviceExtension *DeviceExtension; // rdi
  _LIST_ENTRY *v3; // rdx
  _LIST_ENTRY *v4; // rax
  LIST_ENTRY *v5; // rsi
  _LIST_ENTRY *v6; // rcx
  LIST_ENTRY *v7; // rbx
  _LIST_ENTRY *v8; // rdx
  _LIST_ENTRY *v9; // rax
  signed __int32 v10; // eax
  bool b; // zf
  __int64 result; // rax

  DeviceExtension = Parameter->FilterDeviceExtension;
  SeDeassignSecurity(&Parameter->NewDescriptor);
  DeviceExtension->irql = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->SpinLock);
  v3 = Parameter->list.Flink;
  v4 = Parameter->list.Blink;
  v4->Flink = v3;
  v3->Blink = v4;
  KeReleaseSpinLock(&DeviceExtension->SpinLock, DeviceExtension->irql);
  v5 = &Parameter->list2;
  if ( v5->Flink != v5 )
  {
    v6 = v5->Flink;
    if ( v5->Flink != v5 )
    {
      do
      {
        v7 = v6->Flink;
        v8 = v6->Flink;
        v9 = v6->Blink;
        v9->Flink = v6->Flink;
        v8->Blink = v9;
        ExFreePoolWithTag((char *)&v6[-1].Blink + 4, 0);
        v6 = v7;
      }
      while ( v7 != v5 );
    }
  }
  ExFreePoolWithTag(Parameter, 0);
  v10 = _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF);
  b = v10 == 1;
  result = (unsigned int)(v10 - 1);
  if ( b )
    NmDestroyFilterModule(DeviceExtension);
  return result;
}

//----- (0000000000016B00) ----------------------------------------------------
void __fastcall NmStopUserProc(FileContext *FsContext)
{
  FilterDeviceExtension *FilterDeviceExtension; // r14
  KIRQL irql; // al
  bool b; // zf
  KSPIN_LOCK *SpinLock; // rcx
  char irql_1; // dl
  char irql_2; // al
  FileContext *next; // r12
  CaptureBuffer *CaptureBuffer; // rsi
  KIRQL irql_3; // al

  FilterDeviceExtension = FsContext->FilterDeviceExtension;
  irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
  b = (FsContext->field_40 & 0x40) == 0;
  SpinLock = &FsContext->SpinLock;
  FsContext->irql = irql;
  if ( b )
  {
    _InterlockedAdd(&FsContext->gap18, 1u);
    irql_1 = FsContext->irql;
    FsContext->field_40 |= 0x40u;
    KeReleaseSpinLock(SpinLock, irql_1);
    irql_2 = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    next = (FileContext *)FsContext->list0.Flink;
LABEL_8:
    FsContext->irql = irql_2;
    while ( next != (FileContext *)&FsContext->list0 )
    {
      CaptureBuffer = (CaptureBuffer *)&next[-1].field_110;
      next = *(FileContext **)&next->word0;
      if ( (CaptureBuffer->field_18 & 1) == 0 && (CaptureBuffer->field_18 & 2) != 0 )
      {
        _InterlockedAdd(&CaptureBuffer->volatile_signed___int3258, 1u);
        if ( (CaptureBuffer->field_18 & 2) != 0 )
        {
          irql_3 = KeAcquireSpinLockRaiseToDpc(&FilterDeviceExtension->SpinLock);
          LOBYTE(FilterDeviceExtension->field_23C) = 1;
          FilterDeviceExtension->irql = irql_3;
          KeReleaseSpinLock(&FilterDeviceExtension->SpinLock, irql_3);
          CaptureBuffer->field_18 &= 0xFFFFFFFD;
        }
        CaptureBuffer->irp->IoStatus.Status = STATUS_INVALID_HANDLE;
        CaptureBuffer->irp->IoStatus.Information = 0i64;
        KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
        NmDerefCaptureBuffer(CaptureBuffer);
        NmDerefCaptureBuffer(CaptureBuffer);
        irql_2 = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
        goto LABEL_8;
      }
    }
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    NmDerefUserProc(FsContext);
  }
  else
  {
    KeReleaseSpinLock(SpinLock, irql);
  }
}

//----- (0000000000016C44) ----------------------------------------------------
NTSTATUS __fastcall NmUserProcCaptureStart(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  FilterDeviceExtension *DeviceExtension; // rbx
  NTSTATUS NtStatus; // esi
  NTSTATUS result; // eax
  _IO_STACK_LOCATION *CurrentStackLocation; // rax
  PIRP MasterIrp; // r13
  FileContext *FsContext; // rbp
  NTSTATUS Status; // eax
  NTSTATUS status; // er12
  char irql; // al
  int v12; // edx
  unsigned int IrpCount; // ecx

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  NtStatus = 0;
  if ( TestFilterModuleSignature(DeviceObject) )
  {
    _InterlockedAdd(&DeviceExtension->field_210, 1u);
    CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
    Irp->IoStatus.Information = 0i64;
    if ( CurrentStackLocation->Parameters.DeviceIoControl.InputBufferLength >= 0x20 )
    {
      MasterIrp = Irp->AssociatedIrp.MasterIrp;
      if ( MasterIrp->Type == 0x20 )
      {
        FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
        Status = NmVerifyUserProcObject(FsContext);
        status = Status;
        if ( Status )
        {
          Irp->IoStatus.Status = Status;
          IofCompleteRequest(Irp, IO_NETWORK_INCREMENT);
          NtStatus = status;
        }
        else
        {
          irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
          v12 = FsContext->field_40;
          FsContext->irql = irql;
          if ( (v12 & 0x40) != 0 || (v12 & 0x80u) != 0 )
          {
            NtStatus = STATUS_DEVICE_BUSY;
          }
          else
          {
            FsContext->MdlAddress = MasterIrp->MdlAddress;
            FsContext->IrpCount = *(&MasterIrp->Flags + 1);
            IrpCount = MasterIrp->AssociatedIrp.IrpCount;
            if ( IrpCount < LODWORD(DeviceExtension->field_234) )
              IrpCount = DeviceExtension->field_234;
            FsContext->field_40 = v12 | 0x80;
            *(&FsContext->IrpCount + 1) = IrpCount;
            if ( DeviceExtension->gap224 )
              FsContext->IrpCount &= 0xFFFFFFF7;
            if ( (FsContext->IrpCount & 8) == 0 )
              _InterlockedAdd(&DeviceExtension->dword220, 1u);
          }
          KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
          NmDerefUserProc(FsContext);
        }
        if ( !NtStatus )
        {
          NmInitializeTimerSystem(DeviceExtension);
          _InterlockedAdd(&DeviceExtension->gap218, 1u);
          NmSetAppropriatePacketFilter(DeviceExtension, 1);
        }
      }
      else
      {
        NtStatus = NDIS_STATUS_INVALID_PARAMETER;
      }
    }
    else
    {
      NtStatus = NDIS_STATUS_BUFFER_OVERFLOW;
    }
    if ( _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule(DeviceExtension);
    result = NtStatus;
  }
  else
  {
    Irp->IoStatus.Information = 0i64;
    Irp->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
    IofCompleteRequest(Irp, IO_NO_INCREMENT);
    result = NDIS_STATUS_INVALID_STATE;
  }
  return result;
}

//----- (0000000000016DE0) ----------------------------------------------------
void __fastcall NmUploadCaptureBuffer(volatile FilterDeviceExtension *DeviceExtension, FileContext *FsContext)
{
  KIRQL CurrentIrql; // al
  KSPIN_LOCK *SpinLock_1; // rbx
  BOOL is_dpc; // esi
  KSPIN_LOCK *SpinLock; // rcx
  BOOL b; // er15
  KSPIN_LOCK *SpinLock_2; // rcx
  LIST_ENTRY *v10; // rax
  LIST_ENTRY *v11; // r13 带链表的数据结构。
  CaptureBuffer *Capture; // r14
  int v13; // ecx
  KSPIN_LOCK *SpinLock_3; // rcx
  KSPIN_LOCK *SpinLock_4; // rcx
  KSPIN_LOCK *SpinLock_5; // rcx

  CurrentIrql = KeGetCurrentIrql();
  SpinLock_1 = &DeviceExtension->SpinLock;
  is_dpc = CurrentIrql == DISPATCH_LEVEL;
  SpinLock = &DeviceExtension->SpinLock;
  if ( CurrentIrql == DISPATCH_LEVEL )
    KeAcquireSpinLockAtDpcLevel(SpinLock);
  else
    DeviceExtension->irql = KeAcquireSpinLockRaiseToDpc(SpinLock);
  b = NmStopTimerSystem((FilterDeviceExtension *)DeviceExtension);
  if ( is_dpc )
    KeReleaseSpinLockFromDpcLevel(SpinLock_1);
  else
    KeReleaseSpinLock(SpinLock_1, DeviceExtension->irql);
  if ( b )
  {
    SpinLock_2 = &FsContext->SpinLock;
    if ( is_dpc )
      KeAcquireSpinLockAtDpcLevel(SpinLock_2);
    else
      FsContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_2);
    v10 = &FsContext->list0;
    v11 = FsContext->list0.Flink;
    while ( v11 != v10 && b )
    {
      Capture = (CaptureBuffer *)&v11[-5].Blink;
      v13 = (int)v11[-3].Flink;
      if ( (v13 & 1) != 0 || (v13 & 2) == 0 )
      {
        v11 = v11->Flink;
      }
      else
      {
        if ( !Capture->field_78 )
        {
          if ( Capture->FsContext->list2.Flink == &Capture->FsContext->list2 )
            break;
          b = 0;
        }
        Capture->field_18 = v13 & 0xFFFFFFFD | 1;
        v11 = v11->Flink;
        SpinLock_3 = &FsContext->SpinLock;
        if ( is_dpc )
          KeReleaseSpinLockFromDpcLevel(SpinLock_3);
        else
          KeReleaseSpinLock(SpinLock_3, FsContext->irql);
        NmDerefCaptureBuffer(Capture);
        SpinLock_4 = &FsContext->SpinLock;
        if ( is_dpc )
          KeAcquireSpinLockAtDpcLevel(SpinLock_4);
        else
          FsContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_4);
        v10 = &FsContext->list0;
      }
    }
    memmove(&FsContext->field_C8, &FsContext->field_F8, 0x30u);
    SpinLock_5 = &FsContext->SpinLock;
    if ( is_dpc )
      KeReleaseSpinLockFromDpcLevel(SpinLock_5);
    else
      KeReleaseSpinLock(SpinLock_5, FsContext->irql);
    if ( is_dpc )
      KeAcquireSpinLockAtDpcLevel(SpinLock_1);
    else
      DeviceExtension->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
    if ( DeviceExtension->gap218 )
      NmInitializeTimerSystem((FilterDeviceExtension *)DeviceExtension);
    if ( is_dpc )
      KeReleaseSpinLockFromDpcLevel(SpinLock_1);
    else
      KeReleaseSpinLock(SpinLock_1, DeviceExtension->irql);
  }
}

//----- (0000000000016FC4) ----------------------------------------------------
NTSTATUS __fastcall NmUserProcCaptureStop(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  volatile FilterDeviceExtension *DeviceExtension; // rbx
  NTSTATUS NtStatus; // esi
  NTSTATUS result; // eax
  FileContext *FsContext; // rbp
  NTSTATUS Status; // eax
  NTSTATUS status; // er12
  int v9; // eax

  DeviceExtension = (volatile FilterDeviceExtension *)DeviceObject->DeviceExtension;
  NtStatus = 0;
  if ( TestFilterModuleSignature(DeviceObject) )
  {
    _InterlockedAdd(&DeviceExtension->field_210, 1u);
    Irp->IoStatus.Information = 0i64;
    FsContext = (FileContext *)Irp->Tail.Overlay.CurrentStackLocation->FileObject->FsContext;
    Status = NmVerifyUserProcObject(FsContext);
    status = Status;
    if ( Status )
    {
      Irp->IoStatus.Status = Status;
      IofCompleteRequest(Irp, IO_NETWORK_INCREMENT);
      NtStatus = status;
    }
    else
    {
      FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
      v9 = FsContext->field_40;
      if ( (v9 & 0x40) != 0 || (v9 & 0x80u) == 0 )
      {
        NtStatus = STATUS_DEVICE_BUSY;
      }
      else
      {
        FsContext->field_40 = v9 & 0xFFFFFF7F;
        if ( (~((unsigned int)FsContext->IrpCount >> 3) & 1) != 0 )
          _InterlockedAdd(&DeviceExtension->dword220, 0xFFFFFFFF);
      }
      KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    }
    if ( !NtStatus )
    {
      _InterlockedAdd(&DeviceExtension->gap218, 0xFFFFFFFF);
      NmSetAppropriatePacketFilter((FilterDeviceExtension *)DeviceExtension, -1);
      NmUploadCaptureBuffer(DeviceExtension, FsContext);
    }
    NmDerefUserProc(FsContext);
    if ( _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule((FilterDeviceExtension *)DeviceExtension);
    result = NtStatus;
  }
  else
  {
    Irp->IoStatus.Information = 0i64;
    Irp->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
    IofCompleteRequest(Irp, IO_NO_INCREMENT);
    result = NDIS_STATUS_INVALID_STATE;
  }
  return result;
}

//----- (00000000000170EC) ----------------------------------------------------
NTSTATUS __fastcall NmCloseUserProc(PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation)
{
  FileContext *FsContext; // rbp
  FilterDeviceExtension *FilterDeviceExtension; // rsi
  KIRQL irql; // al
  unsigned int v5; // ebx

  FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
  FilterDeviceExtension = FsContext->FilterDeviceExtension;
  KeEnterCriticalRegion();
  ExAcquireResourceExclusiveLite(&FsContext->FilterDeviceExtension->eresource, 1u);
  IoRemoveShareAccess(FsContext->FileObject, &FsContext->ShareAccess);
  ExReleaseResourceLite(&FsContext->FilterDeviceExtension->eresource);
  KeLeaveCriticalRegion();
  irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
  v5 = (unsigned int)FsContext->field_40 >> 7;
  FsContext->irql = irql;
  KeReleaseSpinLock(&FsContext->SpinLock, irql);
  if ( (v5 & 1) != 0 )
    _InterlockedAdd(&FilterDeviceExtension->gap218, 0xFFFFFFFF);
  NmDerefUserProc(FsContext);
  return STATUS_SUCCESS;
}

//----- (00000000000171A0) ----------------------------------------------------
void __fastcall NmUserProcGetStats(PDEVICE_OBJECT DeviceObject, FileContext *Context)
{
  FilterDeviceExtension *DeviceExtension; // rdi
  char irql; // al
  struct _IO_WORKITEM *WorkItem; // rcx
  __int64 a3; // [rsp+38h] [rbp+10h] BYREF
  __int64 v7; // [rsp+40h] [rbp+18h] BYREF

  DeviceExtension = Context->FilterDeviceExtension;
  if ( !NmGetGlobalStat(DeviceExtension, 0x20102, &a3, 4u) )
    Context->field_12C = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x20207, &v7, 8u) )
    Context->field_138 = v7;
  if ( !NmGetGlobalStat(DeviceExtension, 0x20104, &a3, 4u) )
    Context->field_14C = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x2020D, &a3, 4u) )
    Context->field_130 = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x20105, &a3, 4u) )
    Context->field_140 = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x2020A, &a3, 4u) )
    Context->field_144 = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x2020C, &a3, 4u) )
    Context->field_148 = a3;
  irql = KeAcquireSpinLockRaiseToDpc(&Context->SpinLock);
  WorkItem = Context->WorkItem;
  Context->field_B8 = 0;
  Context->irql = irql;
  if ( WorkItem )
  {
    IoFreeWorkItem(WorkItem);
    Context->WorkItem = NULL;
  }
  KeReleaseSpinLock(&Context->SpinLock, Context->irql);
  NmDerefUserProc(Context);
}

//----- (000000000001B008) ----------------------------------------------------
void __fastcall NmInitializeMinipInfo(NDIS_MEDIUM MiniportMediaType, FilterDeviceExtension *FilterModuleContext)
{
  bool v4; // zf
  unsigned int status; // eax
  int NmDebug; // ecx
  unsigned int status_1; // ebp
  __int64 v8; // [rsp+20h] [rbp-48h]
  __int64 a3[2]; // [rsp+30h] [rbp-38h] BYREF
  __int64 v10; // [rsp+40h] [rbp-28h] BYREF
  __int64 v11; // [rsp+78h] [rbp+10h] BYREF

  switch ( MiniportMediaType )
  {
    case NdisMedium802_3:
      if ( nmOid_Query(OID_802_3_PERMANENT_ADDRESS, FilterModuleContext, &FilterModuleContext->field_368, 0x20u) )
        _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
      if ( !nmOid_Query(OID_802_3_CURRENT_ADDRESS, FilterModuleContext, &FilterModuleContext->field_388, 0x20u) )
        goto LABEL_38;
      goto LABEL_37;
    case NdisMedium802_5:
      *(_DWORD *)&FilterModuleContext->gap225[3] = 2;
      LODWORD(FilterModuleContext->field_22C) = 8;
      LODWORD(FilterModuleContext->field_234) = 32;
      break;
    case NdisMediumFddi:
      *(_DWORD *)&FilterModuleContext->gap225[3] = 1;
      LODWORD(FilterModuleContext->field_22C) = 7;
      LODWORD(FilterModuleContext->field_234) = 13;
      break;
    default:
      switch ( MiniportMediaType )
      {
        case NdisMediumWan:
          if ( nmOid_Query(OID_WAN_PERMANENT_ADDRESS, FilterModuleContext, &FilterModuleContext->field_368, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          if ( nmOid_Query(OID_WAN_CURRENT_ADDRESS, FilterModuleContext, &FilterModuleContext->field_388, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          LODWORD(FilterModuleContext->field_234) = 14;
          FilterModuleContext->gap224 = 1;
          FilterModuleContext->field_22C = 0x600000006i64;
          goto LABEL_40;
        case NdisMediumWirelessWan:
          if ( nmOid_Query(OID_802_3_PERMANENT_ADDRESS, FilterModuleContext, &FilterModuleContext->field_368, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          if ( nmOid_Query(OID_802_3_CURRENT_ADDRESS, FilterModuleContext, &FilterModuleContext->field_388, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          break;
        case NdisMediumTunnel:
          break;
        case NdisMediumNative802_11:
          v4 = HIDWORD(FilterModuleContext->field_188) == 9;
          a3[0] = 0i64;
          a3[1] = 0i64;
          v10 = 0i64;
          if ( v4 )
          {
            if ( !FilterModuleContext->Dot11 )
              goto LABEL_42;
            if ( !nmOid_Query(OID_DOT11_OPERATION_MODE_CAPABILITY, FilterModuleContext, a3, 0x18u) )
            {
              FilterModuleContext->Dot11->dword94 = HIDWORD(v10);
              if ( _bittest((const signed __int32 *)&v10 + 1, 0x1Fu) )
                FilterModuleContext->Dot11->field_90 = 1;
            }
            if ( !nmOid_Query(OID_DOT11_CURRENT_OPERATION_MODE, FilterModuleContext, &v11, 8u) )
              pNmDot11StoreOpMode(FilterModuleContext->Dot11, SHIDWORD(v11));
            nmOid_Query(OID_GEN_CURRENT_PACKET_FILTER, FilterModuleContext, &FilterModuleContext->filter, 4u);
          }
          if ( nmOid_Query(OID_802_3_PERMANENT_ADDRESS, FilterModuleContext, &FilterModuleContext->field_368, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          if ( !nmOid_Query(OID_802_3_CURRENT_ADDRESS, FilterModuleContext, &FilterModuleContext->field_388, 0x20u) )
          {
LABEL_38:
            LODWORD(FilterModuleContext->field_234) = 14;
            FilterModuleContext->field_22C = 0x600000006i64;
            goto LABEL_39;
          }
LABEL_37:
          _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          goto LABEL_38;
        case NdisMediumIP:
          break;
        default:
          goto LABEL_42;
      }
      FilterModuleContext->field_22C = 0i64;
      LODWORD(FilterModuleContext->field_234) = 0;
LABEL_39:
      FilterModuleContext->gap224 = 0;
LABEL_40:
      *(_DWORD *)&FilterModuleContext->gap225[3] = 0;
      goto LABEL_41;
  }
  FilterModuleContext->gap224 = 0;
  HIDWORD(FilterModuleContext->field_22C) = 6;
LABEL_41:
  BYTE4(FilterModuleContext->field_234) = 0;
  BYTE5(FilterModuleContext->field_234) = 0;
LABEL_42:
  if ( HIDWORD(FilterModuleContext->field_188) == 9 )
  {
    if ( MiniportMediaType == NdisMediumNative802_11 )
      BYTE4(FilterModuleContext->field_234) = 1;
  }
  else if ( FilterModuleContext->gap224 != 1 )
  {
    status = NmQueryPacketFilter(FilterModuleContext, (__int64)&FilterModuleContext->filter);
    NmDebug = g_NmDebug;
    status_1 = status;
    if ( g_NmDebug )
    {
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmQueryPacketFilter: status %x, filter %d\n", status, LODWORD(FilterModuleContext->filter));
      NmDebug = g_NmDebug;
    }
    if ( LODWORD(FilterModuleContext->filter) < 0x10 )
    {
      LODWORD(FilterModuleContext->filter) = 11;
      if ( NmDebug )
      {
        LODWORD(v8) = 11;
        DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmQueryPacketFilter: status %x, resetting to %x\n", status_1, v8);
      }
    }
    if ( !NmSetPacketFilter(FilterModuleContext, 32) )
      BYTE4(FilterModuleContext->field_234) = 1;
    NmSetPacketFilter(FilterModuleContext, FilterModuleContext->filter);
  }
}
// 1B3B8: variable 'v8' is possibly undefined
// 1919C: using guessed type int g_NmDebug;
// 191A8: using guessed type int g_InternalRequestFailedCount;

//----- (000000000001C008) ----------------------------------------------------
NTSTATUS __fastcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  NTSTATUS NtStatus; // edi
  RootDeviceExtension *DeviceReservedExtension; // rax
  RootDeviceExtension *DeviceExtension; // rbx
  struct _NDIS_DEVICE_OBJECT_ATTRIBUTES DeviceObjectAttributes; // [rsp+20h] [rbp-148h] BYREF
  UNICODE_STRING SymbolicName; // [rsp+58h] [rbp-110h] BYREF
  UNICODE_STRING DeviceName; // [rsp+68h] [rbp-100h] BYREF
  PDRIVER_DISPATCH MajorFunctions[28]; // [rsp+80h] [rbp-E8h] BYREF 数组元素的个数至少是IRP_MJ_MAXIMUM_FUNCTION。下面的memset，得出是28.
  PDEVICE_OBJECT pDeviceObject; // [rsp+180h] [rbp+18h] BYREF

  NmInitializeGlobals(DriverObject, RegistryPath);
  NtStatus = NmRegisterFilter(DriverObject);
  if ( NtStatus )
  {
failure:
    if ( g_GroupAce )
    {
      ExFreePoolWithTag(g_GroupAce, 0);
      g_GroupAce = NULL;
    }
    return NtStatus;
  }
  memset(MajorFunctions, 0, sizeof(MajorFunctions));
  MajorFunctions[IRP_MJ_CLEANUP] = (PDRIVER_DISPATCH)NmFilterRootDeviceIoCreate;
  MajorFunctions[IRP_MJ_CLOSE] = (PDRIVER_DISPATCH)NmFilterRootDeviceIoClose;
  MajorFunctions[IRP_MJ_DEVICE_CONTROL] = (PDRIVER_DISPATCH)NmFilterRootDeviceIoControl;
  MajorFunctions[0] = (PDRIVER_DISPATCH)NmFilterRootDeviceIoCreate;
  RtlInitUnicodeString(&DeviceName, L"\\Device\\nm3");
  RtlInitUnicodeString(&SymbolicName, L"\\DosDevices\\nm3");
  memset(&DeviceObjectAttributes, 0, sizeof(DeviceObjectAttributes));
  DeviceObjectAttributes.DeviceName = &DeviceName;
  DeviceObjectAttributes.SymbolicName = &SymbolicName;
  DeviceObjectAttributes.Header.Type = NDIS_OBJECT_TYPE_DEVICE_OBJECT_ATTRIBUTES;
  DeviceObjectAttributes.MajorFunctions = MajorFunctions;
  DeviceObjectAttributes.Header.Revision = NDIS_DEVICE_OBJECT_ATTRIBUTES_REVISION_1;
  DeviceObjectAttributes.Header.Size = 56;
  DeviceObjectAttributes.ExtensionSize = 72;
  NtStatus = NdisRegisterDeviceEx(g_FilterDriverHandle, &DeviceObjectAttributes, &pDeviceObject, &g_FilterDeviceHandle);
  if ( !NtStatus )
  {
    DeviceReservedExtension = (RootDeviceExtension *)NdisGetDeviceReservedExtension(pDeviceObject);
    DeviceReservedExtension->Type = NDIS_OBJECT_TYPE_NSI_INTERFACE_PERSIST_RW_STRUCT;
    DeviceReservedExtension->Revision = NDIS_DEVICE_OBJECT_ATTRIBUTES_REVISION_1;
    DeviceReservedExtension->ExtensionSize = 72;
    DeviceReservedExtension->tag = 'DFMN';
    DeviceReservedExtension->init = TRUE;
    DeviceReservedExtension->DeviceObject = pDeviceObject;
    DeviceExtension = DeviceReservedExtension;
    DeviceReservedExtension->FilterDeviceHandle = g_FilterDeviceHandle;
    RtlInitUnicodeString(&DeviceReservedExtension->DeviceName, L"\\Device\\nm3");
    RtlInitUnicodeString(&DeviceExtension->SymbolicName, L"\\DosDevices\\nm3");
  }
  NmAddGroupAccessAce(pDeviceObject);
  if ( NtStatus )
  {
    NdisFDeregisterFilterDriver(g_FilterDriverHandle);
    goto failure;
  }
  return NtStatus;
}

// nfuncs=91 queued=81 decompiled=81 lumina nreq=0 worse=0 better=0
// ALL OK, 81 function(s) have been successfully decompiled

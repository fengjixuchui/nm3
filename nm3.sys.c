/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

NDIS_STATUS __fastcall NetmonSetOptions(NDIS_HANDLE NdisDriverHandle, NDIS_HANDLE DriverContext);
NDIS_STATUS __fastcall NetmonFilterPause(FilterDeviceExtension *FilterModuleContext, PNDIS_FILTER_PAUSE_PARAMETERS PauseParameters);
NDIS_STATUS __fastcall NetmonFilterRestart(NDIS_HANDLE FilterModuleContext, PNDIS_FILTER_RESTART_PARAMETERS RestartParameters);
NDIS_STATUS __fastcall NetmonOidRequest(FilterDeviceExtension *FilterModuleContext, PNDIS_OID_REQUEST OidRequest);
void __fastcall NetmonOidRequestComplete(FilterDeviceExtension *FilterModuleContext, PNDIS_OID_REQUEST OidRequest, NDIS_STATUS Status);
void __fastcall NetmonFilterStatus(FilterDeviceExtension *FilterModuleContext, PNDIS_STATUS_INDICATION StatusIndication);
NDIS_STATUS __fastcall NetmonFilterSetModuleOptions(NDIS_HANDLE FilterModuleContext);
NDIS_STATUS __fastcall nmFilterDoInternalRequest(int a1, FilterDeviceExtension *DeviceExtension, int RequestType_1, __int64 *Information, unsigned int InformationBufferLength, int a6, __int64 a7, unsigned int **a8);
NDIS_STATUS __fastcall NmRegisterFilter(PDRIVER_OBJECT DriverObject);
NDIS_STATUS __fastcall nmOid_Query(int a1, FilterDeviceExtension *a2, __int64 *a3, unsigned int a4);
NDIS_STATUS __fastcall NmGetGlobalStat(FilterDeviceExtension *FilterDeviceExtension, int n, __int64 *a3, unsigned int a4);
void __fastcall NmDerefCaptureBuffer(PVOID P);
void __fastcall NmDestroyCaptureBuffer(PVOID P);
__int64 __fastcall NmCaptureFilterMatch(__int64 a1, __int64 a2);
__int64 __fastcall NmGetFilterSize(_IRP *a1, _DWORD *a2, _DWORD *a3, _IRP *a4);
__int64 __fastcall NmUnserializeCaptureFilter(FileContext *FsContext, _IRP *MasterIrp, unsigned int a3, _IRP **Irp_1);
NTSTATUS __fastcall NmAddCaptureFilter(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmDeleteCaptureFilter(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterRootDeviceIoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterRootDeviceIoClose(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterRootDeviceIoCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp);
RootDeviceExtension *__fastcall GetFilterRootDevice(PDEVICE_OBJECT DeviceObject);
RootDeviceExtension *__fastcall TestFilterRootDeviceSignature(PDEVICE_OBJECT DeviceObject);
NTSTATUS __fastcall NmAddGroupAccessAce(PDEVICE_OBJECT pDeviceObject);
GroupAce *__fastcall GetAceFromAcl(PACL Dacl, unsigned int a2);
char __fastcall AddAceToAcl(ACL *acl, GroupAce *GroupAce);
void __fastcall pNmDot11StoreCurrentIfc(__int64 a1, int a2);
void __fastcall pNmDot11StoreOpMode(__int64 a1, int a2);
__int64 __fastcall pNmDot11QueryMonitorMode(__int64 a1);
__int64 __fastcall pNmDot11QueryCurrentIfc(FilterDeviceExtension *DeviceExtension);
void __fastcall NmDeleteDot11Parameters(PVOID VirtualAddress);
__int64 __fastcall NmCreateDot11Filter(NDIS_HANDLE NdisHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameter, _QWORD *a3);
__int64 __fastcall NmDot11SetPhyId(FilterDeviceExtension *DeviceExtension, unsigned int a2);
__int64 __fastcall NmDot11SetChannel(FilterDeviceExtension *DeviceExtension, unsigned int channel_1);
void __fastcall NetmonUnload(struct _DRIVER_OBJECT *DriverObject);
NDIS_STATUS __fastcall NmSetPacketFilter(FilterDeviceExtension *ModuleContext, int filter);
__int64 __fastcall NmQueryPacketFilter(FilterDeviceExtension *ModuleContext, __int64 filter);
_BOOL8 __fastcall NmSetAppropriatePacketFilter(FilterDeviceExtension *DeviceExtension, int a2); // idb
__int64 __fastcall CopyUnicodeStringToBuffer(void *a1, unsigned __int64 a2, _DWORD *a3, const void **a4);
NTSTATUS __fastcall NmEnumNetworks(PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation, size_t *Information);
__int64 __fastcall NmCopyBufferToMdlWrapper(PMDL *MdlAddress, const void *a2, unsigned int a3, _DWORD *a4);
__int64 __fastcall NmInitializeGlobals(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
__int64 __fastcall LookupFilterModule(NDIS_HANDLE NdisFilterHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters, FilterDeviceExtension **DeferredContext);
NDIS_STATUS __fastcall NetmonFilterAttach(NDIS_HANDLE NdisFilterHandle, NDIS_HANDLE FilterDriverContext, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters);
void __fastcall NetmonFilterDetach(FilterDeviceExtension *FilterModuleContext);
NTSTATUS __fastcall NmCreateFilterModule(NDIS_HANDLE NdisFilterHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters, FilterDeviceExtension **DeferredContext);
void __fastcall NmDestroyFilterModule(FilterDeviceExtension *DeviceExtension);
NTSTATUS __fastcall NmBuildDeviceName(NDIS_HANDLE NdisFilterHandle, PNDIS_STRING FilterModuleGuidName, const WCHAR *str, UNICODE_STRING *__struct_ptr Name);
void __fastcall StackModuleInstance(FilterDeviceExtension *FilterModuleContext, int b);
NTSTATUS __fastcall NmFilterModuleIoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterModuleIoClose(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterModuleIoCleanup(PDEVICE_OBJECT DeviceObject, PIRP Irp);
void __fastcall NmIoReadCancelRoutine(_DEVICE_OBJECT *DeviceObject, _IRP *Irp); // idb
NTSTATUS __fastcall NmFilterModuleIoRead(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmFilterModuleIoCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp);
BOOL __fastcall TestFilterModuleSignature(PDEVICE_OBJECT DeviceObject);
void __fastcall NetmonDevicePnPEventNotify(FilterDeviceExtension *FilterModuleContext, PNET_DEVICE_PNP_EVENT NetDevicePnPEvent);
NDIS_STATUS __fastcall NetmonNetPnPEvent(FilterDeviceExtension *FilterModuleContext, PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification);
__int64 __fastcall NetmonGetTimeStamp(FilterDeviceExtension *FilterModuleContext, __int64 *a2);
void __fastcall NetmonReceiveNetBufferLists(FilterDeviceExtension *FilterModuleContext, PNET_BUFFER_LIST NetBufferLists, NDIS_PORT_NUMBER PortNumber, ULONG NumberOfNetBufferLists, ULONG ReceiveFlags);
void __fastcall NetmonSendNetBufferLists(FilterDeviceExtension *FilterModuleContext, PNET_BUFFER_LIST NetBufferList, NDIS_PORT_NUMBER PortNumber, ULONG SendFlags);
void __fastcall NmCopySingleNetBuffer(_DWORD *a1, __int64 a2, __int64 a3, FilterDeviceExtension *FilterModuleContext, __int64 a5, void *a6, unsigned int a7);
__int64 __fastcall NmCopyNetBufferToCaptureBuffer(__int64 a4, unsigned int edx0, void *a2, char *r9_0, unsigned int a3, void *a2a, void *a7, unsigned int a3a);
__int64 __fastcall NmCopyNetBufferToMdlWrapper(PMDL *MdlAddress, __int64 a2, _DWORD *a3);
void __fastcall NmSyncTimerSystem(FilterDeviceExtension *Context);
void __fastcall ScanLongTimersDpc(struct _KDPC *Dpc, FilterDeviceExtension *DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2); // idb
void __fastcall NmInitializeTimerSystem(FilterDeviceExtension *DeviceExtension);
BOOL __fastcall NmStopTimerSystem(FilterDeviceExtension *DeviceExtension);
void __fastcall NmDerefUserProc(FileContext *FsContext);
NTSTATUS __fastcall NmOpenUserProc(FilterDeviceExtension *FilterDeviceExtension, PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation);
__int64 __fastcall NmCreateUserProc(FilterDeviceExtension *FilterDeviceExtension, FileContext **ctx1, FileContext **ctx2);
__int64 __fastcall NmVerifyUserProcObject(FileContext *FsContext);
__int64 __fastcall NmDestroyUserProc(FileContext *Parameter);
void __fastcall NmStopUserProc(FileContext *FsContext);
NTSTATUS __fastcall NmUserProcCaptureStart(PDEVICE_OBJECT DeviceObject, PIRP Irp);
void __fastcall NmUploadCaptureBuffer(volatile FilterDeviceExtension *DeviceExtension, FileContext *FsContext);
NTSTATUS __fastcall NmUserProcCaptureStop(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall NmCloseUserProc(PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation);
void __fastcall NmUserProcGetStats(PDEVICE_OBJECT DeviceObject, FileContext *Context); // idb
// void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// LARGE_INTEGER __stdcall KeQueryPerformanceCounter(PLARGE_INTEGER PerformanceFrequency);
// NDIS_STATUS NdisFNetPnPEvent(NDIS_HANDLE NdisFilterHandle, PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification);
// void NdisFDevicePnPEventNotify(NDIS_HANDLE NdisFilterHandle, PNET_DEVICE_PNP_EVENT NetDevicePnPEvent);
// NDIS_STATUS NdisFRestartFilter(NDIS_HANDLE NdisFilterHandle);
// NDIS_STATUS NdisFSetAttributes(NDIS_HANDLE NdisFilterHandle, NDIS_HANDLE FilterModuleContext, PNDIS_FILTER_ATTRIBUTES FilterAttributes);
// void NdisFDeregisterFilterDriver(NDIS_HANDLE NdisFilterDriverHandle);
// PVOID NdisAllocateMemoryWithTagPriority(NDIS_HANDLE NdisHandle, UINT Length, ULONG Tag, EX_POOL_PRIORITY Priority);
// void __stdcall NdisFreeMemory(PVOID VirtualAddress, UINT Length, UINT MemoryFlags);
// void NdisDeregisterDeviceEx(NDIS_HANDLE NdisDeviceHandle);
// PVOID NdisGetDeviceReservedExtension(PDEVICE_OBJECT DeviceObject);
// NDIS_STATUS NdisRegisterDeviceEx(NDIS_HANDLE NdisHandle, PNDIS_DEVICE_OBJECT_ATTRIBUTES DeviceObjectAttributes, PDEVICE_OBJECT *pDeviceObject, PNDIS_HANDLE NdisDeviceHandle);
// NDIS_STATUS NdisFRegisterFilterDriver(PDRIVER_OBJECT DriverObject, NDIS_HANDLE FilterDriverContext, PNDIS_FILTER_DRIVER_CHARACTERISTICS FilterDriverCharacteristics, PNDIS_HANDLE NdisFilterDriverHandle);
// void NdisFIndicateReceiveNetBufferLists(NDIS_HANDLE NdisFilterHandle, PNET_BUFFER_LIST NetBufferLists, NDIS_PORT_NUMBER PortNumber, ULONG NumberOfNetBufferLists, ULONG ReceiveFlags);
// void __stdcall NdisSetEvent(PNDIS_EVENT Event);
// BOOLEAN __stdcall NdisWaitEvent(PNDIS_EVENT Event, UINT msToWait);
// void __stdcall NdisInitializeEvent(PNDIS_EVENT Event);
// NDIS_STATUS NdisSetOptionalHandlers(NDIS_HANDLE NdisHandle, PNDIS_DRIVER_OPTIONAL_HANDLERS OptionalHandlers);
// void NdisFIndicateStatus(NDIS_HANDLE NdisFilterHandle, PNDIS_STATUS_INDICATION StatusIndication);
// void NdisFOidRequestComplete(NDIS_HANDLE NdisFilterHandle, PNDIS_OID_REQUEST OidRequest, NDIS_STATUS Status);
// void NdisFreeCloneOidRequest(NDIS_HANDLE SourceHandle, PNDIS_OID_REQUEST Request);
// NDIS_STATUS NdisFOidRequest(NDIS_HANDLE NdisFilterHandle, PNDIS_OID_REQUEST OidRequest);
// NDIS_STATUS NdisAllocateCloneOidRequest(NDIS_HANDLE SourceHandle, PNDIS_OID_REQUEST OidRequest, UINT PoolTag, PNDIS_OID_REQUEST *ClonedOidRequest);
// void __stdcall NdisCloseConfiguration(NDIS_HANDLE ConfigurationHandle);
// NDIS_STATUS NdisOpenConfigurationEx(PNDIS_CONFIGURATION_OBJECT ConfigObject, PNDIS_HANDLE ConfigurationHandle);
// void NdisFSendNetBufferLists(NDIS_HANDLE NdisFilterHandle, PNET_BUFFER_LIST NetBufferList, NDIS_PORT_NUMBER PortNumber, ULONG SendFlags);
// NTSTATUS __stdcall IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName);
// PIO_WORKITEM __stdcall IoAllocateWorkItem(PDEVICE_OBJECT DeviceObject);
// void __stdcall IoQueueWorkItem(PIO_WORKITEM IoWorkItem, PIO_WORKITEM_ROUTINE WorkerRoutine, WORK_QUEUE_TYPE QueueType, PVOID Context);
// BOOLEAN __stdcall KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
// void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
// void __stdcall KeInitializeTimer(PKTIMER Timer);
// BOOLEAN __stdcall KeCancelTimer(PKTIMER);
// void __stdcall ExQueueWorkItem(PWORK_QUEUE_ITEM WorkItem, WORK_QUEUE_TYPE QueueType);
// PEPROCESS IoGetCurrentProcess(void);
// NTSTATUS __stdcall ExDeleteResourceLite(PERESOURCE Resource);
// void __stdcall IoSetShareAccess(ACCESS_MASK DesiredAccess, ULONG DesiredShareAccess, PFILE_OBJECT FileObject, PSHARE_ACCESS ShareAccess);
// NTSTATUS __stdcall SeAssignSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR ExplicitDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOLEAN IsDirectoryObject, PSECURITY_SUBJECT_CONTEXT SubjectContext, PGENERIC_MAPPING GenericMapping, POOL_TYPE PoolType);
// void IoRemoveShareAccess(PFILE_OBJECT FileObject, PSHARE_ACCESS ShareAccess);
// void __stdcall ExReleaseResourceLite(PERESOURCE Resource);
// NTSTATUS __stdcall SeDeassignSecurity(PSECURITY_DESCRIPTOR *SecurityDescriptor);
// void KeEnterCriticalRegion(void);
// void KeLeaveCriticalRegion(void);
// void __stdcall IoFreeWorkItem(PIO_WORKITEM IoWorkItem);
// NTSTATUS __stdcall ExInitializeResourceLite(PERESOURCE Resource);
// void __stdcall IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
// NTSTATUS __stdcall IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName, PUNICODE_STRING DeviceName);
// NTSTATUS __stdcall IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, ULONG DeviceType, ULONG DeviceCharacteristics, BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject);
// NTSTATUS __stdcall ZwQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
// NTSTATUS __stdcall ZwOpenKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// NTSTATUS __stdcall ZwSetSecurityObject(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);
// NTSTATUS __stdcall RtlSetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, BOOLEAN DaclPresent, PACL Dacl, BOOLEAN DaclDefaulted);
// NTSTATUS __stdcall RtlCreateSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Revision);
// PVOID __stdcall ExAllocatePool(POOL_TYPE PoolType, SIZE_T NumberOfBytes);
// ULONG __stdcall RtlLengthSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor);
// NTSTATUS __stdcall RtlGetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, PBOOLEAN DaclPresent, PACL *Dacl, PBOOLEAN DaclDefaulted);
// NTSTATUS ObOpenObjectByPointer(PVOID Object, ULONG HandleAttributes, PACCESS_STATE PassedAccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PHANDLE Handle);
// void __stdcall IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
// PVOID __stdcall MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList, KPROCESSOR_MODE AccessMode, MEMORY_CACHING_TYPE CacheType, PVOID BaseAddress, ULONG BugCheckOnFailure, MM_PAGE_PRIORITY Priority);
// void __stdcall IoReleaseCancelSpinLock(KIRQL Irql);
// void __stdcall IoAcquireCancelSpinLock(PKIRQL Irql);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// ULONG DbgPrintEx(ULONG ComponentId, ULONG Level, PCSTR Format, ...);
// void __stdcall KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// void __stdcall KeReleaseSpinLockFromDpcLevel(PKSPIN_LOCK SpinLock);
// KIRQL __stdcall KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock);
// BOOLEAN __stdcall ExAcquireResourceExclusiveLite(PERESOURCE Resource, BOOLEAN Wait);
// void __stdcall KeAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock);
void __fastcall NmInitializeMinipInfo(NDIS_MEDIUM MiniportMediaType, FilterDeviceExtension *FilterModuleContext);
NTSTATUS __fastcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
// void __cdecl _security_init_cookie();
// NTSTATUS __stdcall GsDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);

//-------------------------------------------------------------------------
// Data declarations

char aNmuserprocea[13] = "NmUserProcEa"; // weak
GENERIC_MAPPING g_GenericMapping = { 131072u, 131072u, 131072u, 131072u }; // idb
int g_TimeSyncIntervalCount = 20; // weak
int g_FilterScanTimerInterval = 500; // weak
int g_OlpFilterConditionMaxCount = 16; // weak
_UNKNOWN g_NmDriverVersion; // weak
_UNKNOWN DefaultCharacteristics; // weak
PVOID g_FilterDriverHandle = NULL; // idb
NDIS_HANDLE g_FilterDeviceHandle = NULL; // idb
LIST_ENTRY g_FilterModuleList = { NULL, NULL };
LIST_ENTRY g_ByPassFilterModuleList = { NULL, NULL };
GroupAce *g_GroupAce = NULL;
int g_AttachUpperLayers = 0; // weak
int g_NmDebug = 0; // weak
__int64 g_DriverStartTimeStamp = 0i64; // weak
int g_InternalRequestFailedCount = 0; // weak
KSPIN_LOCK g_FilterListLock = 0ui64; // idb
KIRQL g_Irql = 0u; // idb
PDRIVER_OBJECT g_FilterDriverObject = NULL; // idb


//----- (0000000000011008) ----------------------------------------------------
NDIS_STATUS __fastcall NetmonSetOptions(NDIS_HANDLE NdisDriverHandle, NDIS_HANDLE DriverContext)
{
  NDIS_STATUS result; // eax

  if ( NdisDriverHandle != g_FilterDriverHandle || DriverContext != g_FilterDriverObject )
    result = STATUS_INVALID_PARAMETER;
  else
    result = STATUS_SUCCESS;
  return result;
}

//----- (000000000001102C) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonFilterPause(FilterDeviceExtension *FilterModuleContext, PNDIS_FILTER_PAUSE_PARAMETERS PauseParameters)
{
  FilterDeviceExtension *Context; // rbx
  KIRQL NewIrql; // al

  Context = FilterModuleContext;
  NewIrql = KeAcquireSpinLockRaiseToDpc(&FilterModuleContext->SpinLock);
  Context->State = FilterPausing;
  Context->irql = NewIrql;
  KeReleaseSpinLock(&Context->SpinLock, NewIrql);
  return STATUS_SUCCESS;
}

//----- (0000000000011078) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonFilterRestart(NDIS_HANDLE FilterModuleContext, PNDIS_FILTER_RESTART_PARAMETERS RestartParameters)
{
  PNDIS_FILTER_RESTART_PARAMETERS RestartParameter; // rbx
  FilterDeviceExtension *Context; // rdi
  PNDIS_RESTART_ATTRIBUTES RestartAttributes; // rax
  KIRQL irql; // al
  NDIS_CONFIGURATION_OBJECT ConfigObject; // [rsp+20h] [rbp-28h]
  NDIS_HANDLE ConfigurationHandle; // [rsp+50h] [rbp+8h]

  ConfigurationHandle = NULL;
  RestartParameter = RestartParameters;
  ConfigObject.Header.Size = 24;
  Context = (FilterDeviceExtension *)FilterModuleContext;
  ConfigObject.Header.Type = NDIS_OBJECT_TYPE_CONFIGURATION_OBJECT;
  ConfigObject.Header.Revision = NDIS_CONFIGURATION_OBJECT_REVISION_1;
  ConfigObject.NdisHandle = g_FilterDriverHandle;
  ConfigObject.Flags = 0;
  if ( !NdisOpenConfigurationEx(&ConfigObject, &ConfigurationHandle) )
    NdisCloseConfiguration(ConfigurationHandle);
  RestartAttributes = RestartParameter->RestartAttributes;
  if ( RestartAttributes )
  {
    *(_DWORD *)RestartAttributes[1].Data = 128; // 参见：\Windows-driver-samples\network\ndis\filter\filter.c的FilterRestart函数。
                                                // 
                                                // NdisGeneralAttributes = (PNDIS_RESTART_GENERAL_ATTRIBUTES)NdisRestartAttributes->Data;
                                                // NdisGeneralAttributes->LookaheadSize = 128;
    do
      RestartAttributes = RestartAttributes->Next;
    while ( RestartAttributes );
  }
  irql = KeAcquireSpinLockRaiseToDpc(&Context->SpinLock);
  Context->State = FilterPaused;                // 3估计是自定义的枚举值，表示运行状态，参见：\Windows-driver-samples\network\ndis\filter\filter.h的FILTER_STATE
  Context->irql = irql;
  KeReleaseSpinLock(&Context->SpinLock, irql);
  return STATUS_SUCCESS;
}

//----- (0000000000011128) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonOidRequest(FilterDeviceExtension *FilterModuleContext, PNDIS_OID_REQUEST OidRequest)
{
  FilterDeviceExtension *ModuleContext; // rsi
  PNDIS_OID_REQUEST OidRequest_1; // rbx
  unsigned int NtStatus_2; // eax
  NDIS_STATUS NtStatus; // edi
  PNDIS_OID_REQUEST OidRequest_2; // rdx
  PVOID InformationBuffer; // rbx
  int Information; // ebp
  KIRQL irql; // al
  bool b; // zf
  NDIS_STATUS NtStatus_1; // eax
  PNDIS_OID_REQUEST OidRequesta; // [rsp+30h] [rbp+8h]

  OidRequesta = NULL;
  ModuleContext = FilterModuleContext;
  OidRequest_1 = OidRequest;
  NtStatus_2 = NdisAllocateCloneOidRequest(FilterModuleContext->NdisFilterHandle, OidRequest, 'dnTF', &OidRequesta);
  NtStatus = NtStatus_2;
  if ( NtStatus_2 )
  {
    DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NetmonOidRequest Clone failed: %x\n", NtStatus_2);
    if ( OidRequest_1->RequestType == NdisRequestSetInformation || OidRequest_1->RequestType != (NdisRequestGeneric1|NdisRequestClose) )// NdisRequestMethod = 0xc
    {
      OidRequest_1->DATA.QUERY_INFORMATION.BytesWritten = 0;
      OidRequest_1->DATA.QUERY_INFORMATION.BytesNeeded = 0;
    }
    else
    {
      OidRequest_1->DATA.METHOD_INFORMATION.BytesRead = 0;
      OidRequest_1->DATA.METHOD_INFORMATION.BytesNeeded = 0;
      OidRequest_1->DATA.METHOD_INFORMATION.BytesWritten = 0;
    }
  }
  else
  {
    *(_QWORD *)&OidRequesta[1].DATA.METHOD_INFORMATION.MethodId = OidRequest_1;
    OidRequesta->RequestId = OidRequest_1->RequestId;
    OidRequest_2 = OidRequesta;
    ModuleContext->OidRequesta = OidRequesta;
    if ( OidRequest_2->RequestType == NdisRequestSetInformation
      && OidRequest_2->DATA.QUERY_INFORMATION.Oid == 0x1010E
      && OidRequest_2->DATA.QUERY_INFORMATION.InformationBufferLength == 4 )
    {
      InformationBuffer = OidRequest_2->DATA.QUERY_INFORMATION.InformationBuffer;
      Information = *(_DWORD *)InformationBuffer;
      irql = KeAcquireSpinLockRaiseToDpc(&ModuleContext->SpinLock);
      b = ModuleContext->dword21C == 0;
      ModuleContext->irql = irql;
      LODWORD(ModuleContext->filter) = *(_DWORD *)InformationBuffer;
      if ( !b )
        *(_DWORD *)InformationBuffer = Information | HIDWORD(ModuleContext->filter);
      KeReleaseSpinLock(&ModuleContext->SpinLock, ModuleContext->irql);
      OidRequest_2 = OidRequesta;
    }
    NtStatus_1 = NdisFOidRequest(ModuleContext->NdisFilterHandle, OidRequest_2);
    NtStatus = NtStatus_1;
    if ( NtStatus_1 != NDIS_STATUS_PENDING )
    {
      NetmonOidRequestComplete(ModuleContext, OidRequesta, NtStatus_1);
      NtStatus = NDIS_STATUS_PENDING;
    }
  }
  return NtStatus;
}

//----- (000000000001126C) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonOidRequestComplete(FilterDeviceExtension *FilterModuleContext, PNDIS_OID_REQUEST OidRequest, NDIS_STATUS Status)
{
  PNDIS_OID_REQUEST OidRequest_2; // rdi
  NDIS_STATUS status; // esi
  PNDIS_OID_REQUEST OidRequest_1; // rbx
  FilterDeviceExtension *Context; // rbp
  __int32 RequestType; // ecx
  __int64 v8; // rcx

  OidRequest_2 = *(PNDIS_OID_REQUEST *)&OidRequest[1].DATA.METHOD_INFORMATION.MethodId;
  status = Status;
  OidRequest_1 = OidRequest;
  Context = FilterModuleContext;
  if ( OidRequest_2 )
  {
    FilterModuleContext->OidRequesta = 0i64;
    RequestType = OidRequest->RequestType - 1;
    OidRequest_2->DATA.QUERY_INFORMATION.BytesWritten = OidRequest->DATA.QUERY_INFORMATION.BytesWritten;
    if ( RequestType )
    {
      if ( RequestType == NdisRequestGeneric4 )
      {
        *(_QWORD *)&OidRequest_2->DATA.METHOD_INFORMATION.BytesRead = *(_QWORD *)&OidRequest->DATA.METHOD_INFORMATION.BytesRead;
        OidRequest_2->DATA.METHOD_INFORMATION.BytesWritten = OidRequest->DATA.METHOD_INFORMATION.BytesWritten;
      }
      else
      {
        OidRequest_2->DATA.QUERY_INFORMATION.BytesNeeded = OidRequest->DATA.QUERY_INFORMATION.BytesNeeded;
      }
    }
    else
    {
      OidRequest_2->DATA.QUERY_INFORMATION.BytesNeeded = OidRequest->DATA.QUERY_INFORMATION.BytesNeeded;
      v8 = Context->qword3B0;
      if ( v8 && OidRequest->DATA.QUERY_INFORMATION.Oid == 0xD010308 && !Status && OidRequest->DATA.QUERY_INFORMATION.InformationBufferLength >= 8 )
        pNmDot11StoreOpMode(v8, *((_DWORD *)OidRequest->DATA.QUERY_INFORMATION.InformationBuffer + 1));
    }
    *(_QWORD *)&OidRequest_1[1].DATA.METHOD_INFORMATION.MethodId = 0i64;
    NdisFreeCloneOidRequest(Context->NdisFilterHandle, OidRequest_1);
    NdisFOidRequestComplete(Context->NdisFilterHandle, OidRequest_2, status);
  }
  else
  {
    *(_DWORD *)&OidRequest[1].NdisReserved[32] = Status;
    NdisSetEvent((PNDIS_EVENT)&OidRequest[1].NdisReserved[8]);
  }
}

//----- (0000000000011358) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonFilterStatus(FilterDeviceExtension *FilterModuleContext, PNDIS_STATUS_INDICATION StatusIndication)
{
  NdisFIndicateStatus(FilterModuleContext->NdisFilterHandle, StatusIndication);
}

//----- (000000000001136C) ----------------------------------------------------
NDIS_STATUS __fastcall NetmonFilterSetModuleOptions(NDIS_HANDLE FilterModuleContext)
{
  FilterDeviceExtension *Context; // rbx
  void (__fastcall *ReceiveNetBufferLists)(FilterDeviceExtension *, PNET_BUFFER_LIST, NDIS_PORT_NUMBER, ULONG, ULONG); // rax
  NDIS_DRIVER_OPTIONAL_HANDLERS OptionalHandlers; // [rsp+20h] [rbp-38h]
  void (__fastcall *SendNetBufferLists)(FilterDeviceExtension *, PNET_BUFFER_LIST, NDIS_PORT_NUMBER, ULONG); // [rsp+28h] [rbp-30h]
  void (__fastcall *ReceiveNetBufferList)(FilterDeviceExtension *, PNET_BUFFER_LIST, NDIS_PORT_NUMBER, ULONG, ULONG); // [rsp+40h] [rbp-18h]

  Context = (FilterDeviceExtension *)FilterModuleContext;
  memmove(&OptionalHandlers, &DefaultCharacteristics, 0x30u);
  _InterlockedAdd(&Context->field_210, 1u);
  ReceiveNetBufferLists = NULL;
  if ( BYTE2(Context->gap20C) )
  {
    SendNetBufferLists = NetmonSendNetBufferLists;
    ReceiveNetBufferLists = NetmonReceiveNetBufferLists;
  }
  else
  {
    SendNetBufferLists = NULL;
  }
  ReceiveNetBufferList = ReceiveNetBufferLists;
  if ( _InterlockedExchangeAdd(&Context->field_210, 0xFFFFFFFF) == 1 )
    NmDestroyFilterModule(Context);
  return NdisSetOptionalHandlers(Context->NdisFilterHandle, &OptionalHandlers);
}

//----- (00000000000113F0) ----------------------------------------------------
NDIS_STATUS __fastcall nmFilterDoInternalRequest(int a1, FilterDeviceExtension *DeviceExtension, int RequestType_1, __int64 *Information, unsigned int InformationBufferLength, int a6, __int64 a7, unsigned int **a8)
{
  __int64 *InformationBuffer; // rsi
  int RequestType; // er12
  FilterDeviceExtension *DeviceExtension_1; // r13
  int Oid; // ebp
  NDIS_STATUS result; // eax
  NDIS_HANDLE NdisFilterHandle; // rcx
  UINT BytesWritten; // ecx
  NDIS_OID_REQUEST OidRequest; // [rsp+20h] [rbp-138h]
  struct _NDIS_EVENT Event; // [rsp+110h] [rbp-48h]
  NDIS_STATUS NtStatus; // [rsp+128h] [rbp-30h]

  NtStatus = STATUS_SUCCESS;
  InformationBuffer = Information;
  RequestType = RequestType_1;
  DeviceExtension_1 = DeviceExtension;
  Oid = a1;
  if ( DeviceExtension->State == FilterRestarting )
    return STATUS_SUCCESS;
  memset(&OidRequest, 0, 0xF0u);
  NdisInitializeEvent(&Event);
  OidRequest.Header.Size = 0xF0;
  OidRequest.Header.Type = NDIS_OBJECT_TYPE_REQUEST_EX;
  OidRequest.Header.Revision = NDIS_FILTER_CHARACTERISTICS_REVISION_1;
  OidRequest.RequestType = RequestType;
  if ( !RequestType || RequestType == 1 )
    goto LABEL_7;
  if ( RequestType == 12 )
  {
    *(_QWORD *)&OidRequest.DATA.METHOD_INFORMATION.OutputBufferLength = 0i64;
LABEL_7:
    OidRequest.DATA.QUERY_INFORMATION.Oid = Oid;
    OidRequest.DATA.QUERY_INFORMATION.InformationBuffer = InformationBuffer;
    OidRequest.DATA.QUERY_INFORMATION.InformationBufferLength = InformationBufferLength;
  }
  NdisFilterHandle = DeviceExtension_1->NdisFilterHandle;
  OidRequest.RequestId = (PVOID)0x52464D4E;
  result = NdisFOidRequest(NdisFilterHandle, &OidRequest);
  if ( result == NDIS_STATUS_PENDING )
  {
    NdisWaitEvent(&Event, 0);
    result = NtStatus;
  }
  if ( !result )
  {
    BytesWritten = OidRequest.DATA.QUERY_INFORMATION.BytesWritten;
    if ( RequestType == 1 )
      *(_DWORD *)a8 = OidRequest.DATA.QUERY_INFORMATION.BytesWritten;
    if ( !RequestType )
      *(_DWORD *)a8 = BytesWritten;
    if ( *(_DWORD *)a8 > InformationBufferLength )
      *(_DWORD *)a8 = InformationBufferLength;
  }
  return result;
}

//----- (0000000000011534) ----------------------------------------------------
NDIS_STATUS __fastcall NmRegisterFilter(PDRIVER_OBJECT DriverObject)
{
  PDRIVER_OBJECT pDriverObject; // rbx
  PDRIVER_OBJECT FilterDriverObject; // rdx
  NDIS_STRING FriendlyName; // xmm0
  NDIS_STRING UniqueName; // xmm1
  NDIS_STRING ServiceName; // xmm0
  _NDIS_FILTER_DRIVER_CHARACTERISTICS FilterDriverCharacteristics; // [rsp+20h] [rbp-108h]
  UNICODE_STRING name; // [rsp+100h] [rbp-28h]
  UNICODE_STRING DestinationString; // [rsp+110h] [rbp-18h]

  pDriverObject = DriverObject;
  RtlInitUnicodeString(&name, L"nm3");
  RtlInitUnicodeString(&DestinationString, L"Netmon Lightweight Filter Driver");
  RtlInitUnicodeString((PUNICODE_STRING)&FilterDriverCharacteristics.DirectOidRequestCompleteHandler, L"{6E022F38-AB31-44c5-8206-2EB023EFF145}");
  memset(&FilterDriverCharacteristics, 0, 0xC8u);
  FilterDriverObject = g_FilterDriverObject;
  FriendlyName = (NDIS_STRING)_mm_loadu_si128((const __m128i *)&DestinationString);
  UniqueName = (NDIS_STRING)_mm_loadu_si128((const __m128i *)&FilterDriverCharacteristics.DirectOidRequestCompleteHandler);
  FilterDriverCharacteristics.MinorNdisVersion = 0;
  FilterDriverCharacteristics.MinorDriverVersion = 0;
  _mm_storeu_si128((__m128i *)&FilterDriverCharacteristics.FriendlyName, (__m128i)FriendlyName);
  ServiceName = (NDIS_STRING)_mm_loadu_si128((const __m128i *)&name);
  _mm_storeu_si128((__m128i *)&FilterDriverCharacteristics.UniqueName, (__m128i)UniqueName);
  FilterDriverCharacteristics.AttachHandler = (FILTER_ATTACH_HANDLER)NetmonFilterAttach;
  FilterDriverCharacteristics.Flags = 0;
  FilterDriverCharacteristics.DetachHandler = (FILTER_DETACH_HANDLER)NetmonFilterDetach;
  FilterDriverCharacteristics.ReturnNetBufferListsHandler = 0i64;
  _mm_storeu_si128((__m128i *)&FilterDriverCharacteristics.ServiceName, (__m128i)ServiceName);
  FilterDriverCharacteristics.RestartHandler = (FILTER_RESTART_HANDLER)NetmonFilterRestart;
  FilterDriverCharacteristics.CancelOidRequestHandler = 0i64;
  FilterDriverCharacteristics.PauseHandler = (FILTER_PAUSE_HANDLER)NetmonFilterPause;
  FilterDriverCharacteristics.SendNetBufferListsCompleteHandler = 0i64;
  FilterDriverCharacteristics.OidRequestHandler = (FILTER_OID_REQUEST_HANDLER)NetmonOidRequest;
  FilterDriverCharacteristics.CancelSendNetBufferListsHandler = 0i64;
  FilterDriverCharacteristics.SetFilterModuleOptionsHandler = (FILTER_SET_FILTER_MODULE_OPTIONS_HANDLER)NetmonFilterSetModuleOptions;
  FilterDriverCharacteristics.SetOptionsHandler = (SET_OPTIONS_HANDLER)NetmonSetOptions;
  FilterDriverCharacteristics.ReceiveNetBufferListsHandler = (FILTER_RECEIVE_NET_BUFFER_LISTS_HANDLER)NetmonReceiveNetBufferLists;
  FilterDriverCharacteristics.DevicePnPEventNotifyHandler = (FILTER_DEVICE_PNP_EVENT_NOTIFY_HANDLER)NetmonDevicePnPEventNotify;
  FilterDriverCharacteristics.Header.Type = NDIS_OBJECT_TYPE_FILTER_DRIVER_CHARACTERISTICS;
  FilterDriverCharacteristics.NetPnPEventHandler = (FILTER_NET_PNP_EVENT_HANDLER)NetmonNetPnPEvent;
  FilterDriverCharacteristics.Header.Size = 0xC8;
  FilterDriverCharacteristics.StatusHandler = (FILTER_STATUS_HANDLER)NetmonFilterStatus;
  FilterDriverCharacteristics.Header.Revision = NDIS_FILTER_CHARACTERISTICS_REVISION_1;
  FilterDriverCharacteristics.OidRequestCompleteHandler = (FILTER_OID_REQUEST_COMPLETE_HANDLER)NetmonOidRequestComplete;
  FilterDriverCharacteristics.MajorNdisVersion = NDIS_FILTER_MAJOR_VERSION;
  FilterDriverCharacteristics.SendNetBufferListsHandler = (FILTER_SEND_NET_BUFFER_LISTS_HANDLER)NetmonSendNetBufferLists;
  FilterDriverCharacteristics.MajorDriverVersion = 1;
  pDriverObject->DriverUnload = (PDRIVER_UNLOAD)NetmonUnload;
  return NdisFRegisterFilterDriver(pDriverObject, FilterDriverObject, &FilterDriverCharacteristics, &g_FilterDriverHandle);
}

//----- (0000000000011700) ----------------------------------------------------
NDIS_STATUS __fastcall nmOid_Query(int a1, FilterDeviceExtension *a2, __int64 *a3, unsigned int a4)
{
  __int64 v5; // [rsp+30h] [rbp-28h]
  unsigned int *a8; // [rsp+40h] [rbp-18h]

  LODWORD(v5) = 0;
  return nmFilterDoInternalRequest(a1, a2, 0, a3, a4, 0, v5, &a8);
}
// 11723: variable 'v5' is possibly undefined

//----- (0000000000011734) ----------------------------------------------------
NDIS_STATUS __fastcall NmGetGlobalStat(FilterDeviceExtension *FilterDeviceExtension, int n, __int64 *a3, unsigned int a4)
{
  __int64 v5; // [rsp+30h] [rbp-18h]
  __int64 *v6; // [rsp+60h] [rbp+18h]

  v6 = a3;
  LODWORD(v5) = 0;
  return nmFilterDoInternalRequest(n, FilterDeviceExtension, 0, a3, a4, 0, v5, (unsigned int **)&v6);
}
// 11767: variable 'v5' is possibly undefined

//----- (0000000000011778) ----------------------------------------------------
void __fastcall NmDerefCaptureBuffer(PVOID P)
{
  FileContext *FsContext; // rbp
  _QWORD *v2; // rsi
  _QWORD *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rdi
  __int64 v9; // rbx

  FsContext = (FileContext *)*((_QWORD *)P + 8);
  v2 = P;
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)P + 22, 0xFFFFFFFF) == 1 )
  {
    _RBX = *((_QWORD *)P + 2);
    IoAcquireCancelSpinLock((PKIRQL)(_RBX + 69));
    _RAX = 0i64;
    __asm { xchg    rax, [rbx+68h]; Exchange Register/Memory with Register }
    IoReleaseCancelSpinLock(*(_BYTE *)(_RBX + 69));
    FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    v6 = (_QWORD *)v2[10];
    v7 = v2[9];
    *v6 = v7;
    *(_QWORD *)(v7 + 8) = v6;
    v8 = (unsigned int)++*(_DWORD *)(v2[8] + 104i64);
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    v9 = v2[8];
    memmove(v2 + 22, (const void *)(v9 + 248), 0x30u);
    memmove(v2 + 16, (const void *)(v9 + 200), 0x30u);
    v2[23] = v8;
    NmDestroyCaptureBuffer(v2);
    NmDerefUserProc(FsContext);
  }
}

//----- (0000000000011860) ----------------------------------------------------
void __fastcall NmDestroyCaptureBuffer(PVOID P)
{
  _IRP *irp; // rsi
  _DWORD *v2; // rbx
  __int64 v3; // rcx
  PVOID v4; // rbp
  unsigned int v5; // eax
  const void *v6; // rdx
  __int16 Src; // [rsp+30h] [rbp-B8h]
  __int16 v8; // [rsp+32h] [rbp-B6h]
  __int64 v9; // [rsp+38h] [rbp-B0h]
  int v10; // [rsp+40h] [rbp-A8h]
  char v11[12]; // [rsp+44h] [rbp-A4h]
  char Dst; // [rsp+50h] [rbp-98h]
  char v13; // [rsp+80h] [rbp-68h]
  char v14; // [rsp+B0h] [rbp-38h]
  int v15; // [rsp+D8h] [rbp-10h]

  irp = (_IRP *)*((_QWORD *)P + 2);
  v2 = P;
  if ( irp->IoStatus.Status == (STATUS_MEDIA_CHECK|STATUS_OBJECT_NAME_EXISTS|STATUS_KERNEL_APC)
    || irp->IoStatus.Status == STATUS_INVALID_HANDLE
    || irp->IoStatus.Status == NDIS_STATUS_RESOURCES )
  {
    irp->IoStatus.Information = 0i64;
  }
  else
  {
    v3 = *((_QWORD *)P + 1);
    if ( *(_BYTE *)(v3 + 10) & 5 )
      v4 = *(PVOID *)(v3 + 24);
    else
      v4 = MmMapLockedPagesSpecifyCache((PMDL)v3, 0, MmCached, 0i64, 0, NormalPagePriority);
    *(_QWORD *)&v11[4] = 0i64;
    Src = 1;
    v8 = 176;
    v10 = v2[30];
    v5 = v2[31];
    v9 = MEMORY[0xFFFFF78000000014] / 10i64;
    *(_QWORD *)v11 = v5;
    memmove(&Dst, v2 + 32, 0x30u);
    memmove(&v13, v2 + 44, 0x30u);
    v6 = (const void *)(*((_QWORD *)v2 + 8) + 296i64);
    v15 = 192;
    memmove(&v14, v6, 0x28u);
    *(_DWORD *)(*((_QWORD *)v2 + 2) + 48i64) = 0;
    *(_QWORD *)(*((_QWORD *)v2 + 2) + 56i64) = (unsigned int)v2[23];
    if ( v4 )
      memmove(v4, &Src, 0xB0u);
    *(_DWORD *)(*((_QWORD *)v2 + 2) + 48i64) = 0;
    *(_QWORD *)(*((_QWORD *)v2 + 2) + 56i64) = (unsigned int)v2[23];
  }
  ExFreePoolWithTag(v2, 0);
  IofCompleteRequest(irp, IO_NETWORK_INCREMENT);
}

//----- (0000000000011A08) ----------------------------------------------------
__int64 __fastcall NmCaptureFilterMatch(__int64 a1, __int64 a2)
{
  unsigned int v2; // er11
  int v3; // eax
  unsigned int v4; // er9
  __int64 v5; // rdi
  int v6; // er8
  _BOOL8 v7; // rbp
  __int64 v8; // r15
  __int64 v9; // r14
  unsigned int v10; // esi
  PMDL mdl; // rbx
  PVOID MappedSystemVa_1; // rax
  __int64 v13; // rdx
  PVOID MappedSystemVa; // r13
  ULONG ByteCount; // edi
  int v16; // er12
  ULONG v17; // esi
  __int64 v18; // rbp
  __int64 v19; // r10
  __int64 result; // rax
  _WORD *v21; // rbx
  int v22; // er11
  bool v23; // zf
  unsigned __int8 v24; // dl
  unsigned __int8 v25; // r8
  unsigned __int8 v26; // r9
  __int64 v27; // r12
  __int64 v28; // rbp
  unsigned __int16 v29; // di
  __int16 v30; // si
  int v31; // eax
  int v32; // er11
  unsigned __int8 v33; // r9
  unsigned __int16 v34; // di
  unsigned __int8 v35; // r8
  unsigned __int8 v36; // r10
  char v37; // r9
  unsigned int v38; // [rsp+30h] [rbp-68h]
  int i; // [rsp+34h] [rbp-64h]
  _BOOL8 v40; // [rsp+38h] [rbp-60h]
  __int64 v41; // [rsp+40h] [rbp-58h]
  __int64 v42; // [rsp+A0h] [rbp+8h]
  __int64 v43; // [rsp+A8h] [rbp+10h]
  unsigned int v44; // [rsp+B0h] [rbp+18h]
  unsigned int v45; // [rsp+B8h] [rbp+20h]

  v43 = a2;
  v42 = a1;
  v2 = *(_DWORD *)(a2 + 24);
  v3 = _bittest((const signed __int32 *)(a1 + 24), 0x10u);
  v4 = 16;
  v5 = a2;
  v6 = 16;
  v44 = *(_DWORD *)(a2 + 24);
  if ( !*(_QWORD *)(a2 + 8) || !v2 )
    return 0xFFFFFFFFi64;
  v7 = v3 == 0;
  v8 = a1 + 36;
  v38 = 0;
  v40 = v3 == 0;
  v41 = v3;
  if ( *(_DWORD *)(a1 + 32) > 0u )
  {
    while ( 1 )
    {
      v45 = 0;
      v9 = *(_QWORD *)v8 + 12i64;
      if ( *(_DWORD *)(*(_QWORD *)v8 + 8i64) > 0u )
        break;
LABEL_81:
      result = 1i64;
      v4 = v6;
      if ( v6 == 1 )
      {
LABEL_77:
        if ( !v41 )
          return result;
      }
      else
      {
LABEL_82:
        LODWORD(result) = 1;
        if ( *(_DWORD *)(*(_QWORD *)v8 + 4i64) & 1 )
          return 2i64;
        if ( v41 == 1 )
          return 0i64;
      }
      v8 += 8i64;
      v38 += result;
      if ( v38 >= *(_DWORD *)(v42 + 32) )
        return v4;
      v5 = v43;
      v2 = v44;
    }
    v10 = 8 * v2;
    for ( i = 8 * v2; ; v10 = i )
    {
      mdl = *(PMDL *)(v5 + 8);
      if ( mdl->MdlFlags & 5 )
      {
        MappedSystemVa_1 = mdl->MappedSystemVa;
      }
      else
      {
        MappedSystemVa_1 = MmMapLockedPagesSpecifyCache(*(PMDL *)(v5 + 8), 0, MmCached, 0i64, 0, NormalPagePriority);
        v2 = v44;
      }
      v13 = *(unsigned int *)(v5 + 16);
      MappedSystemVa = (char *)MappedSystemVa_1 + v13;
      if ( *(_DWORD *)(*(_QWORD *)v9 + 4i64) + *(_DWORD *)(*(_QWORD *)v9 + 8i64) <= v10 )
        break;
      v6 = -1;
LABEL_26:
      LODWORD(result) = 1;
      if ( (*(_WORD *)(*(_QWORD *)v9 + 2i64) & 1) == 1 )
        return 2i64;
      if ( v7 )
      {
        v4 = 0;
        goto LABEL_82;
      }
LABEL_28:
      v9 += 8i64;
      v45 += result;
      if ( v45 >= *(_DWORD *)(*(_QWORD *)v8 + 8i64) )
        goto LABEL_81;
      v5 = v43;
      v2 = v44;
    }
    ByteCount = v2;
    if ( mdl->ByteCount - (int)v13 < v2 )
      ByteCount = mdl->ByteCount - v13;
    v16 = *(_DWORD *)(*(_QWORD *)v9 + 4i64);
    v17 = v2 - ByteCount;
    v18 = *(_DWORD *)(*(_QWORD *)v9 + 4i64) >> 3;
    while ( (unsigned int)v18 >= ByteCount )
    {
      mdl = mdl->Next;
      if ( !mdl )
      {
        v6 = -1;
        goto LABEL_25;
      }
      if ( mdl->MdlFlags & 5 )
        MappedSystemVa = mdl->MappedSystemVa;
      else
        MappedSystemVa = MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
      v18 = (unsigned int)v18 - ByteCount;
      v16 += -8 * ByteCount;
      ByteCount = v17;
      if ( mdl->ByteCount < v17 )
        ByteCount = mdl->ByteCount;
      v17 -= ByteCount;
    }
    v19 = *(_QWORD *)v9;
    if ( v16 + *(_DWORD *)(*(_QWORD *)v9 + 8i64) > 8 * ByteCount )
    {
      v6 = 4;
LABEL_25:
      v7 = v40;
      goto LABEL_26;
    }
    if ( *(_WORD *)(v19 + 2) < 0 )
    {
      v21 = *(_WORD **)v9;
      v22 = memcmp((char *)MappedSystemVa + (unsigned int)v18, *(const void **)(v19 + 16), *(unsigned __int16 *)(v19 + 12));
      result = 1i64;
      v6 = 0;
      if ( *v21 != 1 )
      {
        switch ( *v21 )
        {
          case 2:
            LOBYTE(v6) = v22 != 0;
            break;
          case 3:
            LOBYTE(v6) = v22 > 0;
            break;
          case 4:
            LOBYTE(v6) = v22 < 0;
            break;
        }
        goto LABEL_74;
      }
      v23 = v22 == 0;
      goto LABEL_73;
    }
    v24 = *(_BYTE *)(v19 + 14);
    v25 = *((_BYTE *)MappedSystemVa + v18);
    v26 = **(_BYTE **)(v19 + 16);
    v27 = (unsigned int)v18;
    result = 1i64;
    v28 = *(_QWORD *)v9;
    if ( v24 )
    {
      switch ( *(_WORD *)v19 )
      {
        case 1:
          v6 = (v25 & v24) == (v26 & *(_BYTE *)(v19 + 14));
          break;
        case 2:
          v6 = (v25 & v24) != (v26 & *(_BYTE *)(v19 + 14));
          break;
        case 3:
          v6 = (unsigned __int8)(v25 & v24) > (unsigned __int8)(v26 & *(_BYTE *)(v19 + 14));
          break;
        case 4:
          v6 = (unsigned __int8)(v25 & v24) < (unsigned __int8)(v26 & *(_BYTE *)(v19 + 14));
          break;
        default:
          v6 = 0;
          goto LABEL_51;
      }
      result = 1i64;
    }
    else
    {
      v6 = 1;
    }
LABEL_51:
    if ( v6 != 1 )
      goto LABEL_25;
    v29 = *(_WORD *)(v19 + 12);
    v30 = *(_BYTE *)(v19 + 14) != 0;
    if ( v29 > 0u )
    {
      v31 = memcmp((char *)MappedSystemVa + v27 + (*(_BYTE *)(v19 + 14) != 0), (const void *)((*(_BYTE *)(v19 + 14) != 0) + *(_QWORD *)(v19 + 16)), v29);
      v6 = 0;
      v32 = v31;
      result = 1i64;
      switch ( *(_WORD *)v28 )
      {
        case 1:
          LOBYTE(v6) = v32 == 0;
          break;
        case 2:
          LOBYTE(v6) = v32 != 0;
          break;
        case 3:
          LOBYTE(v6) = v32 > 0;
          break;
        case 4:
          LOBYTE(v6) = v32 < 0;
          break;
      }
      if ( v6 != 1 )
        goto LABEL_25;
    }
    v33 = *(_BYTE *)(v28 + 15);
    if ( v33 <= 0u )
      goto LABEL_75;
    v34 = v30 + v29;
    v35 = *((_BYTE *)MappedSystemVa + v34 + v27);
    v36 = *(_BYTE *)(v34 + *(_QWORD *)(v28 + 16));
    result = 1i64;
    if ( *(_WORD *)v28 != 1 )
    {
      switch ( *(_WORD *)v28 )
      {
        case 2:
          v6 = (v35 & v33) != (v36 & *(_BYTE *)(v28 + 15));
          break;
        case 3:
          v6 = (unsigned __int8)(v35 & v33) > (unsigned __int8)(v36 & *(_BYTE *)(v28 + 15));
          break;
        case 4:
          v6 = (unsigned __int8)(v35 & v33) < (unsigned __int8)(v36 & *(_BYTE *)(v28 + 15));
          break;
        default:
          v6 = 0;
          goto LABEL_74;
      }
      result = 1i64;
LABEL_74:
      if ( v6 != 1 )
        goto LABEL_25;
LABEL_75:
      v7 = v40;
      if ( !v40 )
      {
        v4 = 1;
        goto LABEL_77;
      }
      goto LABEL_28;
    }
    v37 = v35 & v33;
    v6 = 0;
    v23 = v37 == (v36 & *(_BYTE *)(v28 + 15));
    result = 1i64;
LABEL_73:
    LOBYTE(v6) = v23;
    goto LABEL_74;
  }
  return v4;
}

//----- (0000000000011EDC) ----------------------------------------------------
__int64 __fastcall NmGetFilterSize(_IRP *a1, _DWORD *a2, _DWORD *a3, _IRP *a4)
{
  _DWORD *v4; // rbx
  _DWORD *v5; // r11
  unsigned int v6; // edi
  unsigned int v7; // er14
  unsigned int v8; // er9
  int v9; // esi
  MACRO_NDIS_MEMORY NtStatus; // er8
  char *v11; // r10
  unsigned int v12; // er13
  unsigned int v13; // ebp
  unsigned int v14; // edx

  v4 = a3;
  v5 = a2;
  if ( !a2 )
    return NDIS_STATUS_INVALID_PARAMETER;
  if ( !a3 )
    return NDIS_STATUS_INVALID_PARAMETER;
  v6 = (unsigned int)a4->ThreadListEntry.Flink;
  v7 = HIDWORD(a4->AssociatedIrp.SystemBuffer);
  v8 = 36;
  *a2 = 8 * v6 + 44;
  if ( v7 <= 0x24 )
    return NDIS_STATUS_INVALID_PARAMETER;
  *a3 = 0;
  v9 = 0;
  NtStatus = 0;
  v11 = (char *)&a1->ThreadListEntry.Flink + 4;
  if ( v6 )
  {
    while ( NtStatus == NDIS_STATUS_SUCCESS )
    {
      v8 += 12;
      *v5 += 8 * *((_DWORD *)v11 + 2) + 20;
      if ( v8 >= v7 )
        return NDIS_STATUS_INVALID_PARAMETER;
      v12 = *((_DWORD *)v11 + 2);
      v13 = 0;
      *v4 += v12;
      v11 = (char *)a1 + v8;
      if ( v12 )
      {
        while ( 1 )
        {
          v14 = ((*((_DWORD *)v11 + 1) & 7u) + *((_DWORD *)v11 + 2) + 7) >> 3;
          v8 += v14 + 16;
          *v5 += v14 + 24;
          if ( v8 > v7 )
            break;
          ++v13;
          v11 = (char *)a1 + v8;
          if ( v13 >= v12 )
            goto LABEL_12;
        }
        NtStatus = NDIS_STATUS_INVALID_PARAMETER;
      }
LABEL_12:
      if ( ++v9 >= v6 )
        return NtStatus;
    }
  }
  return NtStatus;
}

//----- (0000000000011FE4) ----------------------------------------------------
__int64 __fastcall NmUnserializeCaptureFilter(FileContext *FsContext, _IRP *MasterIrp, unsigned int a3, _IRP **Irp_1)
{
  unsigned int v4; // edi
  _IRP *MasterIrp_1; // rbx
  FileContext *FsContext_1; // r12
  MACRO_NDIS_MEMORY NtStatus; // esi
  __int64 result; // rax
  KIRQL NewIrql; // al
  unsigned int v10; // ecx
  _DWORD *v11; // rax
  _DWORD *v12; // rbp
  unsigned int v13; // er15
  int v14; // eax
  const __m128i *v15; // r9
  unsigned int v16; // er13
  __m128i *v17; // rcx
  __m128i **v18; // rdx
  __int64 v19; // rax
  __m128i *v20; // rax
  __m128i **v21; // r8
  __m128i v22; // xmm0
  __m128i *v23; // r8
  int v24; // edx
  int v25; // eax
  unsigned int v26; // edi
  __int64 v27; // rbx
  bool v28; // cf
  int v29; // ebx
  KIRQL irql; // al
  int v31; // [rsp+20h] [rbp-68h]
  int v32; // [rsp+24h] [rbp-64h]
  int v33; // [rsp+28h] [rbp-60h]
  const __m128i *v34; // [rsp+30h] [rbp-58h]
  __m128i **v35; // [rsp+38h] [rbp-50h]
  __int64 *v36; // [rsp+40h] [rbp-48h]
  SIZE_T NumberOfBytes; // [rsp+98h] [rbp+10h]
  unsigned int v38; // [rsp+A0h] [rbp+18h]
  _IRP **irp; // [rsp+A8h] [rbp+20h]

  irp = Irp_1;
  v38 = a3;
  v31 = 0;
  v4 = a3;
  MasterIrp_1 = MasterIrp;
  FsContext_1 = FsContext;
  NtStatus = NDIS_STATUS_INVALID_PARAMETER;
  if ( MasterIrp && Irp_1 && HIDWORD(MasterIrp->AssociatedIrp.SystemBuffer) == a3 )
  {
    result = NmGetFilterSize(MasterIrp, &NumberOfBytes, &v31, MasterIrp);
    if ( (_DWORD)result )
      return result;
    NewIrql = KeAcquireSpinLockRaiseToDpc(&FsContext_1->SpinLock);
    v10 = LODWORD(FsContext_1->gap80) + v31;
    FsContext_1->irql = NewIrql;
    if ( g_OlpFilterConditionMaxCount < v10 )
    {
      KeReleaseSpinLock(&FsContext_1->SpinLock, NewIrql);
      return STATUS_QUOTA_EXCEEDED;
    }
    LODWORD(FsContext_1->gap80) = v10;
    KeReleaseSpinLock(&FsContext_1->SpinLock, NewIrql);
    v11 = ExAllocatePoolWithTag(NonPagedPool, (unsigned int)NumberOfBytes, 'u3MN');
    v12 = v11;
    if ( !v11 )
      return STATUS_NO_MEMORY;
    v13 = 36;
    memmove(v11, MasterIrp_1, 0x24u);
    v14 = v12[8];
    v15 = (const __m128i *)((char *)&MasterIrp_1->ThreadListEntry.Flink + 4);
    v16 = 8 * v14 + 36;
    v17 = (__m128i *)((char *)v12 + v16);
    if ( v4 <= 0x24 || v16 >= (unsigned int)NumberOfBytes )
      NtStatus = STATUS_DATA_OVERRUN;
    else
      NtStatus = 0;
    v33 = 0;
    v18 = (__m128i **)(v12 + 9);
    v35 = (__m128i **)(v12 + 9);
    if ( v14 )
    {
      while ( NtStatus == NDIS_STATUS_SUCCESS )
      {
        v19 = v15->m128i_i64[0];
        v13 += 12;
        v15 = (const __m128i *)((char *)v15 + 12);
        v17->m128i_i64[0] = v19;
        LODWORD(v17->m128i_i64[1]) = v15[-1].m128i_i32[3];
        *v18 = v17;
        v16 += 8 * LODWORD(v17->m128i_i64[1]) + 12;
        v17 = (__m128i *)((char *)v12 + v16);
        if ( v13 >= v4 || v16 >= (unsigned int)NumberOfBytes )
        {
          NtStatus = STATUS_DATA_OVERRUN;
          goto LABEL_29;
        }
        v20 = *v18;
        v32 = 0;
        v21 = (__m128i **)((char *)&v20->m128i_i64[1] + 4);
        v36 = (__int64 *)((char *)&v20->m128i_i64[1] + 4);
        if ( LODWORD(v20->m128i_i64[1]) > 0 )
        {
          while ( 1 )
          {
            v22 = _mm_loadu_si128(v15);
            v16 += 24;
            ++v15;
            v13 += 16;
            v34 = v15;
            _mm_storeu_si128(v17, v22);
            *v21 = v17;
            v17 = (__m128i *)((char *)v12 + v16);
            if ( v13 >= v4 || v16 >= (unsigned int)NumberOfBytes )
              break;
            v23 = *v21;
            v24 = HIDWORD(v23->m128i_i64[0]);
            v25 = v23->m128i_i64[1];
            v23[1].m128i_i64[0] = (__int64)v17;
            v26 = ((v24 & 7u) + v25 + 7) >> 3;
            v27 = v26;
            memmove(v17, v15, v26);
            v16 += v26;
            v13 += v26;
            v4 = v38;
            v15 = (const __m128i *)((char *)v34 + v27);
            v34 = (const __m128i *)((char *)v34 + v27);
            v17 = (__m128i *)((char *)v12 + v16);
            if ( v13 > v38 || v16 > (unsigned int)NumberOfBytes )
            {
              v18 = v35;
              break;
            }
            v18 = v35;
            v21 = (__m128i **)(v36 + 1);
            v28 = (unsigned int)++v32 < LODWORD((*v35)->m128i_i64[1]);
            v15 = v34;
            ++v36;
            if ( !v28 )
              goto LABEL_26;
          }
          NtStatus = STATUS_DATA_OVERRUN;
        }
LABEL_26:
        ++v18;
        v35 = v18;
        if ( (unsigned int)++v33 >= v12[8] )
          goto LABEL_29;
      }
    }
    else
    {
LABEL_29:
      if ( NtStatus == NDIS_STATUS_SUCCESS )
        goto LABEL_31;
    }
    ExFreePoolWithTag(v12, 0);
    v12 = 0i64;
LABEL_31:
    *irp = (_IRP *)v12;
    if ( NtStatus )
    {
      v29 = v31;
      if ( v31 )
      {
        irql = KeAcquireSpinLockRaiseToDpc(&FsContext_1->SpinLock);
        LODWORD(FsContext_1->gap80) -= v29;
        FsContext_1->irql = irql;
        KeReleaseSpinLock(&FsContext_1->SpinLock, irql);
      }
    }
  }
  return NtStatus;
}
// 19128: using guessed type int g_OlpFilterConditionMaxCount;

//----- (00000000000122D8) ----------------------------------------------------
NTSTATUS __fastcall NmAddCaptureFilter(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  _IO_STACK_LOCATION *CurrentStackLocation; // rax
  PIRP MasterIrp; // rbp
  NTSTATUS NtStatus; // ebx
  unsigned int InputBufferLength; // er14
  PFILE_OBJECT FileObject; // rax
  PIRP irp; // r13
  FileContext *FsContext; // rdi
  NTSTATUS Status; // eax
  KIRQL irql; // al
  bool v11; // zf
  char *v12; // rsi
  char *v13; // rcx
  char **v14; // rcx
  char *v15; // rax
  PIRP Irp_1; // [rsp+58h] [rbp+10h]

  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  MasterIrp = Irp->AssociatedIrp.MasterIrp;
  NtStatus = 0;
  Irp->IoStatus.Information = 0i64;
  InputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.InputBufferLength;
  Irp->IoStatus.Information = 0i64;
  FileObject = CurrentStackLocation->FileObject;
  irp = Irp;
  Irp_1 = MasterIrp;
  FsContext = (FileContext *)FileObject->FsContext;
  Status = NmVerifyUserProcObject((FileContext *)FileObject->FsContext);
  if ( Status || InputBufferLength != HIDWORD(MasterIrp->AssociatedIrp.SystemBuffer) )
  {
    NtStatus = Status;
    if ( !Status )
      NtStatus = NDIS_STATUS_INVALID_PARAMETER;
  }
  else
  {
    irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    v11 = (FsContext->field_40 & 0x40) == 0;
    FsContext->irql = irql;
    if ( v11 && SLOBYTE(FsContext->field_40) >= 0 )
    {
      v12 = (char *)&FsContext->qword70;
      v13 = (char *)FsContext->qword70;
      if ( v13 == (char *)&FsContext->qword70 )
        goto LABEL_21;
      do
      {
        v11 = *(&MasterIrp->Flags + 1) == *((_DWORD *)v13 + 4);
        v13 = *(char **)v13;
        if ( v11 )
          NtStatus = STATUS_NETWORK_OPEN_RESTRICTION|STATUS_WAIT_2|0x28;
      }
      while ( v13 != v12 );
      if ( !NtStatus )
      {
LABEL_21:
        KeReleaseSpinLock(&FsContext->SpinLock, irql);
        NtStatus = NmUnserializeCaptureFilter(FsContext, irp->AssociatedIrp.MasterIrp, InputBufferLength, &Irp_1);
        FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
        if ( NtStatus )
        {
          NtStatus = NDIS_STATUS_RESOURCES;
        }
        else
        {
          v14 = (char **)(&Irp_1->Size + 1);
          *(PMDL *)((char *)&Irp_1->MdlAddress + 4) = (PMDL)(&Irp_1->Size + 1);
          *v14 = (char *)v14;
          v15 = (char *)FsContext->qword78;
          v14[1] = v15;
          *v14 = v12;
          *(_QWORD *)v15 = v14;
          FsContext->qword78 = v14;
        }
      }
      NmDerefUserProc(FsContext);
    }
    else
    {
      NtStatus = STATUS_DEVICE_BUSY;
    }
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
  }
  return NtStatus;
}

//----- (0000000000012420) ----------------------------------------------------
NTSTATUS __fastcall NmDeleteCaptureFilter(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  _IO_STACK_LOCATION *CurrentStackLocation; // rcx
  int MasterIrp; // ebp
  ULONG InputBufferLength; // edi
  FileContext *FsContext; // rbx
  NTSTATUS result; // eax
  KIRQL irql; // al
  bool v8; // zf
  NTSTATUS NtStatus; // edi
  _QWORD *i; // rax
  __int64 v11; // r8
  _QWORD *v12; // rax
  __int64 v13; // rcx
  int v14; // edx
  __int64 v15; // r9
  __int64 *v16; // rcx
  __int64 v17; // rax

  Irp->IoStatus.Information = 0i64;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  MasterIrp = *(_DWORD *)Irp->AssociatedIrp.MasterIrp;
  InputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.InputBufferLength;
  FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
  result = NmVerifyUserProcObject(FsContext);
  if ( result || InputBufferLength != 4 )
  {
    if ( !result )
      result = STATUS_INVALID_BUFFER_SIZE;
  }
  else
  {
    irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    v8 = (FsContext->field_40 & 0x40) == 0;
    NtStatus = STATUS_DEVICE_BUSY;
    FsContext->irql = irql;
    if ( v8 && SLOBYTE(FsContext->field_40) >= 0 )
    {
      NtStatus = STATUS_NETWORK_OPEN_RESTRICTION|0x24;
      for ( i = (_QWORD *)FsContext->qword70; i != &FsContext->qword70; i = (_QWORD *)*i )
      {
        v11 = (__int64)i - 4;
        if ( MasterIrp == *((_DWORD *)i + 4) )
        {
          v12 = *(_QWORD **)(v11 + 12);
          v13 = *(_QWORD *)(v11 + 4);
          v14 = 0;
          *v12 = v13;
          *(_QWORD *)(v13 + 8) = v12;
          if ( *(_DWORD *)(v11 + 32) )
          {
            v15 = *(unsigned int *)(v11 + 32);
            v16 = (__int64 *)(v11 + 36);
            do
            {
              v17 = *v16;
              ++v16;
              v14 += *(_DWORD *)(v17 + 8);
              --v15;
            }
            while ( v15 );
          }
          LODWORD(FsContext->gap80) -= v14;
          ExFreePoolWithTag((PVOID)v11, 0);
          NtStatus = 0;
          break;
        }
      }
      NmDerefUserProc(FsContext);
    }
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    result = NtStatus;
  }
  return result;
}

//----- (000000000001252C) ----------------------------------------------------
NTSTATUS __fastcall NmFilterRootDeviceIoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  NTSTATUS NtStatus; // edi
  PIRP irp; // rsi
  _DEVICE_OBJECT *pDeviceObject; // rbx
  unsigned int Information; // ebp
  RootDeviceExtension *DeviceReservedExtension; // r12
  _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  NTSTATUS Status; // eax
  unsigned int infor; // [rsp+48h] [rbp+10h]

  NtStatus = 0;
  irp = Irp;
  pDeviceObject = DeviceObject;
  Information = 0;
  infor = 0;
  DeviceReservedExtension = GetFilterRootDevice(DeviceObject);
  TestFilterRootDeviceSignature(pDeviceObject);
  CurrentStackLocation = irp->Tail.Overlay.CurrentStackLocation;
  irp->IoStatus.Information = 0i64;
  if ( CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode == 0x21008A )
  {
    if ( DeviceReservedExtension->init == TRUE )
    {
      if ( irp->MdlAddress )
      {
        Status = NmEnumNetworks(irp, CurrentStackLocation, &infor);
        Information = infor;
        NtStatus = Status;
      }
      else
      {
        NtStatus = NDIS_STATUS_BUFFER_OVERFLOW;
      }
    }
    else
    {
      irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
      NtStatus = STATUS_INVALID_DEVICE_STATE;
    }
  }
  irp->IoStatus.Information = Information;
  irp->IoStatus.Status = NtStatus;
  IofCompleteRequest(irp, IO_NO_INCREMENT);
  return NtStatus;
}

//----- (00000000000125D4) ----------------------------------------------------
NTSTATUS __fastcall NmFilterRootDeviceIoClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  PIRP irp; // rdi
  _DEVICE_OBJECT *pDeviceObject; // rbx
  _IO_STACK_LOCATION *CurrentStackLocation; // rax

  irp = Irp;
  pDeviceObject = DeviceObject;
  GetFilterRootDevice(DeviceObject);
  TestFilterRootDeviceSignature(pDeviceObject);
  irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  CurrentStackLocation = irp->Tail.Overlay.CurrentStackLocation;
  irp->IoStatus.Information = 0i64;
  irp->IoStatus.Status = NDIS_STATUS_PENDING;
  CurrentStackLocation->Control &= 0xFEu;
  irp->IoStatus.Status = STATUS_INVALID_HANDLE;
  IofCompleteRequest(irp, IO_NETWORK_INCREMENT);
  return STATUS_INVALID_HANDLE;
}

//----- (000000000001263C) ----------------------------------------------------
NTSTATUS __fastcall NmFilterRootDeviceIoCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  PIRP irp; // rdi
  _DEVICE_OBJECT *pDeviceObject; // rbx
  _IO_STACK_LOCATION *CurrentStackLocation; // rax

  irp = Irp;
  pDeviceObject = DeviceObject;
  GetFilterRootDevice(DeviceObject);
  TestFilterRootDeviceSignature(pDeviceObject);
  irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  CurrentStackLocation = irp->Tail.Overlay.CurrentStackLocation;
  irp->IoStatus.Information = 0i64;
  irp->IoStatus.Status = NDIS_STATUS_PENDING;
  CurrentStackLocation->Control &= 0xFEu;
  irp->IoStatus.Status = NDIS_STATUS_SUCCESS;
  IofCompleteRequest(irp, IO_NETWORK_INCREMENT);
  return NDIS_STATUS_SUCCESS;
}

//----- (00000000000126A0) ----------------------------------------------------
RootDeviceExtension *__fastcall GetFilterRootDevice(PDEVICE_OBJECT DeviceObject)
{
  PDEVICE_OBJECT pDeviceObject; // rbx
  RootDeviceExtension *DeviceReservedExtension; // r11
  RootDeviceExtension *result; // rax

  pDeviceObject = DeviceObject;
  DeviceReservedExtension = (RootDeviceExtension *)NdisGetDeviceReservedExtension(DeviceObject);
  result = NULL;
  if ( &DeviceReservedExtension->FilterDeviceHandle < (_QWORD *)((char *)pDeviceObject + pDeviceObject->Size)
    && DeviceReservedExtension->ExtensionSize == 72
    && DeviceReservedExtension->tag == 'DFMN' )
  {
    result = DeviceReservedExtension;
  }
  return result;
}

//----- (00000000000126E4) ----------------------------------------------------
RootDeviceExtension *__fastcall TestFilterRootDeviceSignature(PDEVICE_OBJECT DeviceObject)
{
  PDEVICE_OBJECT pDeviceObject; // rbx
  RootDeviceExtension *DeviceReservedExtension; // rax

  pDeviceObject = DeviceObject;
  DeviceReservedExtension = (RootDeviceExtension *)NdisGetDeviceReservedExtension(DeviceObject);
  if ( &DeviceReservedExtension->FilterDeviceHandle >= (_QWORD *)((char *)pDeviceObject + pDeviceObject->Size)
    || DeviceReservedExtension->ExtensionSize != 72
    || DeviceReservedExtension->tag != 'DFMN' )
  {
    __debugbreak();
  }
  return DeviceReservedExtension;
}

//----- (0000000000012724) ----------------------------------------------------
NTSTATUS __fastcall NmAddGroupAccessAce(PDEVICE_OBJECT pDeviceObject)
{
  WORD AceCount; // r13
  PDEVICE_OBJECT DeviceObject; // rbx
  NTSTATUS NtStatus; // edi
  void *SecurityDescriptor_2; // rbp
  ACL *Dacl_1; // r12
  GroupAce *GroupAce; // rsi
  PACL dacl; // r15
  unsigned __int16 DataLength; // r14
  __int16 v9; // r14
  GroupAce *v10; // rax
  unsigned __int16 Length_1; // cx
  ULONG Length; // eax
  PVOID SecurityDescriptor_1; // rax
  PACL dacl_1; // rbx
  __int64 NumberOfBytes; // rdi
  ACL *acl; // rax
  ACL *Acl; // rsi
  unsigned int i; // edi
  GroupAce *v19; // rax
  GroupAce *v20; // rax
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+40h] [rbp-58h]
  BOOLEAN DaclDefaulted; // [rsp+A0h] [rbp+8h]
  BOOLEAN DaclPresent; // [rsp+A8h] [rbp+10h]
  HANDLE Handle; // [rsp+B0h] [rbp+18h]
  PACL Dacl; // [rsp+B8h] [rbp+20h]

  AceCount = NULL;
  DeviceObject = pDeviceObject;
  NtStatus = NULL;
  SecurityDescriptor_2 = NULL;
  Dacl_1 = NULL;
  Handle = NULL;
  if ( pDeviceObject && g_GroupAce )
  {
    NtStatus = ObOpenObjectByPointer(pDeviceObject, 0x200u, 0i64, 0x40000u, NULL, NULL, &Handle);
    if ( !NtStatus )
    {
      SecurityDescriptor = DeviceObject->SecurityDescriptor;
      NtStatus = RtlGetDaclSecurityDescriptor(DeviceObject->SecurityDescriptor, &DaclPresent, &Dacl, &DaclDefaulted);
      if ( !NtStatus )
      {
        GroupAce = g_GroupAce;
        dacl = Dacl;
        if ( g_GroupAce )
        {
          DataLength = g_GroupAce->DataLength;
          if ( DataLength >= 0xCu )
          {
            v9 = DataLength - 12;
            if ( Dacl->AceCount )
            {
              do
              {
                v10 = GetAceFromAcl(dacl, AceCount);
                if ( v10 )
                {
                  Length_1 = v10->DataLength - 12;
                  if ( Length_1 == v9 )
                  {
                    if ( Length_1 == RtlCompareMemory(&v10->DataOffset, &GroupAce->DataOffset, Length_1) )
                      goto LABEL_24;
                    GroupAce = g_GroupAce;
                  }
                }
                ++AceCount;
              }
              while ( AceCount < dacl->AceCount );
            }
          }
        }
        Length = RtlLengthSecurityDescriptor(SecurityDescriptor);
        SecurityDescriptor_1 = ExAllocatePool(NonPagedPool, Length + (unsigned __int16)g_GroupAce->DataLength);
        SecurityDescriptor_2 = SecurityDescriptor_1;
        if ( SecurityDescriptor_1 )
        {
          RtlCreateSecurityDescriptor(SecurityDescriptor_1, 1u);
          dacl_1 = Dacl;
          if ( Dacl )
          {
            NumberOfBytes = (unsigned __int16)(Dacl->AclSize + g_GroupAce->DataLength);
            acl = (ACL *)ExAllocatePool(NonPagedPool, (unsigned __int16)NumberOfBytes);
            Acl = acl;
            if ( acl )
            {
              *acl = *dacl_1;
              acl->AclSize = NumberOfBytes;
              acl->AceCount = NULL;
              for ( i = NULL; i < dacl_1->AceCount; ++i )
              {
                v19 = GetAceFromAcl(dacl_1, i);
                if ( v19->char0 != 1 )
                  break;
                AddAceToAcl(Acl, v19);
              }
              AddAceToAcl(Acl, g_GroupAce);
              for ( ; i < dacl_1->AceCount; ++i )
              {
                v20 = GetAceFromAcl(dacl_1, i);
                AddAceToAcl(Acl, v20);
              }
              Dacl_1 = Acl;
            }
          }
          NtStatus = RtlSetDaclSecurityDescriptor(SecurityDescriptor_2, 1u, Dacl_1, 0);
          if ( !NtStatus )
            NtStatus = ZwSetSecurityObject(Handle, 4u, SecurityDescriptor_2);
        }
      }
    }
LABEL_24:
    if ( Handle )
      ZwClose(Handle);
    if ( SecurityDescriptor_2 )
      ExFreePoolWithTag(SecurityDescriptor_2, 0);
    if ( Dacl_1 )
      ExFreePoolWithTag(Dacl_1, 0);
  }
  return NtStatus;
}

//----- (00000000000129DC) ----------------------------------------------------
GroupAce *__fastcall GetAceFromAcl(PACL Dacl, unsigned int a2)
{
  GroupAce *v2; // r8
  PACL v3; // r9
  unsigned __int16 i; // r10

  v2 = 0i64;
  if ( Dacl && a2 < Dacl->AceCount )
  {
    v3 = Dacl + 1;
    for ( i = 0; i < a2; v3 = (PACL)((char *)v3 + v3->AclSize) )
    {
      if ( v3 >= (PACL)((char *)Dacl + Dacl->AclSize) )
        break;
      ++i;
    }
    if ( i == a2 )
      v2 = (GroupAce *)v3;
  }
  return v2;
}

//----- (0000000000012A30) ----------------------------------------------------
char __fastcall AddAceToAcl(ACL *acl, GroupAce *GroupAce)
{
  ACL *v2; // rdi
  char v3; // bl
  ACL *v4; // rcx
  WORD i; // si
  __int64 DataLength; // r8

  v2 = acl;
  v3 = 1;
  if ( acl && GroupAce )
  {
    v4 = acl + 1;
    for ( i = 0; i < v2->AceCount; v4 = (ACL *)((char *)v4 + v4->AclSize) )
    {
      if ( v4 >= (ACL *)((char *)v2 + v2->AclSize) )
        break;
      ++i;
    }
    DataLength = (unsigned __int16)GroupAce->DataLength;
    if ( (char *)v4 + DataLength > (char *)v2 + v2->AclSize )
    {
      v3 = 0;
    }
    else
    {
      memmove(v4, GroupAce, DataLength);
      v2->AceCount = i + 1;
    }
  }
  return v3;
}

//----- (0000000000012AC4) ----------------------------------------------------
void __fastcall pNmDot11StoreCurrentIfc(__int64 a1, int a2)
{
  unsigned int v2; // edi
  int v3; // er12
  __int64 v4; // rsi
  __int64 v5; // rbp
  KIRQL v6; // al

  v2 = 0;
  v3 = a2;
  v4 = a1;
  if ( a1 && *(_DWORD *)(a1 + 164) > 0u )
  {
    v5 = a1 + 184;
    do
    {
      if ( *(_DWORD *)(*(_QWORD *)v5 + 20i64) == v3 )
      {
        v6 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v4 + 128));
        *(_BYTE *)(v4 + 136) = v6;
        *(_QWORD *)(v4 + 176) = *(_QWORD *)v5;
        KeReleaseSpinLock((PKSPIN_LOCK)(v4 + 128), v6);
      }
      ++v2;
      v5 += 8i64;
    }
    while ( v2 < *(_DWORD *)(v4 + 164) );
  }
}

//----- (0000000000012B60) ----------------------------------------------------
void __fastcall pNmDot11StoreOpMode(__int64 a1, int a2)
{
  __int64 v2; // rdi
  int v3; // esi
  KIRQL v4; // al

  if ( a1 )
  {
    v2 = a1;
    v3 = a2;
    v4 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(a1 + 128));
    *(_DWORD *)(v2 + 168) = v3;
    *(_BYTE *)(v2 + 136) = v4;
    KeReleaseSpinLock((PKSPIN_LOCK)(v2 + 128), v4);
  }
}

//----- (0000000000012BB4) ----------------------------------------------------
__int64 __fastcall pNmDot11QueryMonitorMode(__int64 a1)
{
  MACRO_BOOL b; // edi
  __int64 v2; // rsi
  KIRQL NewIrql; // al

  b = FALSE;
  v2 = a1;
  if ( a1 )
  {
    NewIrql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(a1 + 128));
    if ( *(_DWORD *)(v2 + 168) == 0x80000000 )
      b = TRUE;
    *(_BYTE *)(v2 + 136) = NewIrql;
    KeReleaseSpinLock((PKSPIN_LOCK)(v2 + 128), NewIrql);
  }
  return (unsigned int)b;
}

//----- (0000000000012C14) ----------------------------------------------------
__int64 __fastcall pNmDot11QueryCurrentIfc(FilterDeviceExtension *DeviceExtension)
{
  FilterDeviceExtension *DeviceExtension_1; // rbx
  __int64 v2; // rcx
  __int64 v4; // rax
  __int64 v5; // rdi
  unsigned int status; // eax
  __int64 v7; // rax
  __int64 v8; // [rsp+30h] [rbp-18h]
  __int64 a4; // [rsp+50h] [rbp+8h]
  unsigned int *a8; // [rsp+58h] [rbp+10h]

  DeviceExtension_1 = DeviceExtension;
  v2 = DeviceExtension->qword3B0;
  if ( !v2 )
    return 0i64;
  *(_BYTE *)(DeviceExtension_1->qword3B0 + 136i64) = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v2 + 128));
  v4 = DeviceExtension_1->qword3B0;
  v5 = *(_QWORD *)(v4 + 176);
  KeReleaseSpinLock((PKSPIN_LOCK)(v4 + 128), *(_BYTE *)(v4 + 136));
  if ( !v5 )
  {
    LODWORD(v8) = 0;
    status = nmFilterDoInternalRequest(0xE010192, DeviceExtension_1, 0, &a4, 4u, 0, v8, &a8);
    if ( status )
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "pNmDot11QueryCurrentIfc: status %x\n", status);
    else
      pNmDot11StoreCurrentIfc(DeviceExtension_1->qword3B0, a4);
    *(_BYTE *)(DeviceExtension_1->qword3B0 + 136i64) = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(DeviceExtension_1->qword3B0 + 128i64));
    v7 = DeviceExtension_1->qword3B0;
    v5 = *(_QWORD *)(v7 + 176);
    KeReleaseSpinLock((PKSPIN_LOCK)(v7 + 128), *(_BYTE *)(v7 + 136));
    if ( !v5 )
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "pNmDot11QueryCurrentIfc: none\n");
  }
  return v5;
}
// 12C9F: variable 'v8' is possibly undefined

//----- (0000000000012D3C) ----------------------------------------------------
void __fastcall NmDeleteDot11Parameters(PVOID VirtualAddress)
{
  unsigned int v1; // edi
  _DWORD *v2; // rbx
  PVOID *v3; // rsi

  v1 = 0;
  v2 = VirtualAddress;
  if ( VirtualAddress )
  {
    if ( *((_DWORD *)VirtualAddress + 41) > 0u )
    {
      v3 = (PVOID *)((char *)VirtualAddress + 184);
      do
      {
        NdisFreeMemory(*v3, 0, 0);
        ++v1;
        ++v3;
      }
      while ( v1 < v2[41] );
    }
    NdisFreeMemory(v2, 0, 0);
  }
}

//----- (0000000000012DA4) ----------------------------------------------------
__int64 __fastcall NmCreateDot11Filter(NDIS_HANDLE NdisHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameter, _QWORD *a3)
{
  __int64 result; // rax
  char *v4; // rsi
  _QWORD *v5; // r12
  FilterDeviceExtension *MiniportMediaSpecificAttributes; // rbx 这个肯定不是NDIS_HANDLE，而是个结构。
  unsigned int v7; // edi
  UINT Length; // edi
  char *v9; // rax
  unsigned int v10; // er14
  int v11; // eax
  __int64 v12; // r13
  _QWORD *v13; // r15
  int v14; // ebp
  int v15; // edi
  _DWORD *v16; // rax
  NDIS_HANDLE NdisHandlea; // [rsp+60h] [rbp+8h]
  _QWORD *v18; // [rsp+70h] [rbp+18h]

  v18 = a3;
  NdisHandlea = NdisHandle;
  result = 0i64;
  v4 = 0i64;
  v5 = a3;
  if ( AttachParameter->MiniportMediaType != 16 )
    goto LABEL_24;
  MiniportMediaSpecificAttributes = (FilterDeviceExtension *)AttachParameter->MiniportMediaSpecificAttributes;
  if ( !MiniportMediaSpecificAttributes
    || MiniportMediaSpecificAttributes->byte0 != 0xA1u
    || MiniportMediaSpecificAttributes->gap1[0] < 1u
    || MiniportMediaSpecificAttributes->word2 < 0x28u )
  {
    result = NDIS_STATUS_INVALID_PARAMETER;
    goto LABEL_27;
  }
  v7 = 8 * HIDWORD(MiniportMediaSpecificAttributes->char10);
  if ( v7 < (unsigned __int64)(v7 + 8) + 184 )
  {
    Length = v7 + 192;
    v9 = (char *)NdisAllocateMemoryWithTagPriority(NdisHandle, Length, 't3mN', LowPoolPriority);
    v4 = v9;
    if ( !v9 )
    {
      result = NDIS_STATUS_RESOURCES;
      goto LABEL_27;
    }
    memset(v9, 0, Length);
    v10 = 0;
    *((_DWORD *)v4 + 37) = MiniportMediaSpecificAttributes->gap4;
    *((_QWORD *)v4 + 19) = MiniportMediaSpecificAttributes->tag;
    v4[160] = MiniportMediaSpecificAttributes->char10;
    v11 = HIDWORD(MiniportMediaSpecificAttributes->char10);
    *((_DWORD *)v4 + 41) = v11;
    if ( v11 )
    {
      v12 = 0i64;
      v13 = v4 + 184;
      do
      {
        v14 = *(_DWORD *)(v12 + MiniportMediaSpecificAttributes->qword18 + 4);
        if ( v14 == 4 )
        {
          v15 = 218170178;
        }
        else if ( v14 != 6 && v14 != 5 )
        {
          v15 = -1;
          if ( v14 == 7 )
            v15 = 0xD010335;
        }
        else
        {
          v15 = 0xD010335;
        }
        v16 = NdisAllocateMemoryWithTagPriority(NdisHandlea, 0x468u, 't3mN', LowPoolPriority);// 又是个结构？
        if ( v16 )
        {
          *v13 = v16;
          v16[5] = v10;
          v16[6] = v14;
          v16[280] = v15;
          *((_WORD *)v16 + 8) = 1128;
          memmove(v16 + 7, (const void *)(v12 + MiniportMediaSpecificAttributes->qword18), 0x444u);
        }
        ++v10;
        ++v13;
        v12 += 1092i64;
      }
      while ( v10 < *((_DWORD *)v4 + 41) );
      v5 = v18;
    }
    result = 0i64;
    *((_QWORD *)v4 + 16) = 0i64;
LABEL_24:
    *v5 = v4;
    return result;
  }
  result = NDIS_STATUS_BUFFER_OVERFLOW;
LABEL_27:
  *v5 = 0i64;
  return result;
}

//----- (0000000000012F84) ----------------------------------------------------
__int64 __fastcall NmDot11SetPhyId(FilterDeviceExtension *DeviceExtension, unsigned int a2)
{
  FilterDeviceExtension *DeviceExtension_1; // rdi
  __int64 v4; // rbx
  unsigned int status_1; // eax
  unsigned int status; // eax
  unsigned int NtStatus; // edi
  __int64 v8; // [rsp+30h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-28h]
  __int64 a4; // [rsp+40h] [rbp-18h]
  char v11[5]; // [rsp+48h] [rbp-10h]
  __int16 v12; // [rsp+4Dh] [rbp-Bh]
  char v13; // [rsp+4Fh] [rbp-9h]
  unsigned int *a8; // [rsp+60h] [rbp+8h]
  __int64 Information; // [rsp+68h] [rbp+10h]

  LODWORD(Information) = a2;
  DeviceExtension_1 = DeviceExtension;
  LOBYTE(a4) = 0;
  *(__int64 *)((char *)&a4 + 1) = 0i64;
  *(_DWORD *)&v11[1] = 0;
  v12 = 0;
  v13 = 0;
  if ( !DeviceExtension )
    return NDIS_STATUS_INVALID_PARAMETER;
  v4 = DeviceExtension->qword3B0;
  if ( !v4 )
    return 0xC0235001i64;
  if ( !(unsigned int)pNmDot11QueryMonitorMode(DeviceExtension->qword3B0) )
    return 0xC0235002i64;
  *(_DWORD *)&v11[4] = Information;
  LODWORD(v8) = 0;
  a4 = 0x100100180i64;
  *(_DWORD *)v11 = 1;
  status_1 = nmFilterDoInternalRequest(0xE010191, DeviceExtension_1, 1, &a4, 0x10u, 0, v8, &a8);
  if ( status_1 )
    DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmSetDot11PhyType: Attempted set DESIRED_PHY_LIST, status %x\n", status_1);
  LODWORD(v9) = 0;
  status = nmFilterDoInternalRequest(0xE010192, DeviceExtension_1, 1, &Information, 4u, 0, v9, &a8);
  NtStatus = status;
  if ( status )
    DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmSetDot11PhyType: Attempted set CURRENT_PHY_ID, status %x\n", status);
  else
    pNmDot11StoreCurrentIfc(v4, Information);
  return NtStatus;
}
// 1303E: variable 'v8' is possibly undefined
// 1308B: variable 'v9' is possibly undefined

//----- (00000000000130CC) ----------------------------------------------------
__int64 __fastcall NmDot11SetChannel(FilterDeviceExtension *DeviceExtension, unsigned int channel_1)
{
  FilterDeviceExtension *DeviceExtension_1; // rbx
  __int64 v3; // rcx
  __int64 result; // rax
  __int64 v5; // rdi
  NDIS_STATUS v6; // eax
  unsigned int v7; // ebx
  __int64 oid; // [rsp+20h] [rbp-28h]
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  unsigned int *a8; // [rsp+50h] [rbp+8h]
  __int64 channel; // [rsp+58h] [rbp+10h]

  LODWORD(channel) = channel_1;
  DeviceExtension_1 = DeviceExtension;
  v3 = DeviceExtension->qword3B0;
  if ( !v3 )
    return 0xC0235001i64;
  if ( !(unsigned int)pNmDot11QueryMonitorMode(v3) )
    return 0xC0235002i64;
  result = pNmDot11QueryCurrentIfc(DeviceExtension_1);
  v5 = result;
  if ( result )
  {
    LODWORD(v10) = 0;
    v6 = nmFilterDoInternalRequest(*(_DWORD *)(result + 1120), DeviceExtension_1, 1, &channel, 4u, 0, v10, &a8);
    v7 = v6;
    if ( v6 )
    {
      LODWORD(v9) = v6;
      LODWORD(oid) = *(_DWORD *)(v5 + 1120);
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmDot11SetChannel: set channel %x, oid %x, status %x\n", (unsigned int)channel, oid, v9);
    }
    result = v7;
  }
  return result;
}
// 13143: variable 'v10' is possibly undefined
// 1316D: variable 'oid' is possibly undefined
// 1316D: variable 'v9' is possibly undefined

//----- (0000000000013188) ----------------------------------------------------
void __fastcall NetmonUnload(struct _DRIVER_OBJECT *DriverObject)
{
  if ( g_GroupAce )
  {
    ExFreePoolWithTag(g_GroupAce, 0);
    g_GroupAce = NULL;
  }
  if ( g_FilterDeviceHandle )
    NdisDeregisterDeviceEx(g_FilterDeviceHandle);
  g_FilterDeviceHandle = NULL;
  NdisFDeregisterFilterDriver(g_FilterDriverHandle);
}

//----- (00000000000131DC) ----------------------------------------------------
NDIS_STATUS __fastcall NmSetPacketFilter(FilterDeviceExtension *ModuleContext, int filter)
{
  __int64 v3; // [rsp+30h] [rbp-18h]
  __int64 a4; // [rsp+58h] [rbp+10h]
  unsigned int *a8; // [rsp+60h] [rbp+18h]

  LODWORD(a4) = filter;
  LODWORD(v3) = 0;
  return nmFilterDoInternalRequest(65806, ModuleContext, 1, &a4, 4u, 0, v3, &a8);
}
// 13213: variable 'v3' is possibly undefined

//----- (0000000000013224) ----------------------------------------------------
__int64 __fastcall NmQueryPacketFilter(FilterDeviceExtension *ModuleContext, __int64 filter)
{
  unsigned int *v2; // rdi
  NDIS_STATUS Status; // eax
  unsigned int NtStatus; // ebx
  __int64 InformationBufferLength; // [rsp+20h] [rbp-28h]
  __int64 v7; // [rsp+30h] [rbp-18h]
  unsigned int *a8; // [rsp+60h] [rbp+18h]

  v2 = (unsigned int *)filter;
  LODWORD(v7) = 0;
  Status = nmFilterDoInternalRequest(0x1010E, ModuleContext, 0, (__int64 *)filter, 4u, 0, v7, &a8);
  NtStatus = Status;
  if ( g_NmDebug )
  {
    LODWORD(InformationBufferLength) = Status;
    DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmQPacketFilter: Attempted to Q %x, status %x\n", *v2, InformationBufferLength);
  }
  return NtStatus;
}
// 1325B: variable 'v7' is possibly undefined
// 1327E: variable 'InformationBufferLength' is possibly undefined
// 1919C: using guessed type int g_NmDebug;

//----- (0000000000013298) ----------------------------------------------------
_BOOL8 __fastcall NmSetAppropriatePacketFilter(FilterDeviceExtension *DeviceExtension, int a2)
{
  int v2; // edi
  FilterDeviceExtension *DeviceExtension_1; // rbx
  KIRQL irql; // al
  KIRQL irql_1; // dl
  int v6; // eax
  int v7; // esi
  int v8; // ebp
  int filter; // edi
  BOOL b; // er12
  KIRQL irql_2; // al

  v2 = a2;
  DeviceExtension_1 = DeviceExtension;
  _InterlockedAdd(&DeviceExtension->field_210, 1u);
  irql = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->SpinLock);
  irql_1 = irql;
  DeviceExtension_1->irql = irql;
  v6 = DeviceExtension_1->dword21C;
  if ( v2 <= 0 )
  {
    if ( v2 < 0 )
      DeviceExtension_1->dword21C = v6 - 1;
  }
  else
  {
    DeviceExtension_1->dword21C = v6 + 1;
  }
  v7 = DeviceExtension_1->dword21C;
  v8 = DeviceExtension_1->dword220;
  filter = DeviceExtension_1->filter;
  b = (v6 == 0) != (v7 == 0);
  KeReleaseSpinLock(&DeviceExtension_1->SpinLock, irql_1);
  if ( b )
  {
    if ( DeviceExtension_1->qword3B0 )
    {
      if ( v7 > 0 )
        filter = 0x3FF002F;
      goto LABEL_18;
    }
    if ( !v7 )
      goto LABEL_24;
    if ( v8 || LOBYTE(DeviceExtension_1->gap224) )
    {
      filter = 32;
      goto LABEL_18;
    }
    if ( !BYTE4(DeviceExtension_1->field_234) || BYTE5(DeviceExtension_1->field_234) )
      filter = 128;
    else
LABEL_24:
      filter = DeviceExtension_1->filter;
LABEL_18:
    irql_2 = KeAcquireSpinLockRaiseToDpc(&DeviceExtension_1->SpinLock);
    HIDWORD(DeviceExtension_1->filter) = filter;
    DeviceExtension_1->irql = irql_2;
    KeReleaseSpinLock(&DeviceExtension_1->SpinLock, irql_2);
    NmSetPacketFilter(DeviceExtension_1, filter);
  }
  if ( _InterlockedExchangeAdd(&DeviceExtension_1->field_210, 0xFFFFFFFF) == 1 )
    NmDestroyFilterModule(DeviceExtension_1);
  return b;
}

//----- (00000000000133E8) ----------------------------------------------------
__int64 __fastcall CopyUnicodeStringToBuffer(void *a1, unsigned __int64 a2, _DWORD *a3, const void **a4)
{
  MACRO_NDIS_MEMORY NtStatus; // ebx
  const void **v5; // rdi
  _DWORD *v6; // rsi
  unsigned __int64 v7; // r8

  NtStatus = STATUS_SUCCESS;
  v5 = a4;
  v6 = a3;
  if ( a1 )
  {
    v7 = *(unsigned __int16 *)a4;
    if ( v7 <= a2 )
    {
      memmove(a1, a4[1], v7);
      *v6 = *(unsigned __int16 *)v5;
    }
    else
    {
      NtStatus = NDIS_STATUS_BUFFER_OVERFLOW;
    }
  }
  else
  {
    NtStatus = NDIS_STATUS_INVALID_PARAMETER;
  }
  return NtStatus;
}

//----- (0000000000013444) ----------------------------------------------------
NTSTATUS __fastcall NmEnumNetworks(PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation, size_t *Information)
{
  PMDL MdlAddress; // r9
  ULONG OutputBufferLength; // eax
  unsigned int i; // er15
  size_t Length; // er12
  size_t *Infor; // rsi
  _IO_STACK_LOCATION *CurrentStackLocation_1; // rdi
  PIRP Irp_1; // rbp
  unsigned int j; // ebx
  KIRQL irql; // al
  _LIST_ENTRY *FilterModuleList; // rdx
  KIRQL Irql; // r11
  int v15; // eax
  _LIST_ENTRY *v16; // r8
  __int64 v17; // rax
  _LIST_ENTRY **v18; // r8
  __int64 v19; // r9
  _LIST_ENTRY *v20; // rax
  PMDL MdlAddress_3; // rbx
  bool b; // zf
  PVOID MappedSystemVa_2; // rax
  NTSTATUS NtStatus; // ebx
  _DWORD *v25; // rax
  _DWORD *v26; // r14
  __int64 v27; // rax
  _DWORD *v28; // r13
  _WORD *v29; // r14
  unsigned __int64 v30; // rsi
  char *v31; // rbp
  KIRQL Irql_1; // al
  _LIST_ENTRY *FilterModuleList_1; // rdi
  __int64 v34; // rbx
  int v35; // eax
  const void **v36; // r9
  unsigned int v37; // ecx
  MACRO_NDIS_MEMORY NtStatus_2; // eax
  unsigned int v39; // ecx
  MACRO_NDIS_MEMORY NtStatus_1; // eax
  unsigned int v41; // ecx
  MACRO_NDIS_MEMORY status; // eax
  unsigned int v43; // ecx
  MACRO_NDIS_MEMORY Status; // eax
  _LIST_ENTRY *v45; // rax
  __int64 v46; // r13
  unsigned __int16 *v47; // rdx
  unsigned __int64 v48; // r12
  PMDL MdlAddress_1; // rbx
  PVOID MappedSystemVa; // rax
  _DWORD *v51; // [rsp+30h] [rbp-58h]
  PMDL MdlAddress_2; // [rsp+38h] [rbp-50h]
  PVOID MappedSystemVa_1; // [rsp+40h] [rbp-48h]
  ULONG ByteOffset; // [rsp+48h] [rbp-40h]
  ULONG ByteCount; // [rsp+4Ch] [rbp-3Ch]
  PIRP irp; // [rsp+90h] [rbp+8h]
  unsigned int a4; // [rsp+98h] [rbp+10h]
  size_t Length_2; // [rsp+A8h] [rbp+20h]

  irp = Irp;
  MdlAddress = Irp->MdlAddress;
  OutputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.OutputBufferLength;
  i = 0;
  Length = 4;
  Infor = Information;
  CurrentStackLocation_1 = CurrentStackLocation;
  Irp_1 = Irp;
  j = 0;
  Length_2 = 4;
  if ( MdlAddress->ByteCount != OutputBufferLength )
    return NDIS_STATUS_BUFFER_OVERFLOW;
  irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
  FilterModuleList = g_FilterModuleList.Flink;
  Irql = irql;
  g_Irql = irql;
  if ( g_FilterModuleList.Flink != &g_FilterModuleList )
  {
    do
    {
      v15 = (int)FilterModuleList[31].Blink;
      if ( v15 != 5 && v15 != 6 && v15 )
      {
        v16 = FilterModuleList[58].Flink;
        Length += (size_t)((char *)&FilterModuleList[21].Flink->Flink[13]
                         + LOWORD(FilterModuleList[18].Flink)
                         + LOWORD(FilterModuleList[17].Flink)
                         + LOWORD(FilterModuleList[16].Flink));
        if ( v16 )
        {
          v17 = HIDWORD(v16[10].Flink);
          if ( (unsigned int)v17 > 0 )
          {
            v18 = &v16[11].Blink;
            v19 = v17;
            do
            {
              v20 = *v18;
              ++v18;
              Length += LOWORD(v20[1].Flink);
              --v19;
            }
            while ( v19 );
          }
        }
        ++j;
      }
      FilterModuleList = FilterModuleList->Flink;
    }
    while ( FilterModuleList != &g_FilterModuleList );
    Length_2 = Length;
  }
  KeReleaseSpinLock(&g_FilterListLock, Irql);
  *Infor = Length;
  if ( CurrentStackLocation_1->Parameters.DeviceIoControl.OutputBufferLength >= Length )
  {
    v25 = ExAllocatePoolWithTag(NonPagedPool, Length, ' 3MN');
    v26 = v25;
    if ( !v25 )
      return NDIS_STATUS_RESOURCES;
    memset(v25, 0, Length);
    *v26 = 0;
    v27 = 104i64 * j;
    v28 = v26;
    v51 = v26;
    v29 = v26 + 1;
    v30 = Length - v27 * 2 - 4;
    v31 = (char *)&v29[v27];
    Irql_1 = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    FilterModuleList_1 = g_FilterModuleList.Flink;
    g_Irql = Irql_1;
    if ( g_FilterModuleList.Flink != &g_FilterModuleList )
    {
      v34 = (__int64)(v29 + 5);
      do
      {
        v35 = (int)FilterModuleList_1[31].Blink;
        if ( v35 != 5 && v35 != 6 && v35 )
        {
          *v29 = 208;
          *(_DWORD *)(v34 - 6) = FilterModuleList_1[53].Blink;
          *(_WORD *)(v34 - 2) = WORD2(FilterModuleList_1[53].Blink);
          *(_DWORD *)v34 = FilterModuleList_1[55].Blink;
          *(_WORD *)(v34 + 4) = WORD2(FilterModuleList_1[55].Blink);
          *(_DWORD *)(v34 + 102) = HIDWORD(FilterModuleList_1[19].Flink);
          *(_QWORD *)(v34 + 110) = FilterModuleList_1[19].Blink;
          *(_DWORD *)(v34 + 118) = FilterModuleList_1[20].Blink;
          *(_QWORD *)(v34 + 126) = FilterModuleList_1[27].Blink;
          *(_DWORD *)(v34 + 134) = FilterModuleList_1[28].Flink;
          *(_QWORD *)(v34 + 142) = FilterModuleList_1[28].Blink;
          *(_WORD *)(v34 - 8) = 1857;
          if ( LODWORD(FilterModuleList_1[23].Blink) == 3 )
          {
            *(_QWORD *)(v34 + 6) = 0i64;
            *(_QWORD *)(v34 + 14) = 0i64;
          }
          else
          {
            *(_QWORD *)(v34 + 6) = FilterModuleList_1[22].Blink;
            *(_QWORD *)(v34 + 14) = FilterModuleList_1[23].Flink;
          }
          *(_DWORD *)(v34 + 22) = FilterModuleList_1[23].Blink;
          *(_DWORD *)(v34 + 26) = HIDWORD(FilterModuleList_1[23].Blink);
          if ( LOBYTE(FilterModuleList_1[34].Blink) )
            *(_DWORD *)(v34 + 34) |= 0x10u;
          if ( BYTE4(FilterModuleList_1[33].Flink) )
            *(_DWORD *)(v34 + 34) |= 0x8000u;
          v36 = (const void **)&FilterModuleList_1[21].Flink->Flink;
          v37 = 0;
          a4 = 0;
          if ( v36 )
          {
            NtStatus_2 = (unsigned int)CopyUnicodeStringToBuffer(v31, v30, &a4, v36);
            v37 = a4;
          }
          else
          {
            NtStatus_2 = NDIS_STATUS_INVALID_PARAMETER;
          }
          if ( NtStatus_2 == NDIS_STATUS_SUCCESS )
          {
            *(_DWORD *)(v34 + 38) = v37;
            v31 += v37;
            v30 -= v37;
          }
          v39 = 0;
          a4 = 0;
          if ( FilterModuleList_1 == (_LIST_ENTRY *)-256i64 )
          {
            NtStatus_1 = NDIS_STATUS_INVALID_PARAMETER;
          }
          else
          {
            NtStatus_1 = (unsigned int)CopyUnicodeStringToBuffer(v31, v30, &a4, (const void **)&FilterModuleList_1[16].Flink);
            v39 = a4;
          }
          if ( NtStatus_1 == NDIS_STATUS_SUCCESS )
          {
            *(_DWORD *)(v34 + 54) = v39;
            v31 += v39;
            v30 -= v39;
          }
          v41 = 0;
          a4 = 0;
          if ( FilterModuleList_1 == (_LIST_ENTRY *)0xFFFFFFFFFFFFFEF0i64 )
          {
            status = NDIS_STATUS_INVALID_PARAMETER;
          }
          else
          {
            status = (unsigned int)CopyUnicodeStringToBuffer(v31, v30, &a4, (const void **)&FilterModuleList_1[0x11].Flink);
            v41 = a4;
          }
          if ( status == NDIS_STATUS_SUCCESS )
          {
            *(_DWORD *)(v34 + 70) = v41;
            v31 += v41;
            v30 -= v41;
          }
          v43 = 0;
          a4 = 0;
          if ( FilterModuleList_1 == (_LIST_ENTRY *)0xFFFFFFFFFFFFFEE0i64 )
          {
            Status = NDIS_STATUS_INVALID_PARAMETER;
          }
          else
          {
            Status = (unsigned int)CopyUnicodeStringToBuffer(v31, v30, &a4, (const void **)&FilterModuleList_1[0x12].Flink);
            v43 = a4;
          }
          if ( Status == NDIS_STATUS_SUCCESS )
          {
            *(_DWORD *)(v34 + 86) = v43;
            v31 += v43;
            v30 -= v43;
          }
          if ( FilterModuleList_1[58].Flink )
          {
            *(_DWORD *)(v34 + 150) = HIDWORD(FilterModuleList_1[58].Flink[9].Flink);
            *(_DWORD *)(v34 + 154) = FilterModuleList_1[58].Flink[9].Blink;
            *(_DWORD *)(v34 + 158) = HIDWORD(FilterModuleList_1[58].Flink[9].Blink);
            *(_BYTE *)(v34 + 162) = FilterModuleList_1[58].Flink[10].Flink;
            *(_DWORD *)(v34 + 166) = HIDWORD(FilterModuleList_1[58].Flink[10].Flink);
            v45 = FilterModuleList_1[58].Flink;
            if ( HIDWORD(v45[10].Flink) )
            {
              v46 = 184i64;
              do
              {
                v47 = *(unsigned __int16 **)((char *)&v45->Flink + v46);
                v48 = v47[8];
                if ( v30 >= v48 )
                {
                  memmove(v31, v47, v47[8]);
                  v31 += v48;
                  v30 -= v48;
                }
                v45 = FilterModuleList_1[58].Flink;
                ++i;
                v46 += 8i64;
              }
              while ( i < HIDWORD(v45[10].Flink) );
              v28 = v51;
            }
            i = 0;
          }
          v29 += 104;
          v34 += 208i64;
          ++*v28;
        }
        FilterModuleList_1 = FilterModuleList_1->Flink;
      }
      while ( FilterModuleList_1 != &g_FilterModuleList );
      Irql_1 = g_Irql;
      Length = Length_2;
    }
    KeReleaseSpinLock(&g_FilterListLock, Irql_1);
    MdlAddress_1 = irp->MdlAddress;
    MdlAddress_2 = MdlAddress_1;
    if ( MdlAddress_1 )
    {
      if ( MdlAddress_1->MdlFlags & 5 )
        MappedSystemVa = MdlAddress_1->MappedSystemVa;
      else
        MappedSystemVa = MmMapLockedPagesSpecifyCache(MdlAddress_1, 0, MmCached, 0i64, 0, NormalPagePriority);
      MappedSystemVa_1 = MappedSystemVa;
      ByteOffset = MdlAddress_1->ByteOffset;
      ByteCount = MdlAddress_1->ByteCount;
    }
    else
    {
      MappedSystemVa_1 = 0i64;
      ByteOffset = 0;
      ByteCount = 0;
    }
    NtStatus = NmCopyBufferToMdlWrapper(&MdlAddress_2, v28, Length, &a4);
    ExFreePoolWithTag(v28, 0);
  }
  else
  {
    if ( CurrentStackLocation_1->Parameters.DeviceIoControl.OutputBufferLength == 4 )
    {
      MdlAddress_3 = Irp_1->MdlAddress;
      if ( MdlAddress_3 )
      {
        b = (MdlAddress_3->MdlFlags & 5) == 0;
        MdlAddress_2 = Irp_1->MdlAddress;
        if ( b )
          MappedSystemVa_2 = MmMapLockedPagesSpecifyCache(MdlAddress_3, 0, MmCached, 0i64, 0, NormalPagePriority);
        else
          MappedSystemVa_2 = MdlAddress_3->MappedSystemVa;
        MappedSystemVa_1 = MappedSystemVa_2;
        ByteOffset = MdlAddress_3->ByteOffset;
        ByteCount = MdlAddress_3->ByteCount;
        NmCopyBufferToMdlWrapper(&MdlAddress_2, &g_NmDriverVersion, 4u, &a4);
      }
    }
    NtStatus = NDIS_STATUS_BUFFER_OVERFLOW;
  }
  return NtStatus;
}

//----- (0000000000013A24) ----------------------------------------------------
__int64 __fastcall NmCopyBufferToMdlWrapper(PMDL *MdlAddress, const void *a2, unsigned int a3, _DWORD *a4)
{
  MACRO_STATUS_CLUSTER NtStatus; // ebp
  _DWORD *v5; // r15
  unsigned int size; // er14
  const void *v7; // rax
  PMDL *pmdl; // r12
  PMDL mdl; // r13
  PMDL mdl_1; // rbx
  __int64 Size; // rsi
  _MDL *MemoryDescriptorList; // rcx
  _MDL *mdl_2; // rax
  ULONG ByteOffset; // eax
  ULONG v15; // eax
  const void *v17; // [rsp+68h] [rbp+10h]

  v17 = a2;
  NtStatus = 0;
  v5 = a4;
  size = a3;
  v7 = a2;
  pmdl = MdlAddress;
  *a4 = 0;
  if ( !MdlAddress )
    goto LABEL_25;
  mdl = *MdlAddress;
  if ( !*MdlAddress )
    return NDIS_STATUS_BUFFER_OVERFLOW;
  if ( MdlAddress[1] )
  {
    if ( a3 )
    {
      do
      {
        if ( !mdl )
          break;
        mdl_1 = pmdl[1];
        Size = size;
        if ( *((_DWORD *)pmdl + 5) < size )
          Size = *((unsigned int *)pmdl + 5);
        memmove(pmdl[1], v7, Size);
        *((_DWORD *)pmdl + 4) += Size;
        *((_DWORD *)pmdl + 5) -= Size;
        *v5 += Size;
        size -= Size;
        pmdl[1] = (PMDL)((char *)mdl_1 + Size);
        if ( !*((_DWORD *)pmdl + 5) )
        {
          MemoryDescriptorList = mdl->Next;
          *pmdl = mdl->Next;
          if ( MemoryDescriptorList )
          {
            if ( MemoryDescriptorList->MdlFlags & 5 )
              mdl_2 = (_MDL *)MemoryDescriptorList->MappedSystemVa;
            else
              mdl_2 = (_MDL *)MmMapLockedPagesSpecifyCache(MemoryDescriptorList, 0, MmCached, 0i64, 0u, NormalPagePriority);
          }
          else
          {
            mdl_2 = 0i64;
          }
          mdl = *pmdl;
          pmdl[1] = mdl_2;
          ByteOffset = 0;
          if ( mdl )
            ByteOffset = mdl->ByteOffset;
          *((_DWORD *)pmdl + 4) = ByteOffset;
          v15 = 0;
          if ( mdl )
            v15 = mdl->ByteCount;
          *((_DWORD *)pmdl + 5) = v15;
        }
        v7 = v17;
      }
      while ( size );
    }
  }
  else
  {
LABEL_25:
    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
  }
  return NtStatus;
}

//----- (0000000000013B64) ----------------------------------------------------
__int64 __fastcall NmInitializeGlobals(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  struct _DRIVER_OBJECT *pDriverObject; // rdi
  KEY_VALUE_FULL_INFORMATION *KeyValueInformation_1; // rbx
  NTSTATUS NtStatus; // eax
  GroupAce *GroupAce; // rax
  __int16 DataLength; // cx
  NTSTATUS Status; // eax
  int AttachUpperLayers; // eax
  NTSTATUS NtStatus_1; // eax
  NTSTATUS NtStatus_2; // eax
  NTSTATUS NtStatus_3; // eax
  __int64 result; // rax
  ULONG Length; // [rsp+30h] [rbp-98h]
  HANDLE KeyHandle; // [rsp+38h] [rbp-90h]
  UNICODE_STRING DestinationString; // [rsp+40h] [rbp-88h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+50h] [rbp-78h]
  KEY_VALUE_FULL_INFORMATION KeyValueInformation; // [rsp+80h] [rbp-48h]

  ObjectAttributes.Length = 0x30;
  pDriverObject = DriverObject;
  ObjectAttributes.RootDirectory = NULL;
  ObjectAttributes.Attributes = OBJ_CASE_INSENSITIVE;
  ObjectAttributes.ObjectName = RegistryPath;
  KeyValueInformation_1 = NULL;
  KeyHandle = NULL;
  Length = 24;
  ObjectAttributes.SecurityDescriptor = NULL;
  ObjectAttributes.SecurityQualityOfService = NULL;
  if ( !ZwOpenKey(&KeyHandle, KEY_READ, &ObjectAttributes) )
  {
    RtlInitUnicodeString(&DestinationString, L"GroupSid");
    NtStatus = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
    if ( NtStatus == NDIS_STATUS_BUFFER_OVERFLOW || NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
      KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
      if ( KeyValueInformation_1 )
      {
        if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length) )
        {
          GroupAce = (GroupAce *)ExAllocatePoolWithTag(NonPagedPool, KeyValueInformation_1->DataLength + 12i64, 'gamn');
          g_GroupAce = GroupAce;
          if ( GroupAce )
          {                                     // GroupAce肯定是一个结构。
            GroupAce->char0 = NULL;
            GroupAce->byte1 = NULL;
            DataLength = LOWORD(KeyValueInformation_1->DataLength) + 12;
            GroupAce->dword4 = 0x120089;
            GroupAce->DataLength = DataLength;
            memmove(&GroupAce->DataOffset, (char *)KeyValueInformation_1 + KeyValueInformation_1->DataOffset, KeyValueInformation_1->DataLength);
            ExFreePoolWithTag(KeyValueInformation_1, 0);
            KeyValueInformation_1 = NULL;
            Length = 24;
            RtlInitUnicodeString(&DestinationString, L"LoadUpperLayers");
            Status = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
            if ( Status == NDIS_STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL )
            {
              KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
              if ( KeyValueInformation_1 )
              {
                if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length)
                  && KeyValueInformation_1->DataLength )
                {
                  AttachUpperLayers = g_AttachUpperLayers;
                  if ( *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset) > NULL )
                    AttachUpperLayers = *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset);
                  g_AttachUpperLayers = AttachUpperLayers;
                }
                ExFreePoolWithTag(KeyValueInformation_1, 0);
                KeyValueInformation_1 = NULL;
              }
            }
            Length = 24;
            RtlInitUnicodeString(&DestinationString, L"TimeStampSyncIntervalCount");
            NtStatus_1 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
            if ( NtStatus_1 == NDIS_STATUS_BUFFER_OVERFLOW || NtStatus_1 == STATUS_BUFFER_TOO_SMALL )
              KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
            if ( KeyValueInformation_1 )
            {
              if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length)
                && KeyValueInformation_1->DataLength == 4
                && KeyValueInformation_1->DataOffset )
              {
                g_TimeSyncIntervalCount = *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset);
              }
              ExFreePoolWithTag(KeyValueInformation_1, 0);
              KeyValueInformation_1 = NULL;
            }
            Length = 24;
            RtlInitUnicodeString(&DestinationString, L"TimerIntervalMS");
            NtStatus_2 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
            if ( NtStatus_2 == NDIS_STATUS_BUFFER_OVERFLOW || NtStatus_2 == STATUS_BUFFER_TOO_SMALL )
              KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
            if ( KeyValueInformation_1 )
            {
              if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length)
                && KeyValueInformation_1->DataLength == 4
                && KeyValueInformation_1->DataOffset )
              {
                g_FilterScanTimerInterval = *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset);
              }
              ExFreePoolWithTag(KeyValueInformation_1, 0);
              KeyValueInformation_1 = NULL;
            }
            Length = 24;
            RtlInitUnicodeString(&DestinationString, L"OlpFilterConditionMaxCount");
            NtStatus_3 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, &KeyValueInformation, Length, &Length);
            if ( NtStatus_3 == NDIS_STATUS_BUFFER_OVERFLOW || NtStatus_3 == STATUS_BUFFER_TOO_SMALL )
              KeyValueInformation_1 = (KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(NonPagedPool, Length);
            if ( KeyValueInformation_1 )
            {
              if ( !ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, KeyValueInformation_1, Length, &Length)
                && KeyValueInformation_1->DataLength == 4
                && KeyValueInformation_1->DataOffset )
              {
                g_OlpFilterConditionMaxCount = *(ULONG *)((char *)&KeyValueInformation_1->TitleIndex + KeyValueInformation_1->DataOffset);
              }
              ExFreePoolWithTag(KeyValueInformation_1, 0);
              KeyValueInformation_1 = NULL;
            }
          }
        }
      }
    }
  }
  if ( KeyHandle )
    ZwClose(KeyHandle);
  if ( KeyValueInformation_1 )
    ExFreePoolWithTag(KeyValueInformation_1, 0);
  g_FilterListLock = NULL;
  g_FilterDriverObject = pDriverObject;
  g_FilterModuleList.Blink = &g_FilterModuleList;
  g_FilterModuleList.Flink = &g_FilterModuleList;
  g_ByPassFilterModuleList.Blink = &g_ByPassFilterModuleList;
  g_ByPassFilterModuleList.Flink = &g_ByPassFilterModuleList;
  result = MEMORY[0xFFFFF78000000014];
  g_InternalRequestFailedCount = NULL;
  g_DriverStartTimeStamp = MEMORY[0xFFFFF78000000014];
  return result;
}
// 19120: using guessed type int g_TimeSyncIntervalCount;
// 19124: using guessed type int g_FilterScanTimerInterval;
// 19128: using guessed type int g_OlpFilterConditionMaxCount;
// 19198: using guessed type int g_AttachUpperLayers;
// 191A0: using guessed type __int64 g_DriverStartTimeStamp;
// 191A8: using guessed type int g_InternalRequestFailedCount;

//----- (000000000001406C) ----------------------------------------------------
__int64 __fastcall LookupFilterModule(NDIS_HANDLE NdisFilterHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters, FilterDeviceExtension **DeferredContext)
{
  PNDIS_STRING FilterModuleGuidName; // rbp
  NDIS_HANDLE FilterHandle; // r13
  FilterDeviceExtension **Context; // r14
  MACRO_NDIS_MEMORY NtStatus; // er12
  KIRQL irql; // al
  _LIST_ENTRY *FilterModuleList; // rdi
  SIZE_T Length_1; // rsi
  FilterDeviceExtension *temp; // rbx
  _LIST_ENTRY *v11; // rcx
  KIRQL Irql; // al
  _LIST_ENTRY *ByPassFilterModuleList; // rdi
  SIZE_T Length; // rsi
  _LIST_ENTRY *v15; // rcx
  KIRQL irql_1; // al
  bool b; // zf

  FilterModuleGuidName = AttachParameters->FilterModuleGuidName;
  FilterHandle = NdisFilterHandle;
  Context = DeferredContext;
  NtStatus = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
  irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
  FilterModuleList = g_FilterModuleList.Flink;
  g_Irql = irql;
  if ( g_FilterModuleList.Flink == &g_FilterModuleList )
  {
LABEL_7:
    KeReleaseSpinLock(&g_FilterListLock, irql);
    Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    ByPassFilterModuleList = g_ByPassFilterModuleList.Flink;
    g_Irql = Irql;
    if ( g_ByPassFilterModuleList.Flink == &g_ByPassFilterModuleList )
    {
LABEL_13:
      KeReleaseSpinLock(&g_FilterListLock, Irql);
      temp = 0i64;
      goto LABEL_14;
    }
    LOWORD(Length) = FilterModuleGuidName->Length;
    while ( 1 )
    {
      temp = (FilterDeviceExtension *)&ByPassFilterModuleList[-1];
      v15 = ByPassFilterModuleList[20].Flink;
      if ( (_WORD)Length == LOWORD(v15->Flink) )
      {
        Length = FilterModuleGuidName->Length;
        if ( Length == RtlCompareMemory(v15->Blink, FilterModuleGuidName->Buffer, Length) )
          break;
      }
      ByPassFilterModuleList = ByPassFilterModuleList->Flink;
      if ( ByPassFilterModuleList == &g_ByPassFilterModuleList )
      {
        Irql = g_Irql;
        goto LABEL_13;
      }
    }
  }
  else
  {
    LOWORD(Length_1) = FilterModuleGuidName->Length;
    while ( 1 )
    {
      temp = (FilterDeviceExtension *)&FilterModuleList[-1];
      v11 = FilterModuleList[20].Flink;
      if ( (_WORD)Length_1 == LOWORD(v11->Flink) )
      {
        Length_1 = FilterModuleGuidName->Length;
        if ( Length_1 == RtlCompareMemory(v11->Blink, FilterModuleGuidName->Buffer, Length_1) )
          break;
      }
      FilterModuleList = FilterModuleList->Flink;
      if ( FilterModuleList == &g_FilterModuleList )
      {
        irql = g_Irql;
        goto LABEL_7;
      }
    }
  }
  if ( temp->State == FilterDetaching )
    ++temp->field_210;
  KeReleaseSpinLock(&g_FilterListLock, g_Irql);
LABEL_14:
  if ( temp )
  {
    irql_1 = KeAcquireSpinLockRaiseToDpc(&temp->SpinLock);
    b = temp->State == FilterDetaching;
    temp->irql = irql_1;
    if ( b )
    {
      temp->dword214 = 0;
      temp->NdisFilterHandle = FilterHandle;
      temp->State = FilterInitialized;
    }
    KeReleaseSpinLock(&temp->SpinLock, irql_1);
    *Context = temp;
    NtStatus = STATUS_SUCCESS;
  }
  return NtStatus;
}

//----- (000000000001422C) ----------------------------------------------------
NDIS_STATUS __fastcall NetmonFilterAttach(NDIS_HANDLE NdisFilterHandle, NDIS_HANDLE FilterDriverContext, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters)
{
  PNDIS_STRING FilterModuleGuidName; // r9
  PNDIS_FILTER_ATTACH_PARAMETERS AttachParameter; // rsi
  NDIS_HANDLE FilterHandle; // r12
  int b; // er13
  WCHAR c; // bp
  NDIS_STATUS NtStatus; // ebx
  PNDIS_STRING BaseMiniportName; // rdx
  FilterDeviceExtension *FilterModuleContext; // rdi
  int FilterScanTimerInterval; // eax
  struct _NDIS_FILTER_ATTRIBUTES FilterAttributes; // [rsp+20h] [rbp-68h]
  FilterDeviceExtension *DeferredContext; // [rsp+28h] [rbp-60h]
  char Dst; // [rsp+30h] [rbp-58h]

  FilterModuleGuidName = AttachParameters->FilterModuleGuidName;
  AttachParameter = AttachParameters;
  FilterHandle = NdisFilterHandle;
  DeferredContext = NULL;
  b = NULL;
  c = '0';
  if ( FilterModuleGuidName->Length )
    c = FilterModuleGuidName->Buffer[(unsigned __int64)(FilterModuleGuidName->Length - 1) >> 1];
  if ( FilterDriverContext != g_FilterDriverObject )
    return NDIS_STATUS_INVALID_PARAMETER;
  if ( !g_AttachUpperLayers && c != '0' )
  {
    if ( g_NmDebug )
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NetmonFilterAttach: Discarding %ws\n", FilterModuleGuidName->Buffer);
    return NDIS_STATUS_INVALID_PARAMETER;
  }
  if ( AttachParameters->MiniportMediaType != NdisMediumWan
    || (memmove(&Dst, L"\\DEVICE\\NDISWANBH", 36u),
        BaseMiniportName = AttachParameter->BaseMiniportName,
        NtStatus = NDIS_STATUS_FAILURE,
        BaseMiniportName->MaximumLength == 36)
    && RtlCompareMemory(&Dst, BaseMiniportName->Buffer, 36ui64) == 36 )
  {
    NtStatus = LookupFilterModule(FilterHandle, AttachParameter, &DeferredContext);
    if ( NtStatus )
    {
      if ( NmCreateFilterModule(FilterHandle, AttachParameter, &DeferredContext) )
        return NDIS_STATUS_RESOURCES;
      FilterModuleContext = DeferredContext;
      b = 1;
      LOWORD(DeferredContext->gap20C) = c;
    }
    else
    {
      FilterModuleContext = DeferredContext;
      if ( DeferredContext->State != FilterInitialized )
        return NtStatus;
    }
    FilterAttributes.Header.Size = 8;
    FilterAttributes.Header.Revision = NDIS_CONFIGURATION_OBJECT_REVISION_1;
    FilterAttributes.Header.Type = NDIS_OBJECT_TYPE_FILTER_ATTRIBUTES;
    FilterAttributes.Flags = NULL;
    NtStatus = NdisFSetAttributes(FilterHandle, FilterModuleContext, &FilterAttributes);
    if ( !NtStatus )
    {
      NmInitializeMinipInfo(AttachParameter->MiniportMediaType, FilterModuleContext);
      FilterScanTimerInterval = g_FilterScanTimerInterval;
      FilterModuleContext->State = FilterPausing;
      FilterModuleContext->DueTime = 10000 * FilterScanTimerInterval;
      StackModuleInstance(FilterModuleContext, b);
    }
  }
  return NtStatus;
}
// 17D00: using guessed type wchar_t aDeviceNdiswanb[18];
// 19124: using guessed type int g_FilterScanTimerInterval;
// 19198: using guessed type int g_AttachUpperLayers;
// 1919C: using guessed type int g_NmDebug;

//----- (000000000001440C) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonFilterDetach(FilterDeviceExtension *FilterModuleContext)
{
  FilterDeviceExtension *Context; // rbx
  KIRQL irql; // al
  KIRQL irql_1; // al

  Context = FilterModuleContext;
  irql = KeAcquireSpinLockRaiseToDpc(&FilterModuleContext->SpinLock);
  Context->State = FilterRestarting;
  Context->irql = irql;
  KeReleaseSpinLock(&Context->SpinLock, irql);
  if ( !_InterlockedExchange(&Context->dword214, 1) )
  {
    NmStopTimerSystem(Context);
    irql_1 = KeAcquireSpinLockRaiseToDpc(&Context->SpinLock);
    Context->State = FilterDetaching;
    Context->irql = irql_1;
    KeReleaseSpinLock(&Context->SpinLock, irql_1);
    if ( _InterlockedExchangeAdd(&Context->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule(Context);
  }
}

//----- (00000000000144B4) ----------------------------------------------------
NTSTATUS __fastcall NmCreateFilterModule(NDIS_HANDLE NdisFilterHandle, PNDIS_FILTER_ATTACH_PARAMETERS AttachParameters, FilterDeviceExtension **DeferredContext)
{
  void *v3; // r12
  PNDIS_FILTER_ATTACH_PARAMETERS AttachParameter; // rbp
  PNDIS_STRING BaseMiniportName; // rdx
  FilterDeviceExtension **Context; // r15
  NDIS_HANDLE FilterHandle; // rbx
  void *v8; // r13
  MACRO_NDIS_MEMORY NtStatus; // esi
  int i; // edi
  USHORT Length; // r11
  PWSTR Buffer; // rax
  USHORT MaximumLength; // cx
  PVOID v14; // rax
  ULONG DeviceExtensionSize; // edi
  FilterDeviceExtension *DeviceExtension; // r14
  size_t Length_1; // edx
  void *v18; // rcx
  size_t Length_2; // edx
  void *v20; // rcx
  size_t Length_3; // edx
  __m128i v22; // xmm1
  __m128i v23; // xmm0
  UNICODE_STRING BaseMiniport; // [rsp+40h] [rbp-78h]
  UNICODE_STRING DeviceName; // [rsp+50h] [rbp-68h]
  __int128 v27; // [rsp+60h] [rbp-58h]
  UNICODE_STRING SymbolicLinkName; // [rsp+70h] [rbp-48h]
  PDEVICE_OBJECT pDeviceObject; // [rsp+C8h] [rbp+10h]
  void *a3; // [rsp+D8h] [rbp+20h]

  v3 = 0i64;
  AttachParameter = AttachParameters;
  BaseMiniportName = AttachParameters->BaseMiniportName;
  Context = DeferredContext;
  FilterHandle = NdisFilterHandle;
  DeviceName.Length = 0;
  DeviceName.MaximumLength = 0;
  DeviceName.Buffer = 0i64;
  SymbolicLinkName.Length = 0;
  SymbolicLinkName.MaximumLength = 0;
  SymbolicLinkName.Buffer = 0i64;
  LODWORD(v27) = 0;
  *((_QWORD *)&v27 + 1) = 0i64;
  v8 = 0i64;
  a3 = 0i64;
  NtStatus = 0;
  if ( BaseMiniportName )
  {
    i = 0;
    RtlInitUnicodeString(&BaseMiniport, BaseMiniportName->Buffer);
    Length = BaseMiniport.Length;
    if ( BaseMiniport.Length > 0u )
    {
      Buffer = BaseMiniport.Buffer;
      MaximumLength = BaseMiniport.MaximumLength;
      do
      {
        if ( *Buffer == '\\' )
          ++i;
        Length -= 2;
        MaximumLength -= 2;
        ++Buffer;
        BaseMiniport.Length = Length;
        BaseMiniport.MaximumLength = MaximumLength;
        BaseMiniport.Buffer = Buffer;
      }
      while ( i != 2 && Length > 0u );
    }
    v14 = NdisAllocateMemoryWithTagPriority(FilterHandle, Length, 't3mN', LowPoolPriority);
    v3 = v14;
    *((_QWORD *)&v27 + 1) = v14;
    if ( v14 )
    {
      WORD1(v27) = BaseMiniport.Length;
      memmove(v14, BaseMiniport.Buffer, BaseMiniport.Length);
      LOWORD(v27) = BaseMiniport.Length;
    }
    else
    {
      NtStatus = NDIS_STATUS_RESOURCES;
    }
  }
  if ( (NtStatus & 0x80000000) != 0 )
    goto LABEL_28;
  if ( NmBuildDeviceName(FilterHandle, AttachParameter->FilterModuleGuidName, L"\\Device\\Nm3_", &DeviceName) < 0 )
  {
    NtStatus = NDIS_STATUS_FAILURE;
LABEL_28:
    if ( v3 )
      NdisFreeMemory(v3, 0, 0);
    if ( DeviceName.Buffer )
      NdisFreeMemory(DeviceName.Buffer, 0, 0);
    if ( SymbolicLinkName.Buffer )
      NdisFreeMemory(SymbolicLinkName.Buffer, 0, 0);
    return NtStatus;
  }
  NtStatus = NmBuildDeviceName(FilterHandle, AttachParameter->FilterModuleGuidName, L"\\DosDevices\\Nm3_", &SymbolicLinkName);
  if ( (NtStatus & 0x80000000) != 0 )
    goto LABEL_28;
  if ( AttachParameter->MiniportMediaType == 16
    && AttachParameter->FilterModuleGuidName->Buffer[(unsigned __int64)(AttachParameter->FilterModuleGuidName->Length - 1) >> 1] == 48 )
  {
    NmCreateDot11Filter(FilterHandle, AttachParameter, &a3);
    v8 = a3;
    if ( !a3 )
    {
      NtStatus = NDIS_STATUS_RESOURCES;
      goto LABEL_28;
    }
  }
  DeviceExtensionSize = AttachParameter->FilterModuleGuidName->Length
                      + AttachParameter->BaseMiniportInstanceName->Length
                      + AttachParameter->BaseMiniportName->Length
                      + 1000;
  NtStatus = IoCreateDevice(g_FilterDriverObject, DeviceExtensionSize, &DeviceName, FILE_DEVICE_NETWORK, 0x100u, 0u, &pDeviceObject);
  if ( (NtStatus & 0x80000000) != 0 )
    goto LABEL_37;
  pDeviceObject->Flags &= 0xFFFFFF7F;
  NtStatus = IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);
  if ( (NtStatus & 0x80000000) == 0 )
  {
    pDeviceObject->Flags |= 0x10u;
    DeviceExtension = (FilterDeviceExtension *)pDeviceObject->DeviceExtension;
    memset(pDeviceObject->DeviceExtension, 0, DeviceExtensionSize);
    DeviceExtension->byte0 = 9;
    DeviceExtension->word2 = 952;
    DeviceExtension->tag = 'MFMN';
    DeviceExtension->Create = NmFilterModuleIoCreate;
    DeviceExtension->NdisFilterHandle = FilterHandle;
    DeviceExtension->Cleanup = NmFilterModuleIoCleanup;
    DeviceExtension->Close = NmFilterModuleIoClose;
    DeviceExtension->Read = NmFilterModuleIoRead;
    DeviceExtension->Control = NmFilterModuleIoControl;
    DeviceExtension->DeviceObject = pDeviceObject;
    memmove(&DeviceExtension->AttachParameters, AttachParameter, 0xA8u);
    DeviceExtension->qword3C0 = (char *)DeviceExtension + 1000;
    Length_1 = AttachParameter->FilterModuleGuidName->Length;
    DeviceExtension->word3BA = Length_1;
    *(_WORD *)&DeviceExtension->char3B8 = Length_1;
    memmove(&DeviceExtension->FilterModuleGuidName, AttachParameter->FilterModuleGuidName->Buffer, Length_1);
    *(__int64 *)((char *)&DeviceExtension->field_149 + 7) = (__int64)&DeviceExtension->char3B8;
    v18 = (void *)(DeviceExtension->qword3C0 + *(unsigned __int16 *)&DeviceExtension->char3B8);
    DeviceExtension->qword3D0 = v18;
    Length_2 = AttachParameter->BaseMiniportInstanceName->Length;
    DeviceExtension->Length = Length_2;
    *(_WORD *)&DeviceExtension->char3C8 = Length_2;
    memmove(v18, AttachParameter->BaseMiniportInstanceName->Buffer, Length_2);
    DeviceExtension->qword160 = (char *)DeviceExtension + 968;
    v20 = (void *)(DeviceExtension->qword3D0 + *(unsigned __int16 *)&DeviceExtension->char3C8);
    DeviceExtension->qword3E0 = v20;
    Length_3 = AttachParameter->BaseMiniportName->Length;
    DeviceExtension->word3DA = Length_3;
    *(_WORD *)&DeviceExtension->char3D8 = Length_3;
    memmove(v20, AttachParameter->BaseMiniportName->Buffer, Length_3);
    DeviceExtension->qword168 = (char *)DeviceExtension + 984;
    _mm_storeu_si128(&DeviceExtension->m128i110, _mm_loadu_si128((const __m128i *)&DeviceName));
    v22 = _mm_loadu_si128((const __m128i *)&SymbolicLinkName);
    v23 = _mm_loadu_si128((const __m128i *)&v27);
    BYTE2(DeviceExtension->gap20C) = 1;
    DeviceExtension->field_210 = 1;
    DeviceExtension->dword214 = 0;
    _mm_storeu_si128(&DeviceExtension->m128i120, v22);
    _mm_storeu_si128(&DeviceExtension->m128i130, v23);
    NmAddGroupAccessAce(pDeviceObject);
    DeviceExtension->dword21C = 0;
    DeviceExtension->dword220 = 0;
    DeviceExtension->qword18 = (char *)DeviceExtension + 16;
    DeviceExtension->char10 = (__int64)&DeviceExtension->char10;
    DeviceExtension->SpinLock = 0i64;
    DeviceExtension->field_2F0 = (__int64)&DeviceExtension->char2E8;
    DeviceExtension->char2E8 = (__int64)&DeviceExtension->char2E8;
    DeviceExtension->State = 1;                 // FilterInitialized
    ExInitializeResourceLite(&DeviceExtension->eresource);
    if ( AttachParameter->MiniportPhysicalMediaType == 9 )
    {
      HIDWORD(DeviceExtension->field_3A4) = 1;
      DeviceExtension->qword3B0 = v8;
    }
    *Context = DeviceExtension;
  }
  else
  {
    IoDeleteDevice(pDeviceObject);
  }
  if ( (NtStatus & 0x80000000) != 0 )
  {
LABEL_37:
    if ( v8 )
      NmDeleteDot11Parameters(v8);
    goto LABEL_28;
  }
  return NtStatus;
}

//----- (0000000000014960) ----------------------------------------------------
void __fastcall NmDestroyFilterModule(FilterDeviceExtension *DeviceExtension)
{
  _DEVICE_OBJECT *DeviceObject; // rdi
  FilterDeviceExtension *DeviceExtension_1; // rbx
  __int64 v3; // rdx
  __int64 *v4; // rax
  void *v5; // rcx
  void *v6; // rcx
  void *v7; // rcx
  void *v8; // rcx

  DeviceObject = (_DEVICE_OBJECT *)DeviceExtension->DeviceObject;
  DeviceExtension_1 = DeviceExtension;
  g_Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
  v3 = DeviceExtension_1->char10;
  v4 = (__int64 *)DeviceExtension_1->qword18;
  *v4 = v3;
  *(_QWORD *)(v3 + 8) = v4;
  KeReleaseSpinLock(&g_FilterListLock, g_Irql);
  ExDeleteResourceLite(&DeviceExtension_1->eresource);
  IoDeleteSymbolicLink((PUNICODE_STRING)&DeviceExtension_1->m128i120);
  v5 = (void *)DeviceExtension_1->m128i130.m128i_i64[1];
  if ( v5 )
    NdisFreeMemory(v5, 0, 0);
  v6 = (void *)DeviceExtension_1->m128i110.m128i_i64[1];
  if ( v6 )
    NdisFreeMemory(v6, 0, 0);
  v7 = (void *)DeviceExtension_1->m128i120.m128i_i64[1];
  if ( v7 )
    NdisFreeMemory(v7, 0, 0);
  v8 = (void *)DeviceExtension_1->qword3B0;
  if ( v8 )
    NmDeleteDot11Parameters(v8);
  memset(DeviceExtension_1, 0, 0x3B8u);
  IoDeleteDevice(DeviceObject);
}

//----- (0000000000014A40) ----------------------------------------------------
NTSTATUS __fastcall NmBuildDeviceName(NDIS_HANDLE NdisFilterHandle, PNDIS_STRING FilterModuleGuidName, const WCHAR *str, UNICODE_STRING *Name)
{
  NDIS_HANDLE FilterHandle; // r12
  PNDIS_STRING ModuleGuidName; // rdi
  UNICODE_STRING *name; // rsi
  NTSTATUS NtStatus; // ebx
  USHORT Length; // bp
  USHORT Length_1; // r11
  PWSTR Buffer; // rax
  USHORT MaximumLength; // cx
  USHORT MaximumLength_1; // bp
  WCHAR *Buffer_1; // rax
  size_t Length_2; // er8
  PWSTR Buffer_2; // rdx
  size_t Length_3; // er8
  PWSTR Buffer_3; // rdx
  char *Buffer_4; // rcx
  UNICODE_STRING DestinationString; // [rsp+20h] [rbp-28h]
  UNICODE_STRING Name_1; // [rsp+30h] [rbp-18h]

  FilterHandle = NdisFilterHandle;
  ModuleGuidName = FilterModuleGuidName;
  name = Name;
  NtStatus = 0;
  RtlInitUnicodeString(&Name_1, str);
  Length = Name_1.Length;
  if ( ModuleGuidName )
  {
    RtlInitUnicodeString(&DestinationString, ModuleGuidName->Buffer);
    Length_1 = DestinationString.Length;
    if ( DestinationString.Length > 0u )
    {
      Buffer = DestinationString.Buffer;
      MaximumLength = DestinationString.MaximumLength;
      do
      {
        if ( *Buffer == '{' )
          break;
        Length_1 -= 2;
        MaximumLength -= 2;
        ++Buffer;
        DestinationString.Length = Length_1;
        DestinationString.MaximumLength = MaximumLength;
        DestinationString.Buffer = Buffer;
      }
      while ( Length_1 > 0u );
    }
  }
  else
  {
    Length_1 = DestinationString.Length;
  }
  MaximumLength_1 = Length_1 + Length;
  Buffer_1 = (WCHAR *)NdisAllocateMemoryWithTagPriority(FilterHandle, MaximumLength_1, 't3mN', LowPoolPriority);
  name->Buffer = Buffer_1;
  if ( !Buffer_1 )
    return NDIS_STATUS_RESOURCES;
  Length_2 = Name_1.Length;
  Buffer_2 = Name_1.Buffer;
  name->MaximumLength = MaximumLength_1;
  memmove(Buffer_1, Buffer_2, Length_2);
  Length_3 = DestinationString.Length;
  Buffer_3 = DestinationString.Buffer;
  Buffer_4 = (char *)name->Buffer + Name_1.Length;
  name->Length = Name_1.Length;
  memmove(Buffer_4, Buffer_3, Length_3);
  name->Length += DestinationString.Length;
  return NtStatus;
}

//----- (0000000000014B64) ----------------------------------------------------
void __fastcall StackModuleInstance(FilterDeviceExtension *FilterModuleContext, int b)
{
  FilterDeviceExtension *ModuleContext; // rbx
  int v3; // er14
  int v4; // er13
  int v5; // ebp
  int v6; // er12
  KIRQL Irql; // al
  _LIST_ENTRY *FilterModuleList; // rdi
  SIZE_T v9; // rsi
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // cx
  _LIST_ENTRY *v12; // rax
  _LIST_ENTRY *v13; // rcx
  _LIST_ENTRY *ByPassFilterModuleList; // rax
  _LIST_ENTRY *v15; // rcx
  _LIST_ENTRY *v16; // rax
  _LIST_ENTRY *v17; // rax
  KIRQL Irql_1; // al
  KIRQL Irql_2; // dl
  _LIST_ENTRY *FilterModuleList_1; // rax

  ModuleContext = FilterModuleContext;
  v3 = b;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
  FilterModuleList = g_FilterModuleList.Flink;
  g_Irql = Irql;
  if ( g_FilterModuleList.Flink != &g_FilterModuleList )
  {
    LOWORD(v9) = ModuleContext->m128i130.m128i_i16[0];
    do
    {
      if ( LOWORD(FilterModuleList[18].Flink) == (_WORD)v9 )
      {
        v9 = ModuleContext->m128i130.m128i_u16[0];
        if ( v9 == RtlCompareMemory(FilterModuleList[18].Blink, (const void *)ModuleContext->m128i130.m128i_i64[1], v9) )
        {
          v10 = WORD2(FilterModuleList[31].Blink);
          v11 = ModuleContext->gap20C;
          if ( v10 == v11 )
          {
            v5 = 1;
            break;
          }
          if ( v10 > v11 )
          {
            v6 = 1;
            break;
          }
          if ( v10 < v11 )
          {
            v12 = FilterModuleList->Blink;
            v13 = FilterModuleList->Flink;
            v12->Flink = FilterModuleList->Flink;
            v13->Blink = v12;
            ByPassFilterModuleList = g_ByPassFilterModuleList.Flink;
            FilterModuleList->Flink = g_ByPassFilterModuleList.Flink;
            v4 = 1;
            FilterModuleList->Blink = &g_ByPassFilterModuleList;
            ByPassFilterModuleList->Blink = FilterModuleList;
            g_ByPassFilterModuleList.Flink = FilterModuleList;
            v15 = FilterModuleList[1].Flink;
            BYTE6(FilterModuleList[31].Blink) = 0;
            NdisFRestartFilter(v15);
            break;
          }
        }
      }
      FilterModuleList = FilterModuleList->Flink;
    }
    while ( FilterModuleList != &g_FilterModuleList );
  }
  KeReleaseSpinLock(&g_FilterListLock, g_Irql);
  if ( v4 )
  {
    BYTE2(ModuleContext->gap20C) = 1;
    g_Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    if ( ModuleContext->gap218 )
      NmInitializeTimerSystem(ModuleContext);
    v16 = g_FilterModuleList.Flink;
    ModuleContext->char10 = (__int64)g_FilterModuleList.Flink;
    ModuleContext->qword18 = &g_FilterModuleList;
    v16->Blink = (_LIST_ENTRY *)&ModuleContext->char10;
    g_FilterModuleList.Flink = (_LIST_ENTRY *)&ModuleContext->char10;
  }
  else if ( v6 )
  {
    BYTE2(ModuleContext->gap20C) = 0;
    g_Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    v17 = g_ByPassFilterModuleList.Flink;
    ModuleContext->qword18 = &g_ByPassFilterModuleList;
    ModuleContext->char10 = (__int64)v17;
    v17->Blink = (_LIST_ENTRY *)&ModuleContext->char10;
    g_ByPassFilterModuleList.Flink = (_LIST_ENTRY *)&ModuleContext->char10;
  }
  else
  {
    if ( v5 )
    {
      BYTE2(ModuleContext->gap20C) = 1;
      Irql_1 = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
      g_Irql = Irql_1;
      if ( ModuleContext->gap218 )
      {
        NmInitializeTimerSystem(ModuleContext);
        Irql_1 = g_Irql;
      }
      Irql_2 = Irql_1;
      goto LABEL_26;
    }
    if ( !v3 )
      return;
    BYTE2(ModuleContext->gap20C) = 1;
    g_Irql = KeAcquireSpinLockRaiseToDpc(&g_FilterListLock);
    FilterModuleList_1 = g_FilterModuleList.Flink;
    ModuleContext->qword18 = &g_FilterModuleList;
    ModuleContext->char10 = (__int64)FilterModuleList_1;
    FilterModuleList_1->Blink = (_LIST_ENTRY *)&ModuleContext->char10;
    g_FilterModuleList.Flink = (_LIST_ENTRY *)&ModuleContext->char10;
  }
  Irql_2 = g_Irql;
LABEL_26:
  KeReleaseSpinLock(&g_FilterListLock, Irql_2);
}

//----- (0000000000014DC0) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  FilterDeviceExtension *DeviceExtension; // rbp
  PIRP irp; // rsi
  _DEVICE_OBJECT *pDeviceObject; // r13
  NTSTATUS Status; // ebx
  _IO_STACK_LOCATION *CurrentStackLocation; // r15
  unsigned int *Type; // r12
  int InputBufferLength; // eax
  ULONG OutputBufferLength; // er14
  KIRQL NewIrql; // al
  bool IsPaused; // zf
  unsigned int IoControlCode; // er11
  int v13; // er11
  int v14; // er11
  int v15; // er11
  int v16; // er11
  NTSTATUS v17; // eax
  __int64 v18; // r13
  unsigned int status; // eax
  unsigned int v20; // eax
  __int64 v21; // rax
  unsigned int oid; // er13
  NDIS_STATUS v23; // eax
  __int64 v24; // r13
  unsigned int status_1; // eax
  int v26; // er11
  int v27; // er11
  int v28; // er11
  int v29; // er11
  int v30; // er11
  NTSTATUS Status_1; // eax
  __int64 InformationBufferLength; // [rsp+20h] [rbp-78h]
  __int64 a7; // [rsp+30h] [rbp-68h]
  unsigned int *a8; // [rsp+40h] [rbp-58h]
  unsigned int *v36; // [rsp+48h] [rbp-50h]
  int v37[18]; // [rsp+50h] [rbp-48h]
  __int64 a4; // [rsp+A0h] [rbp+8h]
  int InputBufferLength_1; // [rsp+B0h] [rbp+18h]
  __int64 Information; // [rsp+B8h] [rbp+20h]

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  irp = Irp;
  pDeviceObject = DeviceObject;
  Status = STATUS_INVALID_BUFFER_SIZE;
  if ( !TestFilterModuleSignature(DeviceObject) )
  {
    irp->IoStatus.Information = 0i64;
    Status = NDIS_STATUS_INVALID_STATE;
    irp->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
    IofCompleteRequest(irp, IO_NO_INCREMENT);
    return Status;
  }
  _InterlockedAdd(&DeviceExtension->field_210, 1u);
  CurrentStackLocation = irp->Tail.Overlay.CurrentStackLocation;
  Type = (unsigned int *)irp->AssociatedIrp.MasterIrp;
  InputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.InputBufferLength;
  OutputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.OutputBufferLength;
  irp->IoStatus.Information = 0i64;
  InputBufferLength_1 = InputBufferLength;
  NewIrql = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->SpinLock);
  IsPaused = DeviceExtension->State == FilterPaused;
  DeviceExtension->irql = NewIrql;
  if ( !IsPaused && CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode != 0x2100AC )
  {
    KeReleaseSpinLock(&DeviceExtension->SpinLock, NewIrql);
    Status = NDIS_STATUS_INVALID_STATE;
    goto LABEL_62;
  }
  KeReleaseSpinLock(&DeviceExtension->SpinLock, NewIrql);
  IoControlCode = CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode;
  if ( IoControlCode > 0x2100A0 )
  {
    v27 = IoControlCode - 0x2100A4;
    if ( v27 )
    {
      v28 = v27 - 4;
      if ( v28 )
      {
        v29 = v28 - 4;
        if ( !v29 )
        {
          if ( OutputBufferLength == 4 && Type )
          {
            Status = 0;
            *Type = DeviceExtension->State;
            irp->IoStatus.Information = 4i64;
          }
          goto LABEL_62;
        }
        v30 = v29 - 5;
        if ( v30 )
        {
          if ( v30 != 3 )
            goto LABEL_53;
          Status_1 = NmDeleteCaptureFilter(pDeviceObject, irp);
        }
        else
        {
          Status_1 = NmAddCaptureFilter(pDeviceObject, irp);
        }
      }
      else
      {
        Status_1 = NmUserProcCaptureStop(pDeviceObject, irp);
      }
    }
    else
    {
      Status_1 = NmUserProcCaptureStart(pDeviceObject, irp);
    }
    Status = Status_1;
    goto LABEL_62;
  }
  if ( IoControlCode != 0x2100A0 )
  {
    v13 = IoControlCode - 0x21008C;
    if ( v13 )
    {
      v14 = v13 - 4;
      if ( v14 )
      {
        v15 = v14 - 4;
        if ( v15 )
        {
          v16 = v15 - 4;
          if ( !v16 || v16 == 4 )
          {
            if ( InputBufferLength_1 == 4 && Type )
            {
              v17 = NmDot11SetChannel(DeviceExtension, *Type);
              goto LABEL_46;
            }
            goto LABEL_62;
          }
LABEL_53:
          Status = NDIS_STATUS_NOT_SUPPORTED;
          goto LABEL_62;
        }
        if ( OutputBufferLength != 4 || !Type )
          goto LABEL_62;
        v18 = DeviceExtension->qword3B0;
        if ( !v18 )
        {
LABEL_19:
          Status = 0xC0235001;
          goto LABEL_62;
        }
        LODWORD(a7) = 0;
        status = nmFilterDoInternalRequest(0xE010192, DeviceExtension, 0, &a4, 4u, 0, a7, &a8);
        Status = status;
        if ( status )
          DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmDot11QueryPhyId: status %x\n", status);
        else
          pNmDot11StoreCurrentIfc(v18, a4);
        if ( Status )
          goto LABEL_62;
        v20 = a4;
      }
      else
      {
        if ( OutputBufferLength != 4 || !Type )
          goto LABEL_62;
        if ( !DeviceExtension->qword3B0 )
          goto LABEL_19;
        v21 = pNmDot11QueryCurrentIfc(DeviceExtension);
        if ( v21 )
        {
          oid = *(_DWORD *)(v21 + 1120);
          LODWORD(a7) = 0;
          v23 = nmFilterDoInternalRequest(*(_DWORD *)(v21 + 1120), DeviceExtension, 0, &Information, 4u, 0, a7, (unsigned int **)((char *)&a8 + 4));
          Status = v23;
          if ( v23 )
          {
            LODWORD(InformationBufferLength) = v23;
            DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmDot11QueryChannel: oid %x, status %x\n", oid, InformationBufferLength);
          }
          if ( Status )
            goto LABEL_62;
        }
        else
        {
          Status = 0;
        }
        v20 = Information;
      }
      *Type = v20;
    }
    else
    {
      if ( OutputBufferLength != 4 || !Type )
        goto LABEL_62;
      v24 = DeviceExtension->qword3B0;
      if ( !v24 )
        goto LABEL_19;
      LODWORD(a7) = 0;
      status_1 = nmFilterDoInternalRequest(0xD010308, DeviceExtension, 0, (__int64 *)v37, 8u, 0, a7, &v36);
      Status = status_1;
      if ( status_1 )
      {
        DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmDot11QueryPhyId: status %x\n", status_1);
        v26 = a4;
      }
      else
      {
        pNmDot11StoreOpMode(v24, v37[1]);
        v26 = v37[1];
      }
      if ( Status )
        goto LABEL_62;
      *Type = v26;
    }
LABEL_47:
    irp->IoStatus.Information = 4i64;
    goto LABEL_62;
  }
  if ( InputBufferLength_1 == 4 && Type )
  {
    v17 = NmDot11SetPhyId(DeviceExtension, *Type);
LABEL_46:
    Status = v17;
    if ( v17 )
      goto LABEL_62;
    goto LABEL_47;
  }
LABEL_62:
  irp->IoStatus.Status = Status;
  IofCompleteRequest(irp, IO_NO_INCREMENT);
  if ( _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF) == 1 )
    NmDestroyFilterModule(DeviceExtension);
  return Status;
}
// 14F3E: variable 'a7' is possibly undefined
// 1500A: variable 'InformationBufferLength' is possibly undefined

//----- (00000000000151B0) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  PIRP irp; // rsi
  _IO_STACK_LOCATION *CurrentStackLocation; // rdi
  NTSTATUS Status; // ebx
  CCHAR PriorityBoost; // dl

  irp = Irp;
  Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  Irp->IoStatus.Information = 0i64;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Irp->IoStatus.Status = NDIS_STATUS_PENDING;
  if ( !TestFilterModuleSignature(DeviceObject) )
  {
    Status = NDIS_STATUS_INVALID_STATE;
    PriorityBoost = 0;
LABEL_7:
    CurrentStackLocation->Control &= 0xFEu;
    irp->IoStatus.Status = Status;
    IofCompleteRequest(irp, PriorityBoost);
    return Status;
  }
  if ( LODWORD(CurrentStackLocation->FileObject->FsContext2) != 18175 )
  {
    Status = STATUS_INVALID_HANDLE;
LABEL_6:
    PriorityBoost = 2;
    goto LABEL_7;
  }
  Status = NmCloseUserProc(irp, CurrentStackLocation);
  if ( Status != NDIS_STATUS_PENDING )
    goto LABEL_6;
  return Status;
}

//----- (0000000000015244) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoCleanup(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  NTSTATUS Status; // ebx
  PIRP irp; // rsi
  _IO_STACK_LOCATION *CurrentStackLocation; // rdi
  CCHAR PriorityBoost; // dl
  PFILE_OBJECT FileObject; // rax
  FileContext *FsContext; // rbp

  Status = 0;
  irp = Irp;
  Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Irp->IoStatus.Status = NDIS_STATUS_PENDING;
  Irp->IoStatus.Information = 0i64;
  if ( TestFilterModuleSignature(DeviceObject) )
  {
    FileObject = CurrentStackLocation->FileObject;
    if ( LODWORD(FileObject->FsContext2) != 18175
      || (FsContext = (FileContext *)FileObject->FsContext, (int)NmVerifyUserProcObject((FileContext *)FileObject->FsContext) < 0) )
    {
      Status = STATUS_INVALID_HANDLE;
    }
    else
    {
      NmStopUserProc(FsContext);
      NmDerefUserProc(FsContext);
    }
    PriorityBoost = IO_NETWORK_INCREMENT;
  }
  else
  {
    Status = NDIS_STATUS_INVALID_STATE;
    PriorityBoost = IO_NO_INCREMENT;
  }
  CurrentStackLocation->Control &= 0xFEu;
  irp->IoStatus.Status = Status;
  IofCompleteRequest(irp, PriorityBoost);
  return Status;
}

//----- (00000000000152F0) ----------------------------------------------------
void __fastcall NmIoReadCancelRoutine(_DEVICE_OBJECT *DeviceObject, _IRP *Irp)
{
  FilterDeviceExtension *DeviceExtension; // r12
  _IO_STACK_LOCATION *CurrentStackLocation; // rax
  FileContext *FsContext; // rbp
  KIRQL irql; // al
  FileContext *FsContext_1; // rcx
  __int64 v10; // rdi
  KIRQL irql_1; // al

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  _RBX = Irp;
  if ( TestFilterModuleSignature(DeviceObject) )
  {
    _RAX = 0i64;
    __asm { xchg    rax, [rbx+68h]; Exchange Register/Memory with Register }
    _RBX->IoStatus.Information = 0i64;
    CurrentStackLocation = _RBX->Tail.Overlay.CurrentStackLocation;
    _RBX->Cancel = 1;
    _RBX->IoStatus.Status = STATUS_CANCELLED;
    FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
    irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    FsContext_1 = FsContext->next;
    FsContext->irql = irql;
    while ( 1 )
    {
      if ( FsContext_1 == (FileContext *)&FsContext->next )
      {
        KeReleaseSpinLock(&FsContext->SpinLock, irql);
        IoReleaseCancelSpinLock(_RBX->CancelIrql);
        return;
      }
      v10 = (__int64)&FsContext_1[-1].field_110;
      if ( (_IRP *)FsContext_1[-1].field_120 == _RBX )
        break;
      FsContext_1 = *(FileContext **)&FsContext_1->word0;
    }
    _InterlockedAdd((volatile signed __int32 *)(v10 + 88), 1u);
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    IoReleaseCancelSpinLock(_RBX->CancelIrql);
    irql_1 = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    FsContext->irql = irql_1;
    if ( *(_BYTE *)(v10 + 24) & 1 || !(*(_BYTE *)(v10 + 24) & 2) )
    {
      KeReleaseSpinLock(&FsContext->SpinLock, irql_1);
    }
    else
    {
      LOBYTE(DeviceExtension->field_23C) = 1;
      *(_DWORD *)(v10 + 24) &= 0xFFFFFFFD;
      KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
      NmDerefCaptureBuffer((PVOID)v10);
    }
    NmDerefCaptureBuffer((PVOID)v10);
  }
  else
  {
    _RBX->IoStatus.Information = 0i64;
    _RBX->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
    IofCompleteRequest(_RBX, IO_NO_INCREMENT);
  }
}

//----- (0000000000015428) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoRead(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  FilterDeviceExtension *DeviceExtension; // r14
  NTSTATUS Status; // edi
  NTSTATUS NtStatus; // ebx
  CCHAR PriorityBoost; // dl
  _IO_STACK_LOCATION *CurrentStackLocation; // r13
  FileContext *FsContext; // rbp
  NTSTATUS Status_1; // eax
  PMDL MdlAddress; // rbx
  PVOID MappedSystemVa; // rax
  _QWORD *v13; // rax
  _QWORD *v14; // r12
  _QWORD *v15; // r14
  PMDL v16; // rax
  struct _IO_WORKITEM *v17; // rax
  _QWORD *v20; // rax
  __int64 v21; // rax

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  _RSI = Irp;
  Status = NDIS_STATUS_PENDING;
  if ( !TestFilterModuleSignature(DeviceObject) )
  {
    NtStatus = NDIS_STATUS_INVALID_STATE;
    PriorityBoost = IO_NO_INCREMENT;
    _RSI->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
LABEL_3:
    IofCompleteRequest(_RSI, PriorityBoost);
    return NtStatus;
  }
  CurrentStackLocation = _RSI->Tail.Overlay.CurrentStackLocation;
  FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
  Status_1 = NmVerifyUserProcObject(FsContext);
  NtStatus = Status_1;
  if ( Status_1 )
  {
    _RSI->IoStatus.Status = Status_1;
    PriorityBoost = IO_NETWORK_INCREMENT;
    goto LABEL_3;
  }
  _RSI->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  _RSI->IoStatus.Status = NDIS_STATUS_PENDING;
  _RSI->IoStatus.Information = 0i64;
  if ( LODWORD(CurrentStackLocation->FileObject->FsContext2) == 18175 )
  {
    if ( CurrentStackLocation->Parameters.Read.Length >= 0x32 )
    {
      MdlAddress = _RSI->MdlAddress;
      if ( MdlAddress )
      {
        do
        {
          if ( MdlAddress->MdlFlags & 5 )
            MappedSystemVa = MdlAddress->MappedSystemVa;
          else
            MappedSystemVa = MmMapLockedPagesSpecifyCache(MdlAddress, 0, MmCached, 0i64, 0, NormalPagePriority);
          if ( !MappedSystemVa )
            goto LABEL_23;
          MdlAddress = MdlAddress->Next;
        }
        while ( MdlAddress );
        v13 = ExAllocatePoolWithTag(NonPagedPool, 0x108ui64, 'bcMN');// 有一个大结构?
        v14 = v13;
        if ( !v13 )
        {
LABEL_23:
          Status = NDIS_STATUS_RESOURCES;
          goto LABEL_25;
        }
        memset(v13, 0, 0x108u);
        v14[4] = DeviceExtension;
        *(_WORD *)v14 = 264;
        v14[5] = 0i64;
        v15 = v14 + 9;
        *((_WORD *)v14 + 1) = 18175;
        v14[10] = v14 + 9;
        v14[9] = v14 + 9;
        *((_DWORD *)v14 + 30) = 0;
        *((_DWORD *)v14 + 23) = 192;
        *((_DWORD *)v14 + 22) = 1;
        v16 = _RSI->MdlAddress;
        v14[2] = _RSI;
        v14[1] = v16;
        *((_DWORD *)v14 + 24) = CurrentStackLocation->Parameters.Read.Length;
        if ( !_InterlockedExchange((volatile signed __int32 *)&FsContext->field_B8, 1)
          && !_InterlockedCompareExchange((volatile signed __int64 *)&FsContext->WorkItem, 0i64, 0i64) )
        {
          _InterlockedAdd(&FsContext->gap18, 1u);
          v17 = IoAllocateWorkItem((PDEVICE_OBJECT)FsContext->FilterDeviceExtension->DeviceObject);
          if ( v17 )
          {
            _InterlockedCompareExchange((volatile signed __int64 *)&FsContext->WorkItem, (signed __int64)v17, 0i64);
            IoQueueWorkItem(v17, (PIO_WORKITEM_ROUTINE)NmUserProcGetStats, DelayedWorkQueue, FsContext);
          }
        }
        IoAcquireCancelSpinLock(&_RSI->CancelIrql);
        _RAX = NmIoReadCancelRoutine;
        __asm { xchg    rax, [rsi+68h]; Exchange Register/Memory with Register }
        IoReleaseCancelSpinLock(_RSI->CancelIrql);
        FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
        _InterlockedAdd(&FsContext->gap18, 1u);
        *((_DWORD *)v14 + 6) |= 2u;
        v14[8] = FsContext;
        v14[7] = (char *)FsContext + 32;
        v20 = (_QWORD *)FsContext->qword60;
        *v15 = (char *)FsContext + 88;
        v14[10] = v20;
        *v20 = v15;
        FsContext->qword60 = v15;
        v21 = v14[8];
        if ( *(_DWORD *)(v21 + 104) > 0u )
          --*(_DWORD *)(v21 + 104);
        KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
        NmDerefUserProc(FsContext);
        return Status;
      }
    }
    Status = NDIS_STATUS_INVALID_PARAMETER;
  }
  else
  {
    Status = NDIS_STATUS_INVALID_DEVICE_REQUEST;
  }
LABEL_25:
  NmDerefUserProc(FsContext);
  CurrentStackLocation->Control &= 0xFEu;
  _RSI->IoStatus.Status = Status;
  IofCompleteRequest(_RSI, IO_NETWORK_INCREMENT);
  return Status;
}

//----- (00000000000156B8) ----------------------------------------------------
NTSTATUS __fastcall NmFilterModuleIoCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  PIRP irp; // rbx
  MACRO_NDIS_MEMORY Status; // edi
  FilterDeviceExtension *v4; // r10
  CCHAR PriorityBoost; // dl
  PIRP MasterIrp; // r9
  _IO_STACK_LOCATION *CurrentStackLocation; // rsi
  unsigned __int16 i; // r8

  irp = Irp;
  Status = 0;
  if ( !TestFilterModuleSignature(DeviceObject) )
  {
    irp->IoStatus.Information = 0i64;
    PriorityBoost = IO_NO_INCREMENT;
    Status = NDIS_STATUS_INVALID_STATE;
LABEL_11:
    irp->IoStatus.Status = Status;
    IofCompleteRequest(irp, PriorityBoost);
    return Status;
  }
  irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
  MasterIrp = irp->AssociatedIrp.MasterIrp;
  CurrentStackLocation = irp->Tail.Overlay.CurrentStackLocation;
  irp->IoStatus.Status = NDIS_STATUS_PENDING;
  irp->IoStatus.Information = 0i64;
  if ( !MasterIrp || *((_BYTE *)&MasterIrp->Size + 3) != 12 )
    goto LABEL_15;
  for ( i = 0; i < 12u; ++i )
  {
    if ( *((_BYTE *)&MasterIrp->MdlAddress + i) != aNmuserprocea[i] )
      break;
  }
  if ( i != 12 || (Status = NmOpenUserProc(v4, irp, CurrentStackLocation), Status != NDIS_STATUS_PENDING) )
  {
LABEL_15:
    CurrentStackLocation->Control &= 0xFEu;
    PriorityBoost = IO_NETWORK_INCREMENT;
    goto LABEL_11;
  }
  return Status;
}
// 15747: variable 'v4' is possibly undefined

//----- (0000000000015780) ----------------------------------------------------
BOOL __fastcall TestFilterModuleSignature(PDEVICE_OBJECT DeviceObject)
{
  FilterDeviceExtension *DeviceExtension; // r8
  BOOL result; // eax

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  result = FALSE;
  if ( &DeviceExtension->char10 < (__int64 *)((char *)DeviceObject + DeviceObject->Size) && DeviceExtension->word2 == 952 && DeviceExtension->tag == 'MFMN' )
    result = TRUE;
  return result;
}

//----- (00000000000157B8) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonDevicePnPEventNotify(FilterDeviceExtension *FilterModuleContext, PNET_DEVICE_PNP_EVENT NetDevicePnPEvent)
{
  NdisFDevicePnPEventNotify(FilterModuleContext->NdisFilterHandle, NetDevicePnPEvent);
}

//----- (00000000000157CC) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
NDIS_STATUS __fastcall NetmonNetPnPEvent(FilterDeviceExtension *FilterModuleContext, PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification)
{
  return NdisFNetPnPEvent(FilterModuleContext->NdisFilterHandle, NetPnPEventNotification);
}

//----- (00000000000157E0) ----------------------------------------------------
__int64 __fastcall NetmonGetTimeStamp(FilterDeviceExtension *FilterModuleContext, __int64 *a2)
{
  FilterDeviceExtension *Context; // rbx
  __int64 *v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rax
  __int64 result; // rax
  int v8; // eax
  int v9; // [rsp+30h] [rbp+8h]
  __int64 v10; // [rsp+30h] [rbp+8h]
  __int64 v11; // [rsp+38h] [rbp+10h]

  *a2 = 0i64;
  Context = FilterModuleContext;
  v3 = a2;
  v4 = *(_QWORD *)&KeQueryPerformanceCounter(0i64) - *(__int64 *)((char *)&FilterModuleContext->field_244 + 4);
  v5 = *(__int64 *)((char *)&Context->field_24C + 4);
  v11 = (unsigned int)v4;
  v6 = 10000000i64 * HIDWORD(v4) / v5;
  v9 = v6;
  result = v6 >> 32;
  if ( (int)result <= 0 )
  {
    v8 = v9;
    LODWORD(v10) = 0;
    HIDWORD(v10) = v8;
    result = v10 + *(__int64 *)((char *)&Context->field_23C + 4) + 10000000 * v11 / v5;
    *v3 = result;
  }
  return result;
}

//----- (0000000000015880) ----------------------------------------------------
// 第一个参数名誉上是NDIS_HANDLE。
// 实际是：FilterDeviceExtension *
void __fastcall NetmonReceiveNetBufferLists(FilterDeviceExtension *FilterModuleContext, PNET_BUFFER_LIST NetBufferLists, NDIS_PORT_NUMBER PortNumber, ULONG NumberOfNetBufferLists, ULONG ReceiveFlags)
{
  unsigned int ReceiveFlag; // er15
  _NET_BUFFER_LIST *NetBufferList_1; // r14
  FilterDeviceExtension *ModuleContext; // rdi
  bool b; // bp
  KSPIN_LOCK *SpinLock; // rbx
  unsigned int v10; // er12
  KSPIN_LOCK *SpinLock_1; // rcx
  bool v12; // si
  SLIST_HEADER *v13; // rsi
  __int64 v14; // rbx
  __int64 v15; // rcx
  __int64 v16; // rdx
  int v17; // eax
  KSPIN_LOCK *SpinLock_2; // rcx
  ULONGLONG v19; // r11
  __int64 v20; // rcx
  int v21; // er8
  char v22; // al
  int v23; // edx
  __int64 v24; // rax
  __int64 *v25; // r13
  _DWORD *a6; // rbp
  NDIS_PORT_NUMBER v27; // ebx
  __int64 ReceiveFlagsa; // [rsp+20h] [rbp-A8h]
  _DWORD a1[2]; // [rsp+40h] [rbp-88h]
  int v30; // [rsp+48h] [rbp-80h]
  unsigned int v31; // [rsp+4Ch] [rbp-7Ch]
  __int64 v32; // [rsp+58h] [rbp-70h]
  int v33; // [rsp+63h] [rbp-65h]
  __int64 v34; // [rsp+67h] [rbp-61h]
  __int64 v35; // [rsp+6Fh] [rbp-59h]
  char v36; // [rsp+77h] [rbp-51h]
  __int64 TimeStamp; // [rsp+D0h] [rbp+8h]
  PNET_BUFFER_LIST NetBufferList; // [rsp+D8h] [rbp+10h]
  NDIS_PORT_NUMBER PortNumbera; // [rsp+E0h] [rbp+18h]
  ULONG NumberOfNetBufferListsa; // [rsp+E8h] [rbp+20h]

  NumberOfNetBufferListsa = NumberOfNetBufferLists;
  PortNumbera = PortNumber;
  NetBufferList = NetBufferLists;
  ReceiveFlag = ReceiveFlags;
  NetBufferList_1 = NetBufferLists;
  ModuleContext = FilterModuleContext;
  b = (ReceiveFlags & 1) == 1;
  if ( !_bittest((const signed __int32 *)&NetBufferLists->Flags, 0xFu) )
  {
    SpinLock = &FilterModuleContext->SpinLock;
    v10 = 0;
    SpinLock_1 = &FilterModuleContext->SpinLock;
    if ( (ReceiveFlags & 1) == 1 )
      KeAcquireSpinLockAtDpcLevel(SpinLock_1);
    else
      ModuleContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
    v12 = ModuleContext->gap218 != 0;
    if ( b )
      KeReleaseSpinLockFromDpcLevel(SpinLock);
    else
      KeReleaseSpinLock(SpinLock, ModuleContext->irql);
    if ( v12 )
    {
      v13 = (SLIST_HEADER *)NetBufferList_1;
      NetmonGetTimeStamp(ModuleContext, &TimeStamp);
      v14 = TimeStamp;
      v30 = 0;
      *(_QWORD *)a1 = TimeStamp;
      while ( 1 )
      {
        v15 = ModuleContext->qword3B0;
        LOBYTE(v32) = 2;
        *(_WORD *)((char *)&v32 + 1) = 32;
        *(_DWORD *)((char *)&v32 + 3) = 0;
        *(__int64 *)((char *)&v32 + 7) = 0i64;
        v34 = 0i64;
        v35 = 0i64;
        v36 = 0;
        if ( !v15 )
        {
          v25 = 0i64;
          goto LABEL_21;
        }
        *(_BYTE *)(ModuleContext->qword3B0 + 136i64) = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v15 + 128));
        v16 = ModuleContext->qword3B0;
        v17 = *(_DWORD *)(v16 + 168);
        SpinLock_2 = (KSPIN_LOCK *)(v16 + 128);
        LOBYTE(v16) = *(_BYTE *)(v16 + 136);
        *(_DWORD *)((char *)&v32 + 3) = v17;
        KeReleaseSpinLock(SpinLock_2, v16);
        v19 = v13[12].Alignment;
        if ( !v19 )
          break;
        v20 = ModuleContext->qword3B0;
        v21 = *(_DWORD *)(v19 + 4);
        HIDWORD(v34) = *(_DWORD *)(v19 + 20);
        v22 = *(_BYTE *)(v19 + 24);
        *(_DWORD *)((char *)&v32 + 7) = v21;
        LOBYTE(v35) = v22;
        v23 = 0;
        LODWORD(v34) = *(_DWORD *)(v19 + 12);
        v24 = *(unsigned int *)(v19 + 8);
        if ( v20 && (unsigned int)v24 < *(_DWORD *)(v20 + 164) )
          v23 = *(_DWORD *)(*(_QWORD *)(v20 + 8 * v24 + 184) + 24i64);
        v33 = v23;
        if ( !(v21 & 4) )
          goto LABEL_18;
        *(__int64 *)((char *)&v35 + 1) = *(_QWORD *)(v19 + 40);
LABEL_19:
        v25 = &v32;
        v10 = 32;
LABEL_21:
        a6 = *(_DWORD **)&v13->s.Depth;
        if ( a6 )
        {
          v27 = PortNumbera;
          do
          {
            v31 = v10 + a6[6];
            LODWORD(ReceiveFlagsa) = v27;
            NmCopySingleNetBuffer(a1, (__int64)v25, v10, ModuleContext, ReceiveFlagsa, a6, ReceiveFlag);
            a6 = *(_DWORD **)a6;
          }
          while ( a6 );
          v14 = TimeStamp;
        }
        v13 = (SLIST_HEADER *)v13->Alignment;
        v10 = 0;
        if ( !v13 )
        {
          NetBufferList_1 = NetBufferList;
          goto LABEL_27;
        }
      }
      *(_DWORD *)((char *)&v32 + 7) = -1;
      v33 = -1;
      LOBYTE(v35) = 0;
      v34 = 0i64;
LABEL_18:
      *(__int64 *)((char *)&v35 + 1) = v14;
      goto LABEL_19;
    }
  }
LABEL_27:
  NdisFIndicateReceiveNetBufferLists(ModuleContext->NdisFilterHandle, NetBufferList_1, PortNumbera, NumberOfNetBufferListsa, ReceiveFlag);
}
// 15A8C: variable 'ReceiveFlagsa' is possibly undefined

//----- (0000000000015AF8) ----------------------------------------------------
// // 第一个参数名誉上是NDIS_HANDLE。
// // 实际是：FilterDeviceExtension *
void __fastcall NetmonSendNetBufferLists(FilterDeviceExtension *FilterModuleContext, PNET_BUFFER_LIST NetBufferList, NDIS_PORT_NUMBER PortNumber, ULONG SendFlags)
{
  KSPIN_LOCK *SpinLock; // rbx
  FilterDeviceExtension *Context; // rdi
  unsigned int SendFlags_1; // er15
  _NET_BUFFER_LIST *NetBuffer; // r12
  KSPIN_LOCK *SpinLock_1; // rcx
  bool b; // bp
  bool b_1; // si
  SLIST_HEADER *v11; // rsi
  __int64 v12; // rbx
  __int64 v13; // rax
  int v14; // eax
  char *v15; // r14
  unsigned int v16; // er13
  _DWORD *a6; // rbp
  int v18; // ebx
  __int64 a5; // [rsp+20h] [rbp-98h]
  _DWORD a1[2]; // [rsp+40h] [rbp-78h]
  int v21; // [rsp+48h] [rbp-70h]
  unsigned int v22; // [rsp+4Ch] [rbp-6Ch]
  char v23[11]; // [rsp+58h] [rbp-60h]
  __int64 v24; // [rsp+63h] [rbp-55h]
  __int64 v25; // [rsp+6Bh] [rbp-4Dh]
  int v26; // [rsp+73h] [rbp-45h]
  char v27; // [rsp+77h] [rbp-41h]
  __int64 TimeStamp; // [rsp+C0h] [rbp+8h]
  __int64 PortNumber_1; // [rsp+D0h] [rbp+18h]

  LODWORD(PortNumber_1) = PortNumber;
  SpinLock = &FilterModuleContext->SpinLock;
  Context = FilterModuleContext;
  SendFlags_1 = SendFlags;
  NetBuffer = NetBufferList;
  SpinLock_1 = &FilterModuleContext->SpinLock;
  b = (SendFlags & 1) == 1;
  if ( (SendFlags & 1) == 1 )
    KeAcquireSpinLockAtDpcLevel(SpinLock_1);
  else
    Context->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
  b_1 = Context->gap218 != 0;
  if ( b )
    KeReleaseSpinLockFromDpcLevel(SpinLock);
  else
    KeReleaseSpinLock(SpinLock, Context->irql);
  if ( b_1 )
  {
    v11 = (SLIST_HEADER *)NetBuffer;
    NetmonGetTimeStamp(Context, &TimeStamp);
    v12 = TimeStamp;
    v21 = 0;
    *(_QWORD *)a1 = TimeStamp;
    if ( NetBuffer )
    {
      do
      {
        *(_DWORD *)&v23[3] = 0;
        *(_DWORD *)&v23[7] = -1;
        v24 = 0i64;
        v25 = 0i64;
        v26 = 0;
        v27 = 0;
        v13 = Context->qword3B0;
        v23[0] = 2;
        strcpy(&v23[1], " ");
        if ( v13 )
        {
          v14 = *(_DWORD *)(v13 + 168);
          *(__int64 *)((char *)&v25 + 5) = v12;
          v15 = v23;
          *(_DWORD *)&v23[3] = v14;
          v16 = 32;
        }
        else
        {
          v15 = 0i64;
          v16 = 0;
        }
        a6 = *(_DWORD **)&v11->s.Depth;
        if ( a6 )
        {
          v18 = PortNumber_1;
          do
          {
            v22 = v16 + a6[6];
            LODWORD(a5) = v18;
            NmCopySingleNetBuffer(a1, (__int64)v15, v16, Context, a5, a6, SendFlags_1);
            a6 = *(_DWORD **)a6;
          }
          while ( a6 );
          v12 = TimeStamp;
        }
        v11 = (SLIST_HEADER *)v11->Alignment;
      }
      while ( v11 );
    }
  }
  NdisFSendNetBufferLists(Context->NdisFilterHandle, NetBuffer, PortNumber_1, SendFlags_1);
}
// 15C41: variable 'a5' is possibly undefined

//----- (0000000000015CA0) ----------------------------------------------------
void __fastcall NmCopySingleNetBuffer(_DWORD *a1, __int64 a2, __int64 a3, FilterDeviceExtension *FilterModuleContext, __int64 a5, void *a6, unsigned int a7)
{
  unsigned int v7; // er13
  KSPIN_LOCK *SpinLock_1; // rdi
  FilterDeviceExtension *Context; // rbp
  KSPIN_LOCK *SpinLock; // rcx
  __int64 v11; // r15
  __int64 v12; // rax
  const signed __int32 *v13; // rsi
  const signed __int32 *v14; // r12
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // ecx
  unsigned int v19; // eax
  unsigned int v20; // er12
  KSPIN_LOCK *SpinLock_2; // rcx
  KSPIN_LOCK *SpinLock_4; // rcx
  KSPIN_LOCK *SpinLock_3; // rcx
  _DWORD *v24; // [rsp+80h] [rbp+8h]
  void *v25; // [rsp+88h] [rbp+10h]
  unsigned int v26; // [rsp+90h] [rbp+18h]

  v26 = a3;
  v25 = (void *)a2;
  v24 = a1;
  v7 = a7;
  SpinLock_1 = &FilterModuleContext->SpinLock;
  Context = FilterModuleContext;
  SpinLock = &FilterModuleContext->SpinLock;
  if ( (a7 & 1) == 1 )
    KeAcquireSpinLockAtDpcLevel(SpinLock);
  else
    FilterModuleContext->irql = KeAcquireSpinLockRaiseToDpc(SpinLock);
  v11 = Context->char2E8;
  if ( (__int64 *)v11 != &Context->char2E8 )
  {
    v12 = (__int64)&Context->char2E8;
    while ( 1 )
    {
      if ( *(_BYTE *)(v11 + 56) & 0x40 || *(_BYTE *)(v11 + 56) >= 0 )
        goto LABEL_50;
      _InterlockedAdd((volatile signed __int32 *)(v11 + 16), 1u);
      if ( (a7 & 1) == 1 )
        KeReleaseSpinLockFromDpcLevel(SpinLock_1);
      else
        KeReleaseSpinLock(SpinLock_1, Context->irql);
      ++*(_QWORD *)(v11 + 240);
      v13 = (const signed __int32 *)(v11 + 104);
      if ( *(const signed __int32 **)v13 == v13 )
        goto LABEL_31;
      v14 = *(const signed __int32 **)v13;
      v15 = 0;
      while ( v14 != v13 )
      {
        v16 = NmCaptureFilterMatch((__int64)(v14 - 1), (__int64)a6);
        v15 = v16;
        if ( v16 >= 2 )
          break;
        if ( v16 == 1 )
        {
          if ( !_bittest(v14 + 5, 0x11u) )
            break;
        }
        else
        {
          if ( v14[5] & 1 )
          {
            v15 = 2;
            break;
          }
          if ( _bittest(v14 + 5, 0x11u) )
            break;
        }
        v14 = *(const signed __int32 **)v14;
      }
      v17 = v15 - 1;
      if ( !v17 )
        break;
      v18 = v17 - 1;
      if ( !v18 || v18 == 2 )
        break;
      ++*(_QWORD *)(v11 + 280);
      if ( (a7 & 1) == 1 )
        KeAcquireSpinLockAtDpcLevel(SpinLock_1);
      else
        Context->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
      NmDerefUserProc((FileContext *)(v11 - 8));
LABEL_49:
      v12 = (__int64)&Context->char2E8;
LABEL_50:
      v11 = *(_QWORD *)v11;
      v7 = a7;
      if ( v11 == v12 )
        goto LABEL_51;
    }
    v7 = a7;
LABEL_31:
    v19 = *(_DWORD *)(v11 + 140);
    if ( v24[3] < v19 )
      v19 = v24[3];
    v24[4] = v19;
    v20 = (v19 + 55) & 0xFFFFFFE0;
    v24[5] = v20 - 24;
    SpinLock_2 = (KSPIN_LOCK *)(v11 + 24);
    if ( (a7 & 1) == 1 )
      KeAcquireSpinLockAtDpcLevel(SpinLock_2);
    else
      *(_BYTE *)(v11 + 32) = KeAcquireSpinLockRaiseToDpc(SpinLock_2);
    if ( *(_BYTE *)(v11 + 56) & 0x40 || *(_BYTE *)(v11 + 56) >= 0 )
    {
      SpinLock_3 = (KSPIN_LOCK *)(v11 + 24);
      if ( (a7 & 1) == 1 )
        KeReleaseSpinLockFromDpcLevel(SpinLock_3);
      else
        KeReleaseSpinLock(SpinLock_3, *(_BYTE *)(v11 + 32));
    }
    else
    {
      SpinLock_4 = (KSPIN_LOCK *)(v11 + 24);
      if ( (a7 & 1) == 1 )
        KeReleaseSpinLockFromDpcLevel(SpinLock_4);
      else
        KeReleaseSpinLock(SpinLock_4, *(_BYTE *)(v11 + 32));
      if ( (unsigned int)NmCopyNetBufferToCaptureBuffer((__int64)Context, v20, a6, (char *)(v11 - 8), v7, v24, v25, v26) )
        ++*(_QWORD *)(v11 + 272);
    }
    NmDerefUserProc((FileContext *)(v11 - 8));
    if ( (a7 & 1) == 1 )
      KeAcquireSpinLockAtDpcLevel(SpinLock_1);
    else
      Context->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
    goto LABEL_49;
  }
LABEL_51:
  if ( (a7 & 1) == 1 )
    KeReleaseSpinLockFromDpcLevel(SpinLock_1);
  else
    KeReleaseSpinLock(SpinLock_1, Context->irql);
}

//----- (0000000000015F5C) ----------------------------------------------------
__int64 __fastcall NmCopyNetBufferToCaptureBuffer(__int64 a4, unsigned int edx0, void *a2, char *r9_0, unsigned int a3, void *a2a, void *a7, unsigned int a3a)
{
  char *v8; // rdi
  unsigned __int64 v9; // r13
  __int64 v10; // r14
  char *v11; // r12
  bool v12; // bp
  KSPIN_LOCK *SpinLock_1; // rcx
  char *i; // rax
  __int64 v15; // rbx
  int v16; // er15
  KSPIN_LOCK *SpinLock_2; // rcx
  KSPIN_LOCK *v18; // rcx
  unsigned int v19; // er12
  KSPIN_LOCK *SpinLock_3; // rcx
  KSPIN_LOCK *SpinLock_4; // rcx
  _MDL *v22; // rdi
  char *MappedSystemVa; // rcx
  ULONG v24; // edx
  unsigned int v25; // eax
  unsigned int v26; // er13
  unsigned int v27; // edi
  unsigned int v28; // eax
  KSPIN_LOCK *SpinLock_5; // rcx
  KSPIN_LOCK *SpinLock_6; // rcx
  KSPIN_LOCK *SpinLock; // rcx
  PMDL MdlAddress; // [rsp+30h] [rbp-48h]
  char *v34; // [rsp+38h] [rbp-40h]
  unsigned int v35; // [rsp+40h] [rbp-38h]
  unsigned int v36; // [rsp+44h] [rbp-34h]
  void *v37; // [rsp+90h] [rbp+18h]

  v37 = a2;
  v8 = r9_0;
  v9 = edx0;
  v10 = a4;
  v11 = r9_0 + 88;
  v12 = (a3 & 1) == 1;
  while ( 1 )
  {
    SpinLock_1 = (KSPIN_LOCK *)(v8 + 32);
    if ( v12 )
      KeAcquireSpinLockAtDpcLevel(SpinLock_1);
    else
      v8[40] = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
    for ( i = *(char **)v11; ; i = *(char **)i )
    {
      if ( i == v11 )
      {
        SpinLock = (KSPIN_LOCK *)(v8 + 32);
        if ( v12 )
          KeReleaseSpinLockFromDpcLevel(SpinLock);
        else
          KeReleaseSpinLock(SpinLock, v8[40]);
        return STATUS_INSUFFICIENT_RESOURCES;
      }
      v15 = (__int64)(i - 72);
      if ( !(*(i - 48) & 1) )
      {
        if ( *(_BYTE *)(v15 + 24) & 2 )
          break;
      }
    }
    _InterlockedAdd((volatile signed __int32 *)(v15 + 88), 1u);
    v16 = *(_DWORD *)(v15 + 96);
    if ( *(unsigned int *)(v15 + 96) - (unsigned __int64)*(unsigned int *)(v15 + 92) >= v9 )
      break;
    *(_DWORD *)(v15 + 24) |= 1u;
    SpinLock_2 = (KSPIN_LOCK *)(v8 + 32);
    *(_BYTE *)(v10 + 572) = 1;
    if ( v12 )
      KeReleaseSpinLockFromDpcLevel(SpinLock_2);
    else
      KeReleaseSpinLock(SpinLock_2, v8[40]);
    NmDerefCaptureBuffer((PVOID)v15);
    NmDerefCaptureBuffer((PVOID)v15);
  }
  v18 = (KSPIN_LOCK *)(v15 + 40);
  if ( v12 )
    KeAcquireSpinLockAtDpcLevel(v18);
  else
    *(_BYTE *)(v15 + 48) = KeAcquireSpinLockRaiseToDpc(v18);
  v19 = *(_DWORD *)(v15 + 92);
  SpinLock_3 = (KSPIN_LOCK *)(v15 + 40);
  *(_DWORD *)(v15 + 92) = v19 + v9;
  if ( v12 )
    KeReleaseSpinLockFromDpcLevel(SpinLock_3);
  else
    KeReleaseSpinLock(SpinLock_3, *(_BYTE *)(v15 + 48));
  SpinLock_4 = (KSPIN_LOCK *)(v8 + 32);
  if ( v12 )
    KeReleaseSpinLockFromDpcLevel(SpinLock_4);
  else
    KeReleaseSpinLock(SpinLock_4, v8[40]);
  v22 = *(_MDL **)(v15 + 8);
  MdlAddress = v22;
  if ( v22 )
  {
    if ( v22->MdlFlags & 5 )
      MappedSystemVa = (char *)v22->MappedSystemVa;
    else
      MappedSystemVa = (char *)MmMapLockedPagesSpecifyCache(v22, 0, MmCached, 0i64, 0, NormalPagePriority);
    v24 = v22->ByteOffset;
    v25 = v22->ByteCount;
  }
  else
  {
    MappedSystemVa = 0i64;
    v24 = 0;
    v25 = 0;
  }
  if ( v22 )
  {
    v26 = v25;
    if ( v25 > v19 )
    {
LABEL_37:
      v36 = v25 - v19;
      v35 = v19 + v24;
      v34 = &MappedSystemVa[v19];
      if ( !(unsigned int)NmCopyBufferToMdlWrapper(&MdlAddress, a2a, 0x18u, &a3) && a3 == 24 )
      {
        v27 = a3a;
        if ( !a3a || !(unsigned int)NmCopyBufferToMdlWrapper(&MdlAddress, a7, a3a, &a3) && a3 == v27 )
        {
          a3 = 0;
          v28 = v37 ? (unsigned int)NmCopyNetBufferToMdlWrapper(&MdlAddress, (__int64)v37, &a3) : 0;
          if ( !v28 )
          {
            _InterlockedAdd((volatile signed __int32 *)(v15 + 120), 1u);
            NmDerefCaptureBuffer((PVOID)v15);
            return 0i64;
          }
        }
      }
    }
    else
    {
      while ( 1 )
      {
        v22 = v22->Next;
        v19 -= v26;
        MdlAddress = v22;
        if ( !v22 )
          break;
        if ( v22->MdlFlags & 5 )
          MappedSystemVa = (char *)v22->MappedSystemVa;
        else
          MappedSystemVa = (char *)MmMapLockedPagesSpecifyCache(v22, 0, MmCached, 0i64, 0, NormalPagePriority);
        v24 = v22->ByteOffset;
        v25 = v22->ByteCount;
        if ( v26 > v19 )
          goto LABEL_37;
      }
    }
  }
  SpinLock_5 = (KSPIN_LOCK *)(v15 + 40);
  if ( v12 )
    KeAcquireSpinLockAtDpcLevel(SpinLock_5);
  else
    *(_BYTE *)(v15 + 48) = KeAcquireSpinLockRaiseToDpc(SpinLock_5);
  *(_DWORD *)(v15 + 92) = v16;
  SpinLock_6 = (KSPIN_LOCK *)(v15 + 40);
  if ( v12 )
    KeReleaseSpinLockFromDpcLevel(SpinLock_6);
  else
    KeReleaseSpinLock(SpinLock_6, *(_BYTE *)(v15 + 48));
  *(_DWORD *)(*(_QWORD *)(v15 + 16) + 48i64) = STATUS_INSUFFICIENT_RESOURCES;
  ++*(_DWORD *)(v15 + 124);
  NmDerefCaptureBuffer((PVOID)v15);
  return STATUS_INSUFFICIENT_RESOURCES;
}

//----- (000000000001628C) ----------------------------------------------------
__int64 __fastcall NmCopyNetBufferToMdlWrapper(PMDL *MdlAddress, __int64 a2, _DWORD *a3)
{
  _MDL *mdl; // rbx
  unsigned int v4; // edi
  unsigned int v5; // ebp
  _DWORD *v6; // r12
  __int64 v7; // rsi
  PMDL *MdlAddress_1; // r13
  PVOID MappedSystemVa; // r8
  __int64 v10; // rax
  PVOID MappedSystemVa_1; // rdx
  unsigned int i; // ecx
  unsigned int v13; // er8
  int v14; // ecx
  int a4; // [rsp+68h] [rbp+20h]

  mdl = *(_MDL **)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 24);
  v5 = 0;
  a4 = 0;
  v6 = a3;
  v7 = a2;
  MdlAddress_1 = MdlAddress;
  if ( mdl->MdlFlags & 5 )
    MappedSystemVa = mdl->MappedSystemVa;
  else
    MappedSystemVa = MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
  v10 = *(unsigned int *)(v7 + 16);
  MappedSystemVa_1 = (char *)MappedSystemVa + v10;
  for ( i = mdl->ByteCount - v10; v4; i = mdl->ByteCount )
  {
    v13 = v4;
    if ( i < v4 )
      v13 = i;
    v5 = NmCopyBufferToMdlWrapper(MdlAddress_1, MappedSystemVa_1, v13, &a4);
    if ( v5 )
      break;
    v14 = a4;
    mdl = mdl->Next;
    *v6 += a4;
    v4 -= v14;
    if ( !mdl )
      break;
    if ( mdl->MdlFlags & 5 )
      MappedSystemVa_1 = mdl->MappedSystemVa;
    else
      MappedSystemVa_1 = MmMapLockedPagesSpecifyCache(mdl, 0, MmCached, 0i64, 0, NormalPagePriority);
  }
  return v5;
}

//----- (0000000000016378) ----------------------------------------------------
void __fastcall NmSyncTimerSystem(FilterDeviceExtension *Context)
{
  LARGE_INTEGER PerformanceFrequency; // [rsp+30h] [rbp+8h]

  _RBX = Context;
  if ( Context )
  {
    _RAX = MEMORY[0xFFFFF78000000014];
    __asm { xchg    rax, [rcx+240h]; Exchange Register/Memory with Register }
    _RAX = KeQueryPerformanceCounter(&PerformanceFrequency);
    _RCX = PerformanceFrequency;
    __asm
    {
      xchg    rcx, [rbx+250h]; Exchange Register/Memory with Register
      xchg    rax, [rbx+248h]; Exchange Register/Memory with Register
    }
    _InterlockedExchange((volatile signed __int32 *)&_RBX->field_254 + 1, 0);
  }
}

//----- (00000000000163D8) ----------------------------------------------------
void __fastcall ScanLongTimersDpc(struct _KDPC *Dpc, FilterDeviceExtension *DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  FilterDeviceExtension *Context; // rbx
  __int64 *v5; // r12
  volatile signed __int32 *i; // rbp
  KSPIN_LOCK *SpinLock; // rcx
  __int64 v8; // rsi
  int v9; // eax
  KSPIN_LOCK *v10; // rcx

  Context = DeferredContext;
  KeAcquireSpinLockAtDpcLevel(&DeferredContext->SpinLock);
  v5 = &Context->char2E8;
  if ( (__int64 *)*v5 != v5 && !LOBYTE(Context->field_23C) )
  {
    for ( i = (volatile signed __int32 *)*v5; i != (volatile signed __int32 *)v5; i = *(volatile signed __int32 **)i )
    {
      _InterlockedAdd(i + 4, 1u);
      SpinLock = &Context->SpinLock;
      v8 = *((_QWORD *)i + 10);
      if ( (volatile signed __int32 *)v8 == i + 20 )
      {
        KeReleaseSpinLockFromDpcLevel(SpinLock);
      }
      else
      {
        _InterlockedAdd((volatile signed __int32 *)(v8 + 16), 1u);
        KeReleaseSpinLockFromDpcLevel(SpinLock);
        KeAcquireSpinLockAtDpcLevel(*(PKSPIN_LOCK *)(v8 - 16));
        if ( (*(_DWORD *)(v8 + 48) || *(_QWORD *)(*(_QWORD *)(v8 - 8) + 112i64) != *(_QWORD *)(v8 - 8) + 112i64)
          && (v9 = *(_DWORD *)(v8 - 48), v9 & 2)
          && !(v9 & 1) )
        {
          v10 = *(KSPIN_LOCK **)(v8 - 16);
          *(_DWORD *)(v8 - 48) = v9 & 0xFFFFFFFD;
          KeReleaseSpinLockFromDpcLevel(v10);
          NmDerefCaptureBuffer((PVOID)(v8 - 72));
        }
        else
        {
          KeReleaseSpinLockFromDpcLevel(*(PKSPIN_LOCK *)(v8 - 16));
        }
        NmDerefCaptureBuffer((PVOID)(v8 - 72));
      }
      NmDerefUserProc((FileContext *)(i - 2));
      KeAcquireSpinLockAtDpcLevel(&Context->SpinLock);
    }
  }
  KeReleaseSpinLockFromDpcLevel(&Context->SpinLock);
  if ( Context->NdisFilterHandle && g_TimeSyncIntervalCount == _InterlockedIncrement((volatile signed __int32 *)&Context->field_254 + 1) )
    NmSyncTimerSystem(Context);
  KeAcquireSpinLockAtDpcLevel(&Context->SpinLock);
  if ( Context->State >= 5 )
  {
    if ( _InterlockedExchangeAdd(&Context->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule(Context);
  }
  else
  {
    KeSetTimer(&Context->Timer, (LARGE_INTEGER)-Context->DueTime, &Context->Dpc);
  }
  LOBYTE(Context->field_23C) = 0;
  KeReleaseSpinLockFromDpcLevel(&Context->SpinLock);
}
// 19120: using guessed type int g_TimeSyncIntervalCount;

//----- (0000000000016580) ----------------------------------------------------
void __fastcall NmInitializeTimerSystem(FilterDeviceExtension *DeviceExtension)
{
  FilterDeviceExtension *Context; // rsi
  LARGE_INTEGER DueTime; // rdx

  Context = DeviceExtension;
  if ( !DeviceExtension->gap2E0[0] )
  {
    KeInitializeDpc(&DeviceExtension->Dpc, (PKDEFERRED_ROUTINE)ScanLongTimersDpc, DeviceExtension);
    KeInitializeTimer(&Context->Timer);
    DueTime.QuadPart = -Context->DueTime;
    _InterlockedAdd(&Context->field_210, 1u);
    KeSetTimer(&Context->Timer, DueTime, &Context->Dpc);
    NmSyncTimerSystem(Context);
    Context->gap2E0[0] = 1;
  }
}

//----- (0000000000016610) ----------------------------------------------------
BOOL __fastcall NmStopTimerSystem(FilterDeviceExtension *DeviceExtension)
{
  FilterDeviceExtension *DeviceExtension_1; // rbx
  BOOL b; // edi

  DeviceExtension_1 = DeviceExtension;
  b = TRUE;
  if ( DeviceExtension->gap2E0[0] )
  {
    DeviceExtension->gap2E0[0] = 0;
    b = KeCancelTimer(&DeviceExtension->Timer);
    if ( _InterlockedExchangeAdd(&DeviceExtension_1->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule(DeviceExtension_1);
  }
  return b;
}

//----- (0000000000016670) ----------------------------------------------------
void __fastcall NmDerefUserProc(FileContext *FsContext)
{
  struct _WORK_QUEUE_ITEM *WorkItem; // rcx

  if ( _InterlockedExchangeAdd(&FsContext->gap18, 0xFFFFFFFF) == 1 )
  {
    *(_QWORD *)&FsContext->ShareAccess.SharedDelete = FsContext;
    WorkItem = (struct _WORK_QUEUE_ITEM *)&FsContext->ShareAccess;
    WorkItem->List.Flink = 0i64;
    WorkItem->WorkerRoutine = (PWORKER_THREAD_ROUTINE)NmDestroyUserProc;
    ExQueueWorkItem(WorkItem, DelayedWorkQueue);
  }
}

//----- (00000000000166B4) ----------------------------------------------------
NTSTATUS __fastcall NmOpenUserProc(FilterDeviceExtension *FilterDeviceExtension, PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation)
{
  _IO_STACK_LOCATION *CurrentStackLocation_1; // rsi
  PIRP irp; // rbx
  FilterDeviceExtension *DeviceExtension; // r12
  PEPROCESS CurrentProcess; // r13
  unsigned __int8 CurrentIrql; // r14
  FileContext *fc; // rax
  FileContext *pfc; // rbx
  NTSTATUS NtStatus; // ebx
  volatile FileContext *FsContext; // rdi
  BOOL DesiredShareAccess; // edx
  NTSTATUS Status; // er13
  FileContext *temp; // [rsp+78h] [rbp+10h]
  FileContext *ctx; // [rsp+88h] [rbp+20h]

  CurrentStackLocation_1 = CurrentStackLocation;
  irp = Irp;
  DeviceExtension = FilterDeviceExtension;
  CurrentProcess = IoGetCurrentProcess();
  if ( !irp->AssociatedIrp.MasterIrp )
    return STATUS_INVALID_ADDRESS_COMPONENT;
  CurrentIrql = KeGetCurrentIrql();
  __writecr8(1ui64);
  ExAcquireResourceExclusiveLite(&DeviceExtension->eresource, 1u);
  fc = (FileContext *)ExAllocatePoolWithTag(NonPagedPool, 0x158ui64, 'u3MN');// 又是一个大结构。应该是文件上下文。
  pfc = fc;
  if ( !fc )
  {
    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    goto LABEL_16;
  }
  memset(fc, 0, 0x158u);
  pfc->WorkItem = 0i64;
  pfc->SpinLock = 0i64;
  pfc->word0 = 344;
  pfc->FilterDeviceExtension = DeviceExtension;
  pfc->word2 = 18175;
  pfc->qword10 = (char *)pfc + 8;               // 这几个应该是链表。
  pfc->qword8 = (char *)pfc + 8;
  pfc->qword60 = (char *)pfc + 88;
  pfc->next = (FileContext *)((char *)pfc + 88);
  ctx = pfc;
  pfc->qword78 = (char *)pfc + 112;
  pfc->qword70 = (char *)pfc + 112;
  NtStatus = NmCreateUserProc(DeviceExtension, &temp, &ctx);
  if ( NtStatus < 0 )
  {
LABEL_16:
    ExReleaseResourceLite(&DeviceExtension->eresource);
    goto LABEL_17;
  }
  FsContext = temp;
  temp->CurrentProcess = CurrentProcess;
  DesiredShareAccess = CurrentStackLocation_1->Parameters.Create.ShareAccess & 1 || CurrentStackLocation_1->Parameters.Create.ShareAccess & 2;
  IoSetShareAccess(1u, DesiredShareAccess, CurrentStackLocation_1->FileObject, &FsContext->ShareAccess);
  Status = SeAssignSecurity(
             0i64,
             CurrentStackLocation_1->Parameters.Create.SecurityContext->AccessState->SecurityDescriptor,
             &FsContext->NewDescriptor,
             0,
             &CurrentStackLocation_1->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext,
             &g_GenericMapping,
             PagedPool);
  if ( Status < 0 )
  {
    IoRemoveShareAccess(CurrentStackLocation_1->FileObject, &FsContext->ShareAccess);
    FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    LODWORD(FsContext->field_40) |= 0x40u;
    KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    ExReleaseResourceLite(&DeviceExtension->eresource);
    NmDerefUserProc((FileContext *)FsContext);
    return Status;
  }
  ExReleaseResourceLite(&DeviceExtension->eresource);
  if ( DeviceExtension->State == FilterPaused )
  {
    CurrentStackLocation_1->FileObject->FsContext = (PVOID)FsContext;
    CurrentStackLocation_1->FileObject->FsContext2 = (PVOID)18175;
    FsContext->FileObject = CurrentStackLocation_1->FileObject;
    _InterlockedAdd(&FsContext->gap18, 1u);
    FsContext = temp;
    NtStatus = STATUS_SUCCESS;
  }
  else
  {
    NtStatus = STATUS_DEVICE_NOT_READY;
  }
  NmDerefUserProc((FileContext *)FsContext);
LABEL_17:
  __writecr8(CurrentIrql);
  return NtStatus;
}

//----- (00000000000168EC) ----------------------------------------------------
__int64 __fastcall NmCreateUserProc(FilterDeviceExtension *FilterDeviceExtension, FileContext **ctx1, FileContext **ctx2)
{
  FilterDeviceExtension *DeviceExtension; // rdi
  FileContext *ctx; // rcx
  FileContext **ctx_1; // rsi
  FileContext **ctx_2; // rbp
  KIRQL irql; // al
  FileContext *v8; // r8
  _QWORD *v9; // rax

  DeviceExtension = FilterDeviceExtension;
  ctx = *ctx2;
  ctx_1 = ctx2;
  ctx->gap18 = 1;
  ctx_2 = ctx1;
  LODWORD(ctx->field_40) = 32;
  memset(&ctx->field_128, -1, 0x28u);
  irql = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->SpinLock);
  v8 = *ctx_1;
  DeviceExtension->irql = irql;
  v9 = (_QWORD *)DeviceExtension->field_2F0;
  v8 = (FileContext *)((char *)v8 + 8);
  v8->qword8 = v9;
  *(_QWORD *)&v8->word0 = (char *)DeviceExtension + 744;
  *v9 = v8;
  DeviceExtension->field_2F0 = (__int64)v8;
  KeReleaseSpinLock(&DeviceExtension->SpinLock, DeviceExtension->irql);
  (*ctx_1)->FilterDeviceExtension = DeviceExtension;
  _InterlockedAdd(&DeviceExtension->field_210, 1u);
  *ctx_2 = *ctx_1;
  return 0i64;
}

//----- (00000000000169A8) ----------------------------------------------------
__int64 __fastcall NmVerifyUserProcObject(FileContext *FsContext)
{
  FileContext *pfc; // rdi
  MACRO_STATUS_CLUSTER NtStatus; // ebx

  pfc = FsContext;
  NtStatus = STATUS_SUCCESS;
  if ( FsContext && FsContext->word0 == 344 && FsContext->word2 == 18175 )
  {
    FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
    if ( pfc->field_40 & 0x40 )
    {
      NtStatus = STATUS_INVALID_ADDRESS;
    }
    else
    {
      _InterlockedAdd(&pfc->gap18, 1u);
      NtStatus = STATUS_SUCCESS;
    }
    KeReleaseSpinLock(&pfc->SpinLock, pfc->irql);
  }
  return NtStatus;
}

//----- (0000000000016A2C) ----------------------------------------------------
// 是一个WorkerRoutine。
__int64 __fastcall NmDestroyUserProc(FileContext *Parameter)
{
  FilterDeviceExtension *DeviceExtension; // rdi
  FileContext *FsContext; // rbp
  __int64 v3; // rdx
  _QWORD *v4; // rax
  _QWORD **v5; // rsi
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx
  _QWORD *v8; // rdx
  _QWORD *v9; // rax
  signed __int32 v10; // eax
  bool b; // zf
  __int64 result; // rax

  DeviceExtension = Parameter->FilterDeviceExtension;
  FsContext = Parameter;
  SeDeassignSecurity(&Parameter->NewDescriptor);
  DeviceExtension->irql = KeAcquireSpinLockRaiseToDpc(&DeviceExtension->SpinLock);
  v3 = FsContext->qword8;
  v4 = (_QWORD *)FsContext->qword10;
  *v4 = v3;
  *(_QWORD *)(v3 + 8) = v4;
  KeReleaseSpinLock(&DeviceExtension->SpinLock, DeviceExtension->irql);
  v5 = (_QWORD **)&FsContext->qword70;
  if ( *v5 != v5 )
  {
    v6 = *v5;
    if ( *v5 != v5 )
    {
      do
      {
        v7 = (_QWORD *)*v6;
        v8 = (_QWORD *)*v6;
        v9 = (_QWORD *)v6[1];
        *v9 = *v6;
        v8[1] = v9;
        ExFreePoolWithTag((char *)v6 - 4, 0);
        v6 = v7;
      }
      while ( v7 != v5 );
    }
  }
  ExFreePoolWithTag(FsContext, 0);
  v10 = _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF);
  b = v10 == 1;
  result = (unsigned int)(v10 - 1);
  if ( b )
    NmDestroyFilterModule(DeviceExtension);
  return result;
}

//----- (0000000000016B00) ----------------------------------------------------
void __fastcall NmStopUserProc(FileContext *FsContext)
{
  FilterDeviceExtension *FilterDeviceExtension; // r14
  FileContext *Context; // rdi
  KIRQL irql; // al
  bool b; // zf
  KSPIN_LOCK *SpinLock; // rcx
  KIRQL irql_1; // dl
  KIRQL irql_2; // al
  FileContext **next; // r12
  __int64 v9; // rsi
  KIRQL irql_3; // al

  FilterDeviceExtension = FsContext->FilterDeviceExtension;
  Context = FsContext;
  irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
  b = (Context->field_40 & 0x40) == 0;
  SpinLock = &Context->SpinLock;
  Context->irql = irql;
  if ( b )
  {
    _InterlockedAdd(&Context->gap18, 1u);
    irql_1 = Context->irql;
    LODWORD(Context->field_40) |= 0x40u;
    KeReleaseSpinLock(SpinLock, irql_1);
    irql_2 = KeAcquireSpinLockRaiseToDpc(&Context->SpinLock);
    next = (FileContext **)Context->next;
LABEL_8:
    Context->irql = irql_2;
    while ( next != &Context->next )
    {
      v9 = (__int64)(next - 9);
      next = (FileContext **)*next;
      if ( !(*(_BYTE *)(v9 + 24) & 1) && *(_BYTE *)(v9 + 24) & 2 )
      {
        _InterlockedAdd((volatile signed __int32 *)(v9 + 88), 1u);
        if ( *(_BYTE *)(v9 + 24) & 2 )
        {
          irql_3 = KeAcquireSpinLockRaiseToDpc(&FilterDeviceExtension->SpinLock);
          LOBYTE(FilterDeviceExtension->field_23C) = 1;
          FilterDeviceExtension->irql = irql_3;
          KeReleaseSpinLock(&FilterDeviceExtension->SpinLock, irql_3);
          *(_DWORD *)(v9 + 24) &= 0xFFFFFFFD;
        }
        *(_DWORD *)(*(_QWORD *)(v9 + 16) + 48i64) = STATUS_INVALID_HANDLE;
        *(_QWORD *)(*(_QWORD *)(v9 + 16) + 56i64) = 0i64;
        KeReleaseSpinLock(&Context->SpinLock, Context->irql);
        NmDerefCaptureBuffer((PVOID)v9);
        NmDerefCaptureBuffer((PVOID)v9);
        irql_2 = KeAcquireSpinLockRaiseToDpc(&Context->SpinLock);
        goto LABEL_8;
      }
    }
    KeReleaseSpinLock(&Context->SpinLock, Context->irql);
    NmDerefUserProc(Context);
  }
  else
  {
    KeReleaseSpinLock(SpinLock, irql);
  }
}

//----- (0000000000016C44) ----------------------------------------------------
NTSTATUS __fastcall NmUserProcCaptureStart(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  FilterDeviceExtension *DeviceExtension; // rbx
  PIRP irp; // rdi
  NTSTATUS NtStatus; // esi
  NTSTATUS result; // eax
  _IO_STACK_LOCATION *CurrentStackLocation; // rax
  PIRP MasterIrp; // r13
  FileContext *FsContext; // rbp
  NTSTATUS Status; // eax
  NTSTATUS status; // er12
  KIRQL irql; // al
  int v12; // edx
  unsigned int IrpCount; // ecx

  DeviceExtension = (FilterDeviceExtension *)DeviceObject->DeviceExtension;
  irp = Irp;
  NtStatus = 0;
  if ( TestFilterModuleSignature(DeviceObject) )
  {
    _InterlockedAdd(&DeviceExtension->field_210, 1u);
    CurrentStackLocation = irp->Tail.Overlay.CurrentStackLocation;
    irp->IoStatus.Information = 0i64;
    if ( CurrentStackLocation->Parameters.Create.Options >= 0x20 )
    {
      MasterIrp = irp->AssociatedIrp.MasterIrp;
      if ( MasterIrp->Type == 0x20 )
      {
        FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
        Status = NmVerifyUserProcObject(FsContext);
        status = Status;
        if ( Status )
        {
          irp->IoStatus.Status = Status;
          IofCompleteRequest(irp, IO_NETWORK_INCREMENT);
          NtStatus = status;
        }
        else
        {
          irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
          v12 = FsContext->field_40;
          FsContext->irql = irql;
          if ( v12 & 0x40 || (v12 & 0x80u) != 0 )
          {
            NtStatus = STATUS_DEVICE_BUSY;
          }
          else
          {
            FsContext->field_88 = (__int64)MasterIrp->MdlAddress;
            LODWORD(FsContext->field_90) = *(&MasterIrp->Flags + 1);
            IrpCount = MasterIrp->AssociatedIrp.IrpCount;
            if ( IrpCount < LODWORD(DeviceExtension->field_234) )
              IrpCount = DeviceExtension->field_234;
            LODWORD(FsContext->field_40) = v12 | 0x80;
            HIDWORD(FsContext->field_90) = IrpCount;
            if ( LOBYTE(DeviceExtension->gap224) )
              LODWORD(FsContext->field_90) &= 0xFFFFFFF7;
            if ( (~(unsigned __int8)(LODWORD(FsContext->field_90) >> 3) & 1) == 1 )
              _InterlockedAdd(&DeviceExtension->dword220, 1u);
          }
          KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
          NmDerefUserProc(FsContext);
        }
        if ( !NtStatus )
        {
          NmInitializeTimerSystem(DeviceExtension);
          _InterlockedAdd(&DeviceExtension->gap218, 1u);
          NmSetAppropriatePacketFilter(DeviceExtension, 1);
        }
      }
      else
      {
        NtStatus = NDIS_STATUS_INVALID_PARAMETER;
      }
    }
    else
    {
      NtStatus = NDIS_STATUS_BUFFER_OVERFLOW;
    }
    if ( _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule(DeviceExtension);
    result = NtStatus;
  }
  else
  {
    irp->IoStatus.Information = 0i64;
    irp->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
    IofCompleteRequest(irp, IO_NO_INCREMENT);
    result = NDIS_STATUS_INVALID_STATE;
  }
  return result;
}

//----- (0000000000016DE0) ----------------------------------------------------
void __fastcall NmUploadCaptureBuffer(volatile FilterDeviceExtension *DeviceExtension, FileContext *FsContext)
{
  FileContext *Context; // r12
  volatile FilterDeviceExtension *DeviceExtension_1; // rdi
  KIRQL CurrentIrql; // al
  KSPIN_LOCK *SpinLock_1; // rbx
  BOOL is_dpc; // esi
  KSPIN_LOCK *SpinLock; // rcx
  BOOL b; // er15
  KSPIN_LOCK *SpinLock_2; // rcx
  __int64 v10; // rax
  FileContext *v11; // r13
  __int64 v12; // r14
  int v13; // ecx
  KSPIN_LOCK *SpinLock_3; // rcx
  KSPIN_LOCK *SpinLock_4; // rcx
  KSPIN_LOCK *SpinLock_5; // rcx

  Context = FsContext;
  DeviceExtension_1 = DeviceExtension;
  CurrentIrql = KeGetCurrentIrql();
  SpinLock_1 = &DeviceExtension->SpinLock;
  is_dpc = CurrentIrql == (unsigned __int8)DISPATCH_LEVEL;
  SpinLock = &DeviceExtension->SpinLock;
  if ( CurrentIrql == DISPATCH_LEVEL )
    KeAcquireSpinLockAtDpcLevel(SpinLock);
  else
    DeviceExtension_1->irql = KeAcquireSpinLockRaiseToDpc(SpinLock);
  b = NmStopTimerSystem((FilterDeviceExtension *)DeviceExtension_1);
  if ( is_dpc )
    KeReleaseSpinLockFromDpcLevel(SpinLock_1);
  else
    KeReleaseSpinLock(SpinLock_1, DeviceExtension_1->irql);
  if ( b )
  {
    SpinLock_2 = &Context->SpinLock;
    if ( is_dpc )
      KeAcquireSpinLockAtDpcLevel(SpinLock_2);
    else
      Context->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_2);
    v10 = (__int64)&Context->next;
    v11 = Context->next;
    while ( v11 != (FileContext *)v10 && b )
    {
      v12 = (__int64)&v11[-1].field_110;
      v13 = v11[-1].field_128;
      if ( v13 & 1 || !(v13 & 2) )
      {
        v11 = *(FileContext **)&v11->word0;
      }
      else
      {
        if ( !*(_DWORD *)(v12 + 120) )
        {
          if ( *(_QWORD *)(*(_QWORD *)(v12 + 64) + 112i64) == *(_QWORD *)(v12 + 64) + 112i64 )
            break;
          b = 0;
        }
        *(_DWORD *)(v12 + 24) = v13 & 0xFFFFFFFD | 1;
        v11 = *(FileContext **)&v11->word0;
        SpinLock_3 = &Context->SpinLock;
        if ( is_dpc )
          KeReleaseSpinLockFromDpcLevel(SpinLock_3);
        else
          KeReleaseSpinLock(SpinLock_3, Context->irql);
        NmDerefCaptureBuffer((PVOID)v12);
        SpinLock_4 = &Context->SpinLock;
        if ( is_dpc )
          KeAcquireSpinLockAtDpcLevel(SpinLock_4);
        else
          Context->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_4);
        v10 = (__int64)&Context->next;
      }
    }
    memmove(&Context->field_C8, &Context->field_F8, 0x30u);
    SpinLock_5 = &Context->SpinLock;
    if ( is_dpc )
      KeReleaseSpinLockFromDpcLevel(SpinLock_5);
    else
      KeReleaseSpinLock(SpinLock_5, Context->irql);
    if ( is_dpc )
      KeAcquireSpinLockAtDpcLevel(SpinLock_1);
    else
      DeviceExtension_1->irql = KeAcquireSpinLockRaiseToDpc(SpinLock_1);
    if ( DeviceExtension_1->gap218 )
      NmInitializeTimerSystem((FilterDeviceExtension *)DeviceExtension_1);
    if ( is_dpc )
      KeReleaseSpinLockFromDpcLevel(SpinLock_1);
    else
      KeReleaseSpinLock(SpinLock_1, DeviceExtension_1->irql);
  }
}

//----- (0000000000016FC4) ----------------------------------------------------
NTSTATUS __fastcall NmUserProcCaptureStop(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  volatile FilterDeviceExtension *DeviceExtension; // rbx
  PIRP irp; // rdi
  NTSTATUS NtStatus; // esi
  NTSTATUS result; // eax
  FileContext *FsContext; // rbp
  NTSTATUS Status; // eax
  NTSTATUS status; // er12
  int v9; // eax

  DeviceExtension = (volatile FilterDeviceExtension *)DeviceObject->DeviceExtension;
  irp = Irp;
  NtStatus = 0;
  if ( TestFilterModuleSignature(DeviceObject) )
  {
    _InterlockedAdd(&DeviceExtension->field_210, 1u);
    irp->IoStatus.Information = 0i64;
    FsContext = (FileContext *)irp->Tail.Overlay.CurrentStackLocation->FileObject->FsContext;
    Status = NmVerifyUserProcObject(FsContext);
    status = Status;
    if ( Status )
    {
      irp->IoStatus.Status = Status;
      IofCompleteRequest(irp, IO_NETWORK_INCREMENT);
      NtStatus = status;
    }
    else
    {
      FsContext->irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
      v9 = FsContext->field_40;
      if ( v9 & 0x40 || (v9 & 0x80u) == 0 )
      {
        NtStatus = STATUS_DEVICE_BUSY;
      }
      else
      {
        LODWORD(FsContext->field_40) = v9 & 0xFFFFFF7F;
        if ( ~(LODWORD(FsContext->field_90) >> 3) & 1 )
          _InterlockedAdd(&DeviceExtension->dword220, 0xFFFFFFFF);
      }
      KeReleaseSpinLock(&FsContext->SpinLock, FsContext->irql);
    }
    if ( !NtStatus )
    {
      _InterlockedAdd(&DeviceExtension->gap218, 0xFFFFFFFF);
      NmSetAppropriatePacketFilter((FilterDeviceExtension *)DeviceExtension, -1);
      NmUploadCaptureBuffer(DeviceExtension, FsContext);
    }
    NmDerefUserProc(FsContext);
    if ( _InterlockedExchangeAdd(&DeviceExtension->field_210, 0xFFFFFFFF) == 1 )
      NmDestroyFilterModule((FilterDeviceExtension *)DeviceExtension);
    result = NtStatus;
  }
  else
  {
    irp->IoStatus.Information = 0i64;
    irp->IoStatus.Status = NDIS_STATUS_INVALID_STATE;
    IofCompleteRequest(irp, IO_NO_INCREMENT);
    result = NDIS_STATUS_INVALID_STATE;
  }
  return result;
}

//----- (00000000000170EC) ----------------------------------------------------
NTSTATUS __fastcall NmCloseUserProc(PIRP Irp, _IO_STACK_LOCATION *CurrentStackLocation)
{
  FileContext *FsContext; // rbp
  FilterDeviceExtension *FilterDeviceExtension; // rsi
  KIRQL irql; // al
  int v5; // ebx

  FsContext = (FileContext *)CurrentStackLocation->FileObject->FsContext;
  FilterDeviceExtension = FsContext->FilterDeviceExtension;
  KeEnterCriticalRegion();
  ExAcquireResourceExclusiveLite(&FsContext->FilterDeviceExtension->eresource, 1u);
  IoRemoveShareAccess(FsContext->FileObject, &FsContext->ShareAccess);
  ExReleaseResourceLite(&FsContext->FilterDeviceExtension->eresource);
  KeLeaveCriticalRegion();
  irql = KeAcquireSpinLockRaiseToDpc(&FsContext->SpinLock);
  v5 = LODWORD(FsContext->field_40) >> 7;
  FsContext->irql = irql;
  KeReleaseSpinLock(&FsContext->SpinLock, irql);
  if ( !(~v5 & 1) )
    _InterlockedAdd(&FilterDeviceExtension->gap218, 0xFFFFFFFF);
  NmDerefUserProc(FsContext);
  return STATUS_SUCCESS;
}

//----- (00000000000171A0) ----------------------------------------------------
void __fastcall NmUserProcGetStats(PDEVICE_OBJECT DeviceObject, FileContext *Context)
{
  FilterDeviceExtension *DeviceExtension; // rdi
  FileContext *ctx; // rbx
  KIRQL irql; // al
  struct _IO_WORKITEM *WorkItem; // rcx
  __int64 a3; // [rsp+38h] [rbp+10h]
  __int64 v7; // [rsp+40h] [rbp+18h]

  DeviceExtension = Context->FilterDeviceExtension;
  ctx = Context;
  if ( !NmGetGlobalStat(DeviceExtension, 0x20102, &a3, 4u) )
    HIDWORD(ctx->field_128) = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x20207, &v7, 8u) )
    ctx->field_138 = v7;
  if ( !NmGetGlobalStat(DeviceExtension, 0x20104, &a3, 4u) )
    HIDWORD(ctx->field_148) = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x2020D, &a3, 4u) )
    LODWORD(ctx->field_130) = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x20105, &a3, 4u) )
    LODWORD(ctx->field_140) = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x2020A, &a3, 4u) )
    HIDWORD(ctx->field_140) = a3;
  if ( !NmGetGlobalStat(DeviceExtension, 0x2020C, &a3, 4u) )
    LODWORD(ctx->field_148) = a3;
  irql = KeAcquireSpinLockRaiseToDpc(&ctx->SpinLock);
  WorkItem = ctx->WorkItem;
  LODWORD(ctx->field_B8) = 0;
  ctx->irql = irql;
  if ( WorkItem )
  {
    IoFreeWorkItem(WorkItem);
    ctx->WorkItem = NULL;
  }
  KeReleaseSpinLock(&ctx->SpinLock, ctx->irql);
  NmDerefUserProc(ctx);
}

//----- (000000000001B008) ----------------------------------------------------
void __fastcall NmInitializeMinipInfo(NDIS_MEDIUM MiniportMediaType, FilterDeviceExtension *FilterModuleContext)
{
  FilterDeviceExtension *ModuleContext; // rbx
  NDIS_MEDIUM MediaType; // ebp
  bool v4; // zf
  unsigned int status; // eax
  int NmDebug; // ecx
  unsigned int status_1; // ebp
  __int64 v8; // [rsp+20h] [rbp-48h]
  __int64 a3; // [rsp+30h] [rbp-38h]
  __int64 v10; // [rsp+38h] [rbp-30h]
  __int64 v11; // [rsp+40h] [rbp-28h]
  __int64 v12; // [rsp+78h] [rbp+10h]

  ModuleContext = FilterModuleContext;
  MediaType = MiniportMediaType;
  switch ( MiniportMediaType )
  {
    case 0:
      if ( nmOid_Query(16843009, FilterModuleContext, &FilterModuleContext->field_368, 0x20u) )
        _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
      if ( nmOid_Query(16843010, ModuleContext, &ModuleContext->field_388, 0x20u) )
        _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
      goto LABEL_38;
    case 1:
      HIDWORD(FilterModuleContext->gap224) = 2;
      LODWORD(FilterModuleContext->field_22C) = 8;
      LODWORD(FilterModuleContext->field_234) = 32;
      break;
    case 2:
      HIDWORD(FilterModuleContext->gap224) = 1;
      LODWORD(FilterModuleContext->field_22C) = 7;
      LODWORD(FilterModuleContext->field_234) = 13;
      break;
    default:
      switch ( MiniportMediaType )
      {
        case 3:
          if ( nmOid_Query(67174657, FilterModuleContext, &FilterModuleContext->field_368, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          if ( nmOid_Query(67174658, ModuleContext, &ModuleContext->field_388, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          LODWORD(ModuleContext->field_234) = 14;
          LOBYTE(ModuleContext->gap224) = 1;
          ModuleContext->field_22C = 0x600000006i64;
          goto LABEL_40;
        case 9:
          if ( nmOid_Query(16843009, FilterModuleContext, &FilterModuleContext->field_368, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          if ( nmOid_Query(16843010, ModuleContext, &ModuleContext->field_388, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          break;
        case 15:
          break;
        case 16:
          v4 = HIDWORD(FilterModuleContext->field_188) == 9;
          a3 = 0i64;
          v10 = 0i64;
          v11 = 0i64;
          if ( v4 )
          {
            if ( !FilterModuleContext->qword3B0 )
              goto LABEL_42;
            if ( !nmOid_Query(218170119, FilterModuleContext, &a3, 0x18u) )
            {
              *(_DWORD *)(ModuleContext->qword3B0 + 148i64) = HIDWORD(v11);
              if ( _bittest((const signed __int32 *)&v11 + 1, 0x1Fu) )
                *(_DWORD *)(ModuleContext->qword3B0 + 144i64) = 1;
            }
            if ( !nmOid_Query(218170120, ModuleContext, &v12, 8u) )
              pNmDot11StoreOpMode(ModuleContext->qword3B0, SHIDWORD(v12));
            nmOid_Query(65806, ModuleContext, &ModuleContext->filter, 4u);
          }
          if ( nmOid_Query(16843009, ModuleContext, &ModuleContext->field_368, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
          if ( nmOid_Query(16843010, ModuleContext, &ModuleContext->field_388, 0x20u) )
            _InterlockedAdd(&g_InternalRequestFailedCount, 1u);
LABEL_38:
          LODWORD(ModuleContext->field_234) = 14;
          ModuleContext->field_22C = 0x600000006i64;
          goto LABEL_39;
        case 19:
          break;
        default:
          goto LABEL_42;
      }
      ModuleContext->field_22C = 0i64;
      LODWORD(ModuleContext->field_234) = 0;
LABEL_39:
      LOBYTE(ModuleContext->gap224) = 0;
LABEL_40:
      HIDWORD(ModuleContext->gap224) = 0;
      goto LABEL_41;
  }
  LOBYTE(FilterModuleContext->gap224) = 0;
  HIDWORD(FilterModuleContext->field_22C) = 6;
LABEL_41:
  BYTE4(ModuleContext->field_234) = 0;
  BYTE5(ModuleContext->field_234) = 0;
LABEL_42:
  if ( HIDWORD(ModuleContext->field_188) == 9 )
  {
    if ( MediaType == 16 )
      BYTE4(ModuleContext->field_234) = 1;
  }
  else if ( LOBYTE(ModuleContext->gap224) != 1 )
  {
    status = NmQueryPacketFilter(ModuleContext, (__int64)&ModuleContext->filter);
    NmDebug = g_NmDebug;
    status_1 = status;
    if ( g_NmDebug )
    {
      DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmQueryPacketFilter: status %x, filter %d\n", status, LODWORD(ModuleContext->filter));
      NmDebug = g_NmDebug;
    }
    if ( LODWORD(ModuleContext->filter) < 0x10 )
    {
      LODWORD(ModuleContext->filter) = 11;
      if ( NmDebug )
      {
        LODWORD(v8) = 11;
        DbgPrintEx(DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL, "NmQueryPacketFilter: status %x, resetting to %x\n", status_1, v8);
      }
    }
    if ( !NmSetPacketFilter(ModuleContext, 32) )
      BYTE4(ModuleContext->field_234) = 1;
    NmSetPacketFilter(ModuleContext, ModuleContext->filter);
  }
}
// 1B3B8: variable 'v8' is possibly undefined
// 1919C: using guessed type int g_NmDebug;
// 191A8: using guessed type int g_InternalRequestFailedCount;

//----- (000000000001C008) ----------------------------------------------------
NTSTATUS __fastcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  struct _DRIVER_OBJECT *pDriverObject; // rbx
  NTSTATUS NtStatus; // edi
  RootDeviceExtension *DeviceReservedExtension; // rax
  RootDeviceExtension *DeviceExtension; // rbx
  struct _NDIS_DEVICE_OBJECT_ATTRIBUTES DeviceObjectAttributes; // [rsp+20h] [rbp-148h]
  UNICODE_STRING SymbolicName; // [rsp+58h] [rbp-110h]
  UNICODE_STRING DeviceName; // [rsp+68h] [rbp-100h]
  PDRIVER_DISPATCH MajorFunctions[28]; // [rsp+80h] [rbp-E8h] 数组元素的个数至少是IRP_MJ_MAXIMUM_FUNCTION。下面的memset，得出是28.
  PDEVICE_OBJECT pDeviceObject; // [rsp+180h] [rbp+18h]

  pDriverObject = DriverObject;
  NmInitializeGlobals(DriverObject, RegistryPath);
  NtStatus = NmRegisterFilter(pDriverObject);
  if ( NtStatus )
  {
failure:
    if ( g_GroupAce )
    {
      ExFreePoolWithTag(g_GroupAce, 0);
      g_GroupAce = NULL;
    }
    return NtStatus;
  }
  memset(MajorFunctions, 0, 0xE0u);
  MajorFunctions[IRP_MJ_CLEANUP] = (PDRIVER_DISPATCH)NmFilterRootDeviceIoCreate;
  MajorFunctions[IRP_MJ_CLOSE] = (PDRIVER_DISPATCH)NmFilterRootDeviceIoClose;
  MajorFunctions[IRP_MJ_DEVICE_CONTROL] = (PDRIVER_DISPATCH)NmFilterRootDeviceIoControl;
  MajorFunctions[0] = (PDRIVER_DISPATCH)NmFilterRootDeviceIoCreate;
  RtlInitUnicodeString(&DeviceName, L"\\Device\\nm3");
  RtlInitUnicodeString(&SymbolicName, L"\\DosDevices\\nm3");
  memset(&DeviceObjectAttributes, 0, 0x38u);
  DeviceObjectAttributes.DeviceName = &DeviceName;
  DeviceObjectAttributes.SymbolicName = &SymbolicName;
  DeviceObjectAttributes.Header.Type = NDIS_OBJECT_TYPE_DEVICE_OBJECT_ATTRIBUTES;
  DeviceObjectAttributes.MajorFunctions = MajorFunctions;
  DeviceObjectAttributes.Header.Revision = NDIS_DEVICE_OBJECT_ATTRIBUTES_REVISION_1;
  DeviceObjectAttributes.Header.Size = 0x38;
  DeviceObjectAttributes.ExtensionSize = 72;
  NtStatus = NdisRegisterDeviceEx(g_FilterDriverHandle, &DeviceObjectAttributes, &pDeviceObject, &g_FilterDeviceHandle);
  if ( !NtStatus )
  {
    DeviceReservedExtension = (RootDeviceExtension *)NdisGetDeviceReservedExtension(pDeviceObject);
    DeviceReservedExtension->Type = NDIS_OBJECT_TYPE_NSI_INTERFACE_PERSIST_RW_STRUCT;
    DeviceReservedExtension->Revision = NDIS_DEVICE_OBJECT_ATTRIBUTES_REVISION_1;
    DeviceReservedExtension->ExtensionSize = 72;
    DeviceReservedExtension->tag = 'DFMN';
    DeviceReservedExtension->init = TRUE;
    DeviceReservedExtension->DeviceObject = pDeviceObject;
    DeviceExtension = DeviceReservedExtension;
    DeviceReservedExtension->FilterDeviceHandle = g_FilterDeviceHandle;
    RtlInitUnicodeString(&DeviceReservedExtension->DeviceName, L"\\Device\\nm3");
    RtlInitUnicodeString(&DeviceExtension->SymbolicName, L"\\DosDevices\\nm3");
  }
  NmAddGroupAccessAce(pDeviceObject);
  if ( NtStatus )
  {
    NdisFDeregisterFilterDriver(g_FilterDriverHandle);
    goto failure;
  }
  return NtStatus;
}

// ALL OK, 81 function(s) have been successfully decompiled
